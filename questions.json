[
    {
        "question": "### 试题 1:\n\nChoose two. Your MySQL server was upgraded from an earlier major version. The sales database contains three tables, one of which is the transactions table, which has 4 million rows. You are running low on disk space on the datadir partition and begin to investigate. Examine these commands and output:\n\n```sql\nmysql> show global variables like 'innodb_file_%';\n+-----------------------+-------+\n| Variable_name         | Value |\n+-----------------------+-------+\n| innodb_file_per_table | ON    |\n+-----------------------+-------+\n1 row in set (0.00 sec)\n```\n\n```bash\n# ls -l | grep ib\n-rw-r----- 1 mysql mysql       3287 Dec 12 07:54 ib_buffer_pool\n-rw-r----- 1 mysql mysql 125827192912 Dec 12 09:50 ibdata1\n-rw-r----- 1 mysql mysql   50331648 Dec 12 09:50 ib_logfile0\n-rw-r----- 1 mysql mysql   50331648 Dec 11 14:05 ib_logfile1\n-rw-r----- 1 mysql mysql   12582912 Dec 12 08:05 ibtmp1\n-rw-r----- 1 mysql mysql   25165824 Dec 12 09:50 mysql.ibd\n```\n\n```bash\n# ls -l sales/\ntotal 544\n-rw-r----- 1 mysql mysql 47550136 Dec 12 09:50 sales.ibd\n-rw-r----- 1 mysql mysql   114688 Dec 11 14:33 leads.ibd\n```\n\nWhich two statements are true?",
        "selections": {
            "A": "The transactions table was created with innodb_file_per_table=OFF.",
            "B": "Truncating the sales and leads table will free up disk space.",
            "C": "Executing SET GLOBAL innodb_row_format=COMPRESSED and then ALTER TABLE transactions will free up disk space.",
            "D": "Executing ALTER TABLE transactions will enable you to free up disk space.",
            "E": "Truncating the transactions table will free up the most disk space."
        },
        "answers": [
            "A",
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n当前 `innodb_file_per_table` 设置为 `ON`，这意味着新创建的表或重建的表会使用独立的 `.ibd` 文件。然而，`ibdata1` 文件非常大（约125GB），并且在 `sales/` 目录下没有 `transactions.ibd` 文件，只有 `sales.ibd` 和 `leads.ibd`。这强烈暗示 `transactions` 表是在 `innodb_file_per_table` 为 `OFF` 时创建的，因此其数据存储在共享表空间 `ibdata1` 中 (A正确)。对于使用独立表空间 (`.ibd` 文件) 的表，如 `sales` 和 `leads`，执行 `TRUNCATE TABLE` 会删除并重建 `.ibd` 文件，从而将空间返还给操作系统 (B正确)。\n\n选项C提到的 `innodb_row_format` 不是一个全局变量，而是表级别的属性，且更改行格式本身不一定能直接通过 `SET GLOBAL` 实现。即使通过 `ALTER TABLE` 应用压缩，如果表在 `ibdata1` 中，空间也主要在 `ibdata1` 内部被标记为可用，不直接返还给OS。选项D，`ALTER TABLE` (例如 `ALTER TABLE transactions ENGINE=InnoDB;`) 如果表在 `ibdata1` 中，可以整理空间，但不会缩小 `ibdata1` 文件。如果表有自己的 `.ibd` 文件，`ALTER` 会重建表，可以回收空间。但题中 `transactions` 表在 `ibdata1` 中。选项E，由于 `transactions` 表数据在 `ibdata1` 中，`TRUNCATE` 它不会缩小 `ibdata1` 文件，空间仅在文件内部被标记为可重用，因此不会“释放最多磁盘空间”给操作系统。\n\n**考点总结:**\n此题考察对 InnoDB 表空间管理（共享表空间 `ibdata1` 与独立表空间 `innodb_file_per_table`）的理解，以及不同操作（`TRUNCATE TABLE`, `ALTER TABLE`）对磁盘空间回收的影响。关键在于区分空间是返还给操作系统还是仅在表空间内部标记为可用。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细观察命令行输出。`show global variables` 显示当前配置，而 `ls -l` 显示文件系统状态，可以推断历史配置。注意 `ibdata1` 的大小和各个 `.ibd` 文件的存在与否。当 `innodb_file_per_table=ON` 时，如果某个表没有对应的 `.ibd` 文件，则它很可能创建于该参数为 `OFF` 的时期，数据位于共享表空间。\n\n**学习建议:**\n深入学习 InnoDB 的存储结构，特别是 `innodb_file_per_table` 参数的作用和影响。理解共享表空间 (`ibdata1`) 和独立表空间的区别，以及它们在磁盘空间管理上的行为。掌握 `TRUNCATE TABLE`、`OPTIMIZE TABLE` 和 `ALTER TABLE ... ENGINE=InnoDB` 等操作如何回收空间，以及何时空间会真正返还给操作系统。"
    },
    {
        "question": "### 试题 2:\n\nExamine the following `EXPLAIN` output:\n\n```\nEXPLAIN:\n-> Sort: <temporary>.Population DESC (actual time=8.306..8.431 rows=125 loops=1)\n    -> Stream results (actual time=0.145..8.033 rows=125 loops=1)\n        -> Nested loop inner join (cost=241.12 rows=205) (actual time=0.141..7.787 rows=125 loops=1)\n            -> Filter: (world.country.Continent = 'Asia') (cost=25.40 rows=34) (actual time=0.064..0.820 rows=51 loops=1)\n                -> Table scan on country (cost=25.40 rows=239) (actual time=0.059..0.359 rows=239 loops=1)\n            -> Filter: (world.city.Population > 1000000) (cost=4.53 rows=6) (actual time=0.030..0.131 rows=2 loops=51)\n                -> Index lookup on city using CountryCode (CountryCode=world.country.Code) (cost=4.53 rows=18) (actual time=0.023..0.096 rows=35 loops=51)\n1 row in set (0.0094 sec)\n```\n\nWhich two statements are true? ",
        "selections": {
            "A": "The country table is accessed as the first table, and then joined to the city table.",
            "B": "35 rows from the city table are included in the result.",
            "C": "The optimizer estimates that 51 rows in the country table have Continent = 'Asia'.",
            "D": "It takes more than 8 milliseconds to sort the rows.",
            "E": "The query returns exactly 125 rows."
        },
        "answers": [
            "A",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n\nA) 在 `Nested loop inner join` 中，`country` 表的访问（`Table scan on country`）在 `city` 表的访问（`Index lookup on city`）之上，表明 `country` 表是驱动表（外部表），先被访问，然后其结果用于连接 `city` 表 (A 正确)。\n\nB) `Index lookup on city` 显示 `actual time=... rows=35 loops=51`。这意味着对于 `country` 表中满足条件的51行，每次查找 `city` 表时，平均（或在某些迭代中）处理了35行。但最终参与 `Nested loop inner join` 且满足 `city.Population > 1000000` 条件的是 `actual time=... rows=2 loops=51`，这表明每次匹配的 `country` 行，平均有2行 `city` 记录满足条件并进入连接。最终结果集有125行，不能直接说从 city 表中取了35行进入最终结果 (B 错误)。\n\nC) 对于 `country` 表的 `Filter: (world.country.Continent = 'Asia')`，优化器估计 `rows=34`，但实际 `actual time=... rows=51 loops=1`。所以优化器估计是34行，实际是51行 (C 错误)。\n\nD) `Sort: ... (actual time=8.306..8.431 rows=125 loops=1)`。排序花费的时间是 `8.431 - 8.306 = 0.125` 毫秒，这远小于8毫秒 (D 错误)。\n\nE) `Sort: ... (actual time=... rows=125 loops=1)` 以及 `Stream results (actual time=... rows=125 loops=1)` 都表明最终返回了125行 (E 正确)。\n\n**考点总结:**\n此题考察对 `EXPLAIN` (特别是带有 `actual time` 的 `EXPLAIN ANALYZE` 格式) 输出的解读能力。需要理解嵌套循环连接的执行顺序、优化器的估算行数 (`rows`) 与实际行数 (`actual ... rows=...`) 的区别，以及各个操作的实际执行时间。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n阅读 `EXPLAIN` 输出时，从上到下看操作的最终顺序，从缩进判断操作的层级关系。对于 `Nested loop join`，通常先处理的是缩进较少的那个分支（驱动表）。注意区分 `cost` 和 `rows` (估计值) 与 `actual time` 和 `actual rows` (实际值)。时间单位通常是毫秒。\n\n**学习建议:**\n熟练掌握 `EXPLAIN` 和 `EXPLAIN ANALYZE` (或通过设置 `optimizer_trace` 查看详细执行计划) 的使用。理解不同类型的连接操作 (Nested Loop, Hash Join, Merge Join)、表访问方式 (Table Scan, Index Scan, Index Lookup) 以及排序、临时表等操作在 `EXPLAIN` 中的体现。多练习分析复杂查询的执行计划。"
    },
    {
        "question": "### 试题 3:\n\nChoose four. A newly deployed replication master database has a 10/90 read to write ratio. The complete dataset is currently 28G but will never fluctuate (波动) beyond +-10%. The database storage system consists of two locally attached PCI-E Enterprise grade disks (mounted as /data1 and /data2). The server is dedicated to this MySQL Instance. System memory capacity is 64G. The my.cnf file contents are displayed here:\n\n```ini\n[mysqld]\ndatadir=/data1/\ninnodb_buffer_pool_size=28G\ninnodb_log_file_size=150M\n```\n\nWhich four changes provide the most performance improvement, without sacrificing (牺牲) data integrity?",
        "selections": {
            "A": "innodb_doublewrite=off",
            "B": "innodb_log_group_home_dir=/data2/",
            "C": "innodb_log_file_size=1G",
            "D": "innodb_undo_directory=/dev/shm",
            "E": "log-bin=/data2/",
            "F": "innodb_flush_log_at_trx_commit=0",
            "G": "sync_binlog=0",
            "H": "innodb_buffer_pool_size=32G",
            "I": "disable-log-bin"
        },
        "answers": [
            "B",
            "C",
            "E",
            "H"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n\nA) `innodb_doublewrite=off`: 会牺牲数据完整性，不符合题意。\n\nB) `innodb_log_group_home_dir=/data2/`: 将 InnoDB redo 日志放到与数据文件不同的磁盘 (`/data2`)，可以改善 I/O 性能，且不牺牲完整性 (B 正确)。\n\nC) `innodb_log_file_size=1G`: 150M 的 redo 日志对于 28G 的缓冲池和数据集可能偏小，增加到 1G (例如 2个512M文件或1个1G文件，取决于 `innodb_log_files_in_group`) 可以减少刷盘频率，有助于写入性能，对读取也有间接益处，不牺牲完整性 (C 正确)。\n\nD) `innodb_undo_directory=/dev/shm`: 将 undo 日志放到内存文件系统 `/dev/shm`，虽然可能提速，但在系统崩溃时 undo 日志会丢失，严重影响数据完整性和恢复能力，不符合题意。\n\nE) `log-bin=/data2/`: 将二进制日志放到与数据文件和 InnoDB redo 日志不同的磁盘（如果B也选了，则redo和binlog都在/data2，但仍优于和数据都在/data1），改善 I/O 性能，不牺牲完整性 (E 正确)。\n\nF) `innodb_flush_log_at_trx_commit=0`: 会牺牲 ACID 中的 D (Durability)，不符合题意。\n\nG) `sync_binlog=0`: 会牺牲复制的完整性和崩溃恢复时的准确性，不符合题意。\n\nH) `innodb_buffer_pool_size=32G`: 系统内存 64G，数据集约 28-31G。将缓冲池从 28G 增加到 32G (约占总内存50%，或能容纳整个数据集)，可以提高缓存命中率，对读密集型应用有益，不牺牲完整性 (H 正确)。\n\nI) `disable-log-bin`: 题目明确是复制主库，禁用二进制日志会导致复制无法进行，不符合题意。\n\n**考点总结:**\n此题考察 MySQL 性能调优，特别是在保证数据完整性前提下的配置优化。涉及 InnoDB 缓冲池大小、日志文件大小与位置、二进制日志位置以及关键的完整性相关参数（`innodb_doublewrite`, `innodb_flush_log_at_trx_commit`, `sync_binlog`）。重点在于I/O分离和内存的合理分配。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n首先排除牺牲数据完整性的选项（如A, D, F, G, I）。然后根据“性能改进”选择。考虑I/O瓶颈（将不同类型日志和数据分到不同物理磁盘）、内存利用（增加缓冲池）和日志调优（合理的日志大小）。题目中明确有 `/data1` 和 `/data2` 两个挂载点，这是I/O分离的重要提示。\n\n**学习建议:**\n深入理解 `my.cnf` 中各项参数的含义及其对性能和数据完整性的影响。特别是 InnoDB 相关的参数 (`innodb_buffer_pool_size`, `innodb_log_file_size`, `innodb_log_group_home_dir`, `innodb_flush_log_at_trx_commit`, `innodb_doublewrite`) 和复制相关的参数 (`log-bin`, `sync_binlog`)。了解磁盘I/O、内存管理对数据库性能的基础影响。"
    },
    {
        "question": "### 试题 4:\n\nWhich two actions will secure a MySQL server from network-based attacks?",
        "selections": {
            "A": "Use MySQL Router to proxy connections to the MySQL server.",
            "B": "Place the MySQL instance behind a firewall.",
            "C": "Use network file system (NFS) for storing data.",
            "D": "Change the listening port to 3307.",
            "E": "Allow connections from the application server only."
        },
        "answers": [
            "B",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n\nA) MySQL Router 主要用于高可用和负载均衡（如InnoDB Cluster），本身不直接作为网络攻击的主要防御手段，尽管它可以间接参与安全架构。\n\nB) 将 MySQL 实例置于防火墙之后，并配置防火墙规则限制访问来源，是标准的网络安全措施，能有效抵御未授权的网络访问 (B 正确)。\n\nC) 使用 NFS 存储数据与防御网络攻击 MySQL 服务本身关系不大，反而可能引入额外的安全风险和性能问题。\n\nD) 更改监听端口（如从默认的3306改为3307）是一种“安全靠隐晦”(security through obscurity)的做法，容易被端口扫描发现，不能提供实质性的安全防护。\n\nE) 仅允许来自特定应用服务器的连接，是一种基于白名单的网络访问控制，大大减少了攻击面，是有效的安全措施 (E 正确)。这通常通过防火墙规则或MySQL的用户账户权限（例如 `CREATE USER 'app_user'@'app_server_ip' ...`）来实现。\n\n**考点总结:**\n此题考察 MySQL 服务器的网络安全防护措施。核心原则是最小化攻击面和实施访问控制。防火墙和限制连接来源是关键的网络层面安全措施。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n考虑哪些措施能真正阻止或限制未经授权的网络连接。区分主动防御（如防火墙、IP白名单）和效果有限的策略（如改端口）。思考“纵深防御”的理念。\n\n**学习建议:**\n学习 MySQL 安全的最佳实践，包括网络层安全（防火墙、`bind-address`、限制用户来源IP）、传输层安全（SSL/TLS加密连接）、认证与授权（强密码策略、最小权限原则、角色管理）、以及防范SQL注入等应用层安全。了解 MySQL Enterprise Firewall 等高级安全特性。"
    },
    {
        "question": "### 试题 5:\n\nChoose four. You must store connection parameters for connecting a Linux-based MySQL client to a remote Windows-based MySQL server listening on port 3309. Which four methods can be used to configure user, host, and database parameters?",
        "selections": {
            "A": "Embed login information into the SSH tunnel definition.",
            "B": "Execute mysql_config_editor to configure the user connection.",
            "C": "Configure ~/.my.cnf.",
            "D": "Execute the mysqladmin command to configure the user connection.",
            "E": "Execute the command in a bash script.",
            "F": "Configure environment variables.",
            "G": "Define a UNIX socket.",
            "H": "Use the usermod program to store static user information.",
            "I": "Configure ~/.ssh/config for public key authentication."
        },
        "answers": [
            "B",
            "C",
            "E",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n\nA) SSH隧道用于安全地转发连接，但其本身的定义（如在~/.ssh/config中）不直接存储MySQL客户端的用户名/密码等参数供mysql客户端程序使用，而是建立一个转发端口。mysql客户端仍需连接到本地转发端口，并提供认证信息。\n\nB) `mysql_config_editor set --login-path=... --host=... --user=... --password` 命令可以将连接参数（包括密码）加密存储在 `~/.mylogin.cnf` 文件中，mysql客户端可以使用 `--login-path` 选项读取这些参数 (B 正确)。\n\nC) 在用户的 `~/.my.cnf` (或系统级的 `my.cnf`) 文件中，可以在 `[client]` 或自定义的程序块中配置 `user`, `password`, `host`, `port`, `database` 等参数 (C 正确)。\n\nD) `mysqladmin` 是一个管理工具，用于执行如ping服务器、查看状态、创建/删除数据库等管理操作，不用于存储客户端连接参数。\n\nE) 在bash脚本中，可以直接在 `mysql` 命令后面跟上 `-u user -p'password' -h host -P 3309 dbname` 等参数来执行命令 (E 正确)。\n\nF) MySQL客户端会检查特定的环境变量，如 `MYSQL_USER`, `MYSQL_PWD`, `MYSQL_HOST`, `MYSQL_TCP_PORT`, `MYSQL_DATABASE` (虽然 `MYSQL_DATABASE` 不是标准客户端选项，但可以通过脚本等方式使用) (F 正确)。注意：`MYSQL_PWD` 有安全风险。\n\nG) UNIX套接字用于本地连接，题目中明确指出是连接到远程Windows服务器，因此不适用。\n\nH) `usermod`是Linux系统管理用户账户的命令，与MySQL客户端连接参数无关。\n\nI) `~/.ssh/config` 用于配置SSH连接参数，如通过SSH隧道连接，但这不直接是MySQL客户端参数的存储方式。\n\n**考点总结:**\n此题考察MySQL客户端连接参数的多种配置方法。主要包括命令行参数、选项文件（my.cnf）、加密的选项文件（.mylogin.cnf via mysql_config_editor）和环境变量。\n\n**答案说明:** 官方文档中，`MYSQL_DATABASE` 环境变量不是标准MySQL客户端（如`mysql`命令行工具）直接识别的环境变量来指定默认数据库。但脚本可以读取它。如果题目严格指`mysql`客户端，则F可能依赖于具体哪些环境变量被认为是“参数”。然而，在更广泛的“配置参数”意义上，环境变量是一种常用方法。 `MYSQL_TCP_PORT` 是一个有效的环境变量。鉴于需要选四个，BCEF 是最合理的组合。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分MySQL服务器端配置、客户端配置和操作系统配置。考虑参数的传递方式：命令行、文件、环境变量。注意安全 implications，例如在脚本或环境变量中明文存储密码。\n\n**学习建议:**\n熟悉MySQL客户端程序（`mysql`, `mysqldump`, `mysqladmin`等）的常用选项。掌握选项文件的结构和优先级 (`/etc/my.cnf`, `~/.my.cnf`, etc.)。学习 `mysql_config_editor` 的使用方法和优点。了解MySQL客户端可以识别哪些环境变量。"
    },
    {
        "question": "### 试题 6:\n\nChoose two. Examine this statement, which executes successfully:\n\n```sql\nCREATE TABLE employees (\n  emp_no int unsigned NOT NULL,\n  birth_date date NOT NULL,\n  first_name varchar(14) NOT NULL,\n  last_name varchar(16) NOT NULL,\n  hire_date date NOT NULL,\n  PRIMARY KEY (emp_no)\n) ENGINE=InnoDB;\n```\n\nNow examine this query: `SELECT emp_no, first_name, last_name, birth_date FROM employees WHERE MONTH(birth_date) = 4;`\n\nYou must add an index that can reduce the number of rows processed by the query. Which two statements can do this?",
        "selections": {
            "A": "ALTER TABLE employees ADD INDEX ((CAST(birth_date ->>'$.month' AS unsigned)));",
            "B": "ALTER TABLE employees ADD INDEX (birth_date DESC);",
            "C": "ALTER TABLE employees ADD COLUMN birth_month tinyint unsigned GENERATED ALWAYS AS (MONTH(birth_date)) VIRTUAL NOT NULL, ADD INDEX (birth_month);",
            "D": "ALTER TABLE employees ADD INDEX (birth_date);",
            "E": "ALTER TABLE employees ADD COLUMN birth_month tinyint unsigned GENERATED ALWAYS AS (birth_date ->>'$.month') VIRTUAL NOT NULL, ADD INDEX (birth_month);",
            "F": "ALTER TABLE employees ADD INDEX ((MONTH(birth_date)));"
        },
        "answers": [
            "C",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n查询条件是 `WHERE MONTH(birth_date) = 4`。为了优化这个查询，我们需要一个能够直接利用 `MONTH(birth_date)` 结果的索引。\n\nA) `birth_date ->>'$.month'` 是JSON操作符，不适用于`DATE`类型的 `birth_date` 列。\n\nB) 和 D) 在 `birth_date` 列上创建索引，无论是升序还是降序，都无法直接优化 `MONTH(birth_date)` 这个函数表达式。MySQL优化器通常不会使用普通列索引来加速对该列应用函数后的条件判断，除非进行全索引扫描。\n\nC) 创建一个虚拟生成列 `birth_month`，其值是 `MONTH(birth_date)`，然后在这个生成列上创建索引。查询时，如果查询条件与生成列的定义匹配（或者优化器能够转换），就可以使用这个索引 (C 正确)。\n\nE) 类似A，使用了不适用于 `DATE` 类型的JSON操作符 `->>` 来定义生成列。\n\nF) 直接在表达式 `(MONTH(birth_date))` 上创建索引（函数索引或表达式索引）。从MySQL 8.0.13开始支持这种语法。这允许优化器直接使用这个索引来满足 `WHERE MONTH(birth_date) = 4` 条件 (F 正确)。\n\n**考点总结:**\n此题考察对函数或表达式结果进行索引优化的方法。主要有两种方式：1. 创建生成列（Generated Column），其值基于表达式，然后对生成列创建索引。2. 直接在表达式上创建索引（Functional/Expression Indexes，MySQL 8.0+）。\n\n**答案说明:** C和F都是有效的解决方案。C是MySQL 5.7引入生成列后的常用方法，F是MySQL 8.0引入的更直接的方法。题目未指定MySQL版本，但两者都是现代MySQL中优化此类查询的正确途径。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n当 `WHERE` 子句中对列使用了函数时，标准的B-Tree索引在该列上通常无效。寻找能够使索引直接匹配函数结果的选项。注意MySQL版本特性，如生成列和表达式索引。\n\n**学习建议:**\n学习MySQL的索引类型和使用场景。重点掌握生成列（Stored 和 Virtual）的创建和用途，以及如何为它们创建索引。如果备考MySQL 8.0，务必学习表达式索引的语法和优势。理解为什么 `WHERE FUNC(column) = value` 不能有效利用 `column` 上的普通索引。"
    },
    {
        "question": "### 试题 7:\n\nChoose two. Which two queries are examples of successful SQL injection attacks?",
        "selections": {
            "A": "SELECT user, passwd FROM members WHERE user = ' ? ' ; INSERT INTO members ('user', 'passwd') VALUES ('bob@example.com', 'secret');--';",
            "B": "SELECT user, phone FROM customers WHERE name = '\\'; DROP TABLE users; -- ';",
            "C": "SELECT id, name FROM user WHERE user.id= (SELECT members.id FROM members);",
            "D": "SELECT id, name FROM user WHERE id=23 OR id=32 OR 1=1;",
            "E": "SELECT id, name FROM user WHERE id=23 OR id=32 AND 1=1;",
            "F": "SELECT email, passwd FROM members WHERE email = 'INSERT INTO members('email', 'passwd') VALUES ('bob@example.com', 'secret') ;-- ';"
        },
        "answers": [
            "A",
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nSQL注入攻击的核心是攻击者能够将恶意SQL代码片段插入到应用程序的SQL查询中，从而改变原始查询的逻辑或执行额外的恶意操作。\n\nA) 假设 `?` 是用户输入点。如果用户输入 `' ; INSERT INTO members ('user', 'passwd') VALUES ('bob@example.com', 'secret');--`，那么原始查询的 `user = '... '` 中的第一个单引号会被用户输入的单引号闭合，然后 `;` 开始一个新的 `INSERT` 语句。`--` 会注释掉原始查询可能存在的后续部分。这是一个典型的SQL注入，执行了额外的 `INSERT` 操作 (A 正确)。\n\nB) 用户输入 `'; DROP TABLE users; -- `。`'` 用于转义并闭合前一个单引号（或者根据上下文直接闭合），然后 `;` 结束当前语句，`DROP TABLE users;` 是注入的恶意命令。`--` 注释掉后续内容。这是一个成功删除表的SQL注入 (B 正确)。\n\nC) 这是一个合法的SQL查询，使用了子查询。它本身不是SQL注入攻击的例子，除非子查询的内容是用户可控并被恶意构造的，但查询本身结构是合法的。\n\nD) 和 E) `OR 1=1` 或 `AND 1=1` 是SQL注入中常用的技巧，用于绕过认证或获取更多数据（例如，如果 `id=23 OR id=32` 是用户输入的一部分，而攻击者注入了 `OR 1=1`）。但语句本身作为完整查询，只是一个逻辑表达式，不一定代表一个“攻击”，它只是一个恒真或部分恒真的条件。题目问的是“成功的SQL注入攻击”，A和B更清晰地展示了恶意代码的执行。\n\nF) 如果整个 `'INSERT INTO ... ;-- '` 字符串被视为 `email` 的值，那么它只是一个普通的字符串比较，不是SQL注入。如果注入点是 `email = '` 之后，用户输入了 `anything_here_to_close_the_quote'; INSERT INTO ... ;-- `，那才是注入。从选项的写法看，似乎整个 `INSERT` 语句是作为 `email` 字符串的值，这通常不会构成注入，除非数据库或驱动有非常特殊的解析行为。A和B的结构更符合典型SQL注入的模式。\n\n**考点总结:**\n此题考察对SQL注入攻击原理和常见形式的识别。关键在于识别如何通过用户输入来闭合当前的SQL语句片段（如字符串字面量），并引入新的SQL命令或修改原始查询逻辑。分号 (`;`) 用于分隔多个SQL语句，注释符 (`--` 或 `/* ... */`) 用于忽略原始查询的剩余部分。\n\n**答案说明:** A和B清晰地展示了通过终止原语句并引入新恶意语句的注入方式。F的描述有点模糊，如果假设单引号未闭合，且用户输入 `INSERT INTO ... ;-- ` 作为 `email` 值的一部分，那么它缺少一个前导单引号来闭合原始的 `email = '` 语句，因此按其字面形式，它更像是一个包含SQL语句的字符串，而不是一个已成功执行的注入攻击。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n寻找那些能够改变原始SQL查询结构、执行额外命令或绕过逻辑判断的选项。注意单引号、分号、注释符等特殊字符在SQL注入中的作用。问题问的是“成功的SQL注入攻击”，所以要选那些能实际执行恶意代码的例子。\n\n**学习建议:**\n深入理解SQL注入的各种类型（基于错误的、联合查询的、盲注、时间延迟的、堆叠查询的等）。学习如何防范SQL注入，主要是使用参数化查询（预编译语句）和严格的输入验证/清理。了解不同数据库系统对SQL注入的敏感度和特定技巧。"
    },
    {
        "question": "### 试题 8:\n\nChoose two. Which two tools are available to monitor the global status of InnoDB locking?",
        "selections": {
            "A": "SHOW ENGINE INNODB STATUS;",
            "B": "SHOW TABLE STATUS;",
            "C": "INFORMATION_SCHEMA.INNODB_TABLESTATS;",
            "D": "SHOW STATUS;",
            "E": "INFORMATION_SCHEMA.STATISTICS",
            "F": "INFORMATION_SCHEMA.INNODB_METRICS"
        },
        "answers": [
            "A",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n\nA) `SHOW ENGINE INNODB STATUS;` 是监控InnoDB内部状态（包括锁、事务、缓冲池、日志等）非常重要的命令。其输出的 `LATEST DETECTED DEADLOCK` 和 `TRANSACTIONS` 部分包含了大量的锁信息 (A 正确)。\n\nB) `SHOW TABLE STATUS;` 提供关于表的一般信息，如引擎、行数、数据大小等，不直接显示当前的锁状态。\n\nC) `INFORMATION_SCHEMA.INNODB_TABLESTATS` (MySQL 5.6+) 或 `mysql.innodb_table_stats` (更早版本) 存储的是持久化的InnoDB表和索引的统计信息，用于查询优化，不是实时锁信息。\n\nD) `SHOW STATUS;` (或 `SHOW GLOBAL STATUS;`) 显示服务器级别的状态变量，其中一些可能与锁相关（如 `Innodb_row_lock_waits`, `Table_locks_waited`），但它不提供详细的InnoDB锁信息，如哪些事务持有锁，哪些在等待锁。\n\nE) `INFORMATION_SCHEMA.STATISTICS` 提供关于表索引的统计信息，用于查询优化，不显示锁信息。\n\nF) `INFORMATION_SCHEMA.INNODB_METRICS` 表提供了一系列InnoDB性能计数器。可以通过查询此表来获取关于锁的聚合统计信息，例如 `lock_deadlocks`, `lock_timeouts`, `lock_wait_secs` 等，这些可以反映InnoDB锁的全局状况 (F 正确)。\n\n在现代MySQL版本（如8.0+）中，`performance_schema` 下的表如 `data_locks` 和 `data_lock_waits` 提供了更详细和实时的锁信息。但题目选项未包含这些。在题目给出的选项中，A和F是监控InnoDB锁状态最相关的工具。\n\n**考点总结:**\n此题考察监控InnoDB锁状态的工具。`SHOW ENGINE INNODB STATUS` 是传统的综合性诊断工具。`INFORMATION_SCHEMA.INNODB_METRICS` 提供了更细粒度的性能计数器。了解不同监控工具的适用范围和提供的信息类型是关键。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分提供实时详细锁信息（如 `SHOW ENGINE INNODB STATUS`中的事务和锁部分）、提供聚合锁统计（如 `INNODB_METRICS` 或某些 `SHOW STATUS` 变量）和提供其他元数据/统计信息（如 `SHOW TABLE STATUS`, `I_S.STATISTICS`）的工具。选择最能反映“全局锁状态”的选项。\n\n**学习建议:**\n熟练掌握 `SHOW ENGINE INNODB STATUS` 命令的输出解读。学习使用 `INFORMATION_SCHEMA` 中的InnoDB相关表，特别是 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS` (在8.0中被performance_schema替代但可能仍被考察概念) 以及 `INNODB_METRICS`。对于MySQL 8.0及以上版本，重点学习 `Performance Schema` 中与锁相关的表，如 `performance_schema.data_locks` 和 `performance_schema.data_lock_waits`。"
    },
    {
        "question": "### 试题 9:\n\nChoose two. Which two authentication plugins require the plain text client plugin (`mysql_clear_password`) for authentication to work?",
        "selections": {
            "A": "LDAP authentication",
            "B": "SHA256 authentication",
            "C": "Windows Native authentication",
            "D": "PAM authentication",
            "E": "MySQL Native Password",
            "F": "LDAP SASL authentication"
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n客户端插件 `mysql_clear_password` 用于在客户端和服务器之间以明文形式传输密码。这通常是当服务器端认证插件需要接收实际密码以进行验证时（例如，将其传递给外部认证系统如LDAP或PAM）。\n\nA) LDAP认证插件：如果配置为简单的LDAP绑定（Simple Bind），服务器端的LDAP插件通常需要从客户端接收明文密码，然后用该密码向LDAP服务器进行认证。因此，客户端需要使用 `mysql_clear_password` (A 正确)。\n\nB) `sha256_password` 认证插件使用基于SHA256的密码哈希和加盐机制，密码不在网络上明文传输，不需要 `mysql_clear_password`。\n\nC) Windows Native Authentication 使用Windows操作系统的认证机制（如SSPI），不依赖于明文密码传输。\n\nD) PAM (Pluggable Authentication Modules) 认证插件：PAM的配置非常灵活。如果配置的PAM服务栈需要明文密码进行验证（例如，传递给 `pam_unix.so` 进行本地密码验证，或某些其他需要密码的模块），则MySQL服务器端的PAM插件会要求客户端发送明文密码，客户端因此需要使用 `mysql_clear_password` (D 正确)。\n\nE) `mysql_native_password` 认证插件使用基于挑战-应答的机制，密码经过哈希处理，不在网络上明文传输，不需要 `mysql_clear_password`。\n\nF) LDAP SASL (Simple Authentication and Security Layer) 认证：SASL支持多种认证机制。例如，使用Kerberos (GSSAPI) 的SASL机制就不需要明文密码。虽然某些简单的SASL机制可能需要，但通常SASL旨在提供更强的认证方法，避免明文密码。相对于A（简单LDAP绑定），F的场景更复杂，不一定强制需要明文密码。\n\n**考点总结:**\n此题考察MySQL的认证插件机制，特别是哪些插件需要客户端以明文形式发送密码。关键在于理解不同认证插件的工作原理以及它们如何与外部认证系统交互。使用 `mysql_clear_password` 插件时，必须配合SSL/TLS加密连接以保护密码安全。\n\n**答案说明:** 基于MySQL官方文档，用于简单绑定（Simple Bind）的LDAP认证插件和某些配置下的PAM认证插件是需要客户端发送明文密码的典型例子。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n思考哪些认证机制本质上需要服务器端接收到用户的原始密码才能工作。通常，当MySQL将认证委托给外部系统，并且该外部系统需要密码时，就可能需要明文密码。注意区分密码在本地的存储方式（哈希）和在网络上传输的方式。\n\n**学习建议:**\n了解MySQL支持的各种认证插件，如 `mysql_native_password`, `sha256_password`, `caching_sha2_password` (MySQL 8.0默认), LDAP认证插件, PAM认证插件, Windows Native Authentication等。理解它们各自的认证流程和安全特性。特别注意何时需要客户端插件 `mysql_clear_password`，以及使用它时的安全前提（必须启用SSL/TLS加密连接）。"
    },
    {
        "question": "### 试题 10:\n\nWhich three are types of information stored in the MySQL data dictionary?",
        "selections": {
            "A": "InnoDB buffer pool LRU management data",
            "B": "performance metrics",
            "C": "access control lists",
            "D": "server runtime configuration",
            "E": "server configuration rollback",
            "F": "view definitions",
            "G": "stored procedure definitions"
        },
        "answers": [
            "C",
            "F",
            "G"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL 数据字典 (Data Dictionary) 是一个集中的事务性存储库，用于存储关于数据库对象的元数据。有效的选项包括：\nC) 访问控制列表（Access control lists）：用户账户、权限和角色信息存储在数据字典中。\nF) 视图定义（View definitions）：视图的SQL定义存储在数据字典中。\nG) 存储过程定义（Stored procedure definitions）：存储过程、函数和触发器的定义也存储在数据字典中。\n\n无效的选项：\nA) InnoDB缓冲池LRU管理数据：这是InnoDB内部内存管理的数据，不属于数据字典的元数据范畴。\nB) 性能指标（Performance metrics）：性能指标通常由Performance Schema或状态变量提供，而非直接存储于数据字典的核心对象定义中。\nD) 服务器运行时配置（Server runtime configuration）：运行时配置通过系统变量管理，部分持久化配置可能影响数据字典的结构，但配置值本身不是数据字典存储的核心对象元数据。\nE) 服务器配置回滚（Server configuration rollback）：这不是数据字典存储的信息类型。\n\n**考点总结:**\n此题考察对 MySQL 8.0 引入的数据字典所存储内容的理解。数据字典取代了旧的基于FRM文件和系统表的元数据存储方式，集中存储了数据库对象的定义、结构、权限等信息。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解“元数据”的含义——即关于数据的数据。数据字典存储的是描述数据库结构和管理的信息，而不是运行时状态或性能数据本身。排除那些描述服务器内部操作细节或瞬时状态的选项。\n\n**学习建议:**\n学习 MySQL 8.0 数据字典的架构和功能。了解它存储了哪些类型的数据库对象信息，例如表定义、索引、视图、存储过程、触发器、用户账户和权限等。区分数据字典与 Performance Schema、Information Schema 以及系统变量的角色。"
    },
    {
        "question": "### 试题 11:\n\n(Choose four.) Which four are types of information stored in the MySQL data dictionary?",
        "selections": {
            "A": "performance metrics",
            "B": "table definitions",
            "C": "access control lists",
            "D": "view definitions",
            "E": "server runtime configuration",
            "F": "server configuration rollback",
            "G": "stored procedure definitions",
            "H": "InnoDB buffer pool LRU management data"
        },
        "answers": [
            "B",
            "C",
            "D",
            "G"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n与试题10类似，此题要求选出四项存储在MySQL数据字典中的信息类型。\nB) 表定义（Table definitions）：包括表结构、列、索引、约束等元数据。\nC) 访问控制列表（Access control lists）：用户、角色及其权限。\nD) 视图定义（View definitions）：视图的创建语句和结构。\nG) 存储过程定义（Stored procedure definitions）：存储过程、函数等的代码和元数据。\n\n无效选项的理由同试题10。\n\n**考点总结:**\n再次强调MySQL数据字典作为元数据中心的角色。它存储了数据库对象的静态定义信息，是数据库运行的基础。理解哪些属于描述数据库结构和管理的信息至关重要。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细阅读题目要求（选择四项）。基于对数据字典核心功能的理解，筛选出描述数据库对象定义和权限管理的选项。通常，动态的、运行时的数据（如性能指标、LRU数据）不属于数据字典的核心存储内容。\n\n**学习建议:**\n复习数据字典包含的关键元数据类别。可以参考MySQL官方文档中关于数据字典的章节，明确其存储范围。与旧版本（<8.0）的元数据存储方式（如.frm文件、mysql数据库中的系统表）进行对比，有助于理解数据字典的统一性和重要性。"
    },
    {
        "question": "### 试题 12:\n\nChoose two. Examine this SQL statement:\n```sql\nmysql> GRANT r_read@localhost TO mark WITH ADMIN OPTION;\n```\nWhich two are true?",
        "selections": {
            "A": "Mark can grant the privileges assigned to the r_read@localhost role to another user.",
            "B": "Mark can grant the r_read@localhost role to another user.",
            "C": "ADMIN OPTION causes the role to be activated by default.",
            "D": "Mark must connect from localhost to activate the r_read@localhost role.",
            "E": "Mark can revoke the r_read@localhost role from another user.",
            "F": "ADMIN OPTION allows Mark to drop the role."
        },
        "answers": [
            "B",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`GRANT role TO user WITH ADMIN OPTION` 授予用户 `user`（这里是 `mark`）一个角色 `role`（这里是 `r_read@localhost`），并且赋予该用户管理此角色的权限。具体来说，`WITH ADMIN OPTION` 允许 `mark`：\n1.  将 `r_read@localhost` 这个角色授予其他用户。\n2.  从其他用户那里撤销 `r_read@localhost` 这个角色。\n\nB) Mark可以将 `r_read@localhost` 角色授予其他用户。这是 `WITH ADMIN OPTION` 的主要功能之一 (B 正确)。\nE) Mark可以从其他用户那里撤销 `r_read@localhost` 角色。这也是 `WITH ADMIN OPTION` 的功能 (E 正确，假设“from another role”是“from another user”的笔误，这在实际权限中是标准行为)。\n\n错误选项分析：\nA) `WITH ADMIN OPTION` 不直接允许 `mark` 将角色内含的 *具体权限* 授予其他用户。要授予具体权限，`mark` 需要对那些权限拥有 `GRANT OPTION`。\nC) `ADMIN OPTION` 与角色的默认激活无关。角色的默认激活通过 `SET DEFAULT ROLE` 命令设置。\nD) 角色名中的 `@localhost` 指定了角色的作用域（即该角色定义在localhost上），与 `mark` 激活角色时必须从何处连接无关。\nF) `ADMIN OPTION` 不允许 `mark` 删除（DROP）该角色。删除角色需要 `DROP ROLE` 权限。\n\n**考点总结:**\n此题考察MySQL中角色的管理权限，特别是 `WITH ADMIN OPTION` 子句的作用。它与权限的 `WITH GRANT OPTION` 不同，前者针对角色本身的授予和撤销，后者针对权限的授予。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n清晰地区分 `WITH ADMIN OPTION` 和 `WITH GRANT OPTION`。`WITH ADMIN OPTION` 是与角色相关的，允许被授权者将该角色传递给他人或从他人处收回。它不直接传递角色内部权限的授予权。\n\n**学习建议:**\n深入学习MySQL角色管理，包括创建角色、授予权限给角色、将角色授予用户、激活角色、设置默认角色以及 `WITH ADMIN OPTION` 的具体含义和使用场景。对比其与传统直接授予权限给用户并使用 `WITH GRANT OPTION` 的异同。"
    },
    {
        "question": "### 试题 13:\n\nChoose two. Which two statements are true about general tablespaces?",
        "selections": {
            "A": "General tablespaces support temporary tables.",
            "B": "Dropping a table from a general tablespace releases the space back to the operating system.",
            "C": "A new table can be created explicitly in a general tablespace.",
            "D": "An existing table can be moved into a general tablespace.",
            "E": "A general tablespace can have multiple data files."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n通用表空间 (General Tablespaces) 是MySQL InnoDB存储引擎提供的一种共享表空间，可以存储多个表的数据。\nC) 新表可以显式地在通用表空间中创建。使用 `CREATE TABLE ... TABLESPACE = general_tablespace_name;` 语法 (C 正确)。\nD) 现有表可以移入通用表空间。使用 `ALTER TABLE ... TABLESPACE = general_tablespace_name;` 语法 (D 正确)。\n\n错误选项分析：\nA) 通用表空间不支持存储临时表。临时表有其特定的存储机制。\nB) 从通用表空间删除表（`DROP TABLE`）时，空间在表空间内部被标记为可用，但通常不会立即或轻易地将该空间释放回操作系统。要收缩通用表空间文件（`.ibd`文件）通常很困难，类似于系统表空间。\nE) 每个通用表空间由单个数据文件（`.ibd` 文件）组成，创建时指定文件名，不能有多个数据文件。\n\n**考点总结:**\n此题考察对InnoDB通用表空间的特性和限制的理解。关键点包括表在其中的创建和移动方式、空间管理以及与独立表空间（file-per-table）和系统表空间的区别。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住通用表空间的核心特性：可以容纳多个表，但本身是单个文件。表可以被创建或移动到其中。空间回收通常是内部的，不直接返回给OS。与 `innodb_file_per_table` 的独立表空间行为进行对比。\n\n**学习建议:**\n学习InnoDB的各种表空间类型：系统表空间、独立表空间（file-per-table）、通用表空间、undo表空间、临时表空间。理解它们各自的优缺点、适用场景和管理方式。特别是通用表空间的创建、使用和限制。"
    },
    {
        "question": "### 试题 14:\n\nscale up 垂直扩展 在现有服务器中增加硬件资源,以提高性能和处理能力。\n\n Which three methods are part of a 'scale up' approach to capacity planning?",
        "selections": {
            "A": "adding additional MySQL servers to the existing host",
            "B": "adding more CPU power",
            "C": "adding a replication slave",
            "D": "adding more RAM",
            "E": "adding more storage to your disk array",
            "F": "sharding the server into a parallel server farm",
            "G": "adding a new node to InnoDB Cluster"
        },
        "answers": [
            "B",
            "D",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n“Scale up”（垂直扩展）指的是通过增强现有单个服务器的硬件资源来提升其性能和容量。\nB) 增加更多CPU处理能力（例如，升级到更多核心或更高频率的CPU）是典型的垂直扩展 (B 正确)。\nD) 增加更多RAM（内存）可以提高缓存命中率，减少磁盘I/O，是垂直扩展 (D 正确)。\nE) 增加更多存储空间到磁盘阵列，或使用更快的存储设备（如SSD替换HDD）是垂直扩展 (E 正确)。\n\n错误选项分析（这些通常属于“Scale out”或水平扩展）：\nA) 在现有主机上添加额外的MySQL服务器实例，更像是资源分割或虚拟化，不完全是传统意义上的对单一服务实例的垂直扩展。\nC) 添加复制从库主要用于读写分离、负载均衡或高可用性，属于水平扩展策略。\nF) 将服务器分片到并行服务器集群（Sharding）是典型的水平扩展数据库架构。\nG) 向InnoDB集群添加新节点也是水平扩展，通过增加更多服务器来分散负载和提高可用性。\n\n**考点总结:**\n此题考察对两种主要容量规划策略的区分：垂直扩展（Scale Up）和水平扩展（Scale Out）。垂直扩展关注增强单机能力，水平扩展关注通过增加机器数量来扩展系统能力。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解垂直扩展的核心是“使现有的更强大”，而水平扩展是“增加更多相同的单元”。根据这个原则判断选项属于哪种扩展方式。\n\n**学习建议:**\n学习数据库架构中的不同扩展策略。了解垂直扩展的优点（如管理相对简单）和缺点（如单点故障风险、硬件升级成本和上限）。同时了解水平扩展的优缺点及其常见的实现方式（如复制、分片、集群）。"
    },
    {
        "question": "### 试题 15:\n\nChoose three. A user wants to connect without entering his or her username and password on the Linux command prompt. Which three locations can be used to store the user's mysql credentials to satisfy this requirement?",
        "selections": {
            "A": "$HOME/.mysqlrc file",
            "B": "/etc/my.cnf file",
            "C": "DATADIR/mysqld-auto.cnf file",
            "D": "$HOME/.my.cnf file",
            "E": "$HOME/.mylogin.cnf file",
            "F": "$MYSQL_HOME/my.cnf file",
            "G": "$HOME/.mysql/auth/login file"
        },
        "answers": [
            "B",
            "D",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n为了让MySQL客户端（如 `mysql` 命令行工具）在连接时自动读取凭据而无需在命令行输入，可以使用以下配置文件：\nB) `/etc/my.cnf`：这是系统级的MySQL配置文件。可以在其中的 `[client]` 部分定义用户名和密码。所有用户均可使用，但通常用于定义通用客户端选项，密码存放于此需注意安全。\nD) `$HOME/.my.cnf`：这是用户家目录下的个人MySQL配置文件。同样可以在 `[client]` 部分定义用户名和密码，仅对该用户生效。\nE) `$HOME/.mylogin.cnf`：这是由 `mysql_config_editor` 工具创建和管理的加密凭据文件。它以安全的方式存储登录路径（包含主机、用户、密码等），客户端可以通过 `--login-path` 选项使用。\n\n错误选项分析：\nA) `$HOME/.mysqlrc`：通常用于存储 `mysql` 客户端启动时执行的命令别名或设置，而不是标准的凭据存储位置。\nC) `DATADIR/mysqld-auto.cnf`：这是MySQL服务器在数据目录下自动生成的配置文件，主要用于持久化 `SET PERSIST` 命令设置的系统变量，与客户端凭据无关。\nF) `$MYSQL_HOME/my.cnf`：`$MYSQL_HOME` 通常指向MySQL的安装目录，该路径下的 `my.cnf` 更多是服务器端或特定安装的配置，不如 `/etc/my.cnf` 或 `$HOME/.my.cnf` 通用作为客户端凭据存储。\nG) `$HOME/.mysql/auth/login`：这不是一个标准的MySQL客户端凭据文件位置。\n\n**考点总结:**\n此题考察MySQL客户端凭据的存储方式，特别是如何通过配置文件避免在命令行明文输入密码。重点是 `my.cnf` 文件的层级和 `mysql_config_editor` 的使用。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分服务器配置文件和客户端配置文件。记住 `my.cnf` 可以在多个位置存在（系统级、用户级），并且客户端会按特定顺序读取它们。了解 `mysql_config_editor` 是推荐的安全存储凭据的方式。\n\n**学习建议:**\n熟悉MySQL选项文件的加载顺序和不同section（如 `[client]`, `[mysql]`, `[mysqld]`）的用途。学习如何使用 `mysql_config_editor` 工具来创建和管理加密的登录凭据。注意在普通 `my.cnf` 文件中存储密码的安全隐患（文件权限需严格控制）。"
    },
    {
        "question": "### 试题 16:\n\nChoose two. Examine the modified output:\n```sql\nmysql> SHOW SLAVE STATUS \\G\n*************************** 1. row ***************************\n          Slave_IO_Running: Yes\n         Slave_SQL_Running: Yes\n       Seconds_Behind_Master: 1612\n```\n`Seconds_Behind_Master` value is steadily growing. What are two possible causes?",
        "selections": {
            "A": "The master is producing a large volume of events in parallel but the slave is processing them serially.",
            "B": "This value shows only I/O latency and is not indicative of the size of the transaction queue.",
            "C": "One or more large tables do not have primary keys.",
            "D": "The master is most probably too busy to transmit data and the slave needs to wait for more data.",
            "E": "The parallel slave threads are experiencing lock contention."
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`Seconds_Behind_Master` (SBM) 表示从库SQL线程应用事件的时间戳与主库I/O线程读取到的最新事件时间戳之间的差异。SBM持续增长表明从库处理速度跟不上主库事件产生的速度。\n\nA) 主库并行产生大量事件，而从库串行处理（或并行度不足/效率不高）：如果主库写入并发高，而从库SQL线程是单线程的，或者多线程复制（MTS）配置不当或遇到瓶颈，SQL线程会成为瓶颈，导致SBM增长 (A 正确)。\nD) 主库过于繁忙无法及时传输数据，或网络延迟导致从库等待数据：如果主库负载过高，或者主从之间的网络存在问题（带宽不足、高延迟、丢包），从库的I/O线程可能无法及时获取到最新的二进制日志事件，这也会导致SBM增加，因为SQL线程只能处理已接收到的事件 (D 正确)。\n\n错误选项分析：\nB) SBM反映的是SQL线程相对于I/O线程读取到的binlog事件的时间戳的延迟。它间接受到I/O延迟（因为SQL线程不能超越I/O线程）和SQL线程处理延迟（这是直接原因）的影响。它确实与事务队列的大小有关，因为积压的事件越多，SBM可能越大。\nC) 大表无主键确实会导致从库应用更新（尤其是行模式复制RBR下的UPDATE/DELETE）非常缓慢，可能引起SBM增长。但这通常是一个持续的性能问题，而题目描述的是“steadily growing”，A和D更直接地描述了吞吐量不匹配或数据获取延迟的动态过程。\nE) 如果从库启用了并行复制（MTS）并且并行工作线程之间发生锁争用，确实会导致SQL线程应用变慢，SBM增长。但选项A更具普遍性，即使是单SQL线程也可能发生A的情况。D则指向I/O瓶颈。\n\n**考点总结:**\n此题考察对MySQL复制延迟（`Seconds_Behind_Master`）原因的理解。延迟可能源于从库I/O线程无法及时从主库获取binlog，或者从库SQL线程（单个或多个）无法及时应用已获取的binlog事件。网络问题、主库负载、从库处理能力、大事务、锁争用等都可能导致延迟。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n分析SBM增长时，要从I/O线程和SQL线程两方面考虑。I/O线程慢，SQL线程能处理的事件就少；SQL线程慢，即使I/O线程快，事件也会积压在relay log中。寻找描述这两种瓶颈的选项。\n\n**学习建议:**\n深入理解MySQL复制架构，包括I/O线程和SQL线程（以及并行复制协调线程和工作线程）的角色和工作流程。学习如何监控复制状态（`SHOW SLAVE STATUS`），并诊断常见的复制延迟问题。了解影响复制性能的因素，如网络、硬件、SQL效率、锁、binlog格式等。"
    },
    {
        "question": "### 试题 17:\n\nChoose two. Which two are true about binary logs used in asynchronous replication?",
        "selections": {
            "A": "The master connects to the slave and initiates log transfer.",
            "B": "They contain events that describe all queries run on the master.",
            "C": "They contain events that describe database changes on the master.",
            "D": "They are pulled from the master to the slave.",
            "E": "They contain events that describe only administrative commands run on the master."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n二进制日志（binary logs）是MySQL复制的核心组件，记录了数据库更改的事件。\nC) 它们包含描述主库上数据库更改的事件：这是二进制日志的主要目的。无论是基于语句的复制（SBR）、基于行的复制（RBR）还是混合模式（MBR），binlog的核心都是记录导致数据变化的DDL和DML操作 (C 正确)。\nD) 它们由从库从主库拉取：在异步复制中，从库的I/O线程主动连接到主库，并请求主库发送其二进制日志中的事件 (D 正确)。\n\n错误选项分析：\nA) 是从库连接到主库，而不是主库连接到从库。\nB) 二进制日志不一定包含所有在主库上运行的查询。例如，默认情况下，只读的`SELECT`查询通常不会被记录（除非配置了特定日志记录如慢查询日志，或使用SBR时某些特定的SELECT）。记录的内容取决于`binlog_format`以及查询是否修改数据。\nE) 二进制日志记录了所有导致数据或结构更改的事件，包括DML（如INSERT, UPDATE, DELETE）、DDL（如CREATE TABLE, ALTER TABLE）以及一些管理性但会影响复制的命令，并非“仅”管理命令。\n\n**考点总结:**\n此题考察对二进制日志在异步复制中作用的基本理解。关键点包括日志内容的本质（数据更改）和日志传输的方向（从库拉取）。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n明确复制中主从服务器的角色和数据流向。记住binlog的核心是记录“变化”。\n\n**学习建议:**\n学习MySQL二进制日志的格式（STATEMENT, ROW, MIXED）及其各自的优缺点。理解binlog事件的类型和内容。掌握异步复制的基本设置步骤和工作原理，特别是I/O线程和SQL线程如何与binlog交互。"
    },
    {
        "question": "### 试题 18:\n\nYou have appropriate privileges and are about to shut down a running MySQL server process on Oracle Linux 7. Which three are valid methods that will shut down the MySQL server?",
        "selections": {
            "A": "mysqld_safe -S /tmp/mysql.sock SHUTDOWN",
            "B": "kill mysqld_safe",
            "C": "mysqladmin shutdown",
            "D": "mysql -S /tmp/mysql.sock --shutdown",
            "E": "mysqld_safe --shutdown",
            "F": "systemctl stop mysqld",
            "G": "mysql> SHUTDOWN;"
        },
        "answers": [
            "C",
            "F",
            "G"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n关闭正在运行的MySQL服务器有多种方法，通常推荐使用能进行优雅关闭（graceful shutdown）的方式。\nC) `mysqladmin shutdown`：这是标准的命令行工具，用于连接到MySQL服务器并发送关闭命令。需要适当的权限和连接参数（如果不是默认）(C 正确)。\nF) `systemctl stop mysqld`：在Oracle Linux 7（以及其他使用systemd的系统）上，如果MySQL是通过systemd服务管理的（通常是这样），这是标准的、推荐的关闭服务的方法。它会执行预定义的关闭脚本 (F 正确)。\nG) `mysql> SHUTDOWN;`：在MySQL客户端中，拥有`SHUTDOWN`权限的用户可以执行此SQL命令来关闭服务器 (G 正确)。\n\n错误选项分析：\nA) 和 E) `mysqld_safe`是一个包装脚本，用于启动和监控`mysqld`进程。它本身不接受`--shutdown`或`SHUTDOWN`参数来关闭一个已运行的服务器。关闭是通过`mysqladmin`或信号完成的。\nB) `kill mysqld_safe`会杀死`mysqld_safe`脚本进程。如果`mysqld_safe`配置为在`mysqld`意外退出时重启它，那么`mysqld`本身可能不会被干净关闭，或者会被重启。直接`kill <mysqld_pid>`（通常用SIGTERM）是关闭`mysqld`进程的一种方式，但不如`mysqladmin shutdown`优雅。\nD) `mysql`命令行客户端没有`--shutdown`选项。关闭服务器的命令行工具是`mysqladmin`。\n\n**考点总结:**\n此题考察关闭MySQL服务器的正确方法。区分管理工具（如`mysqladmin`、`systemctl`）和SQL命令，以及它们的使用场景。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n熟悉常用的MySQL管理命令和工具。了解在不同操作系统环境下（特别是使用systemd的Linux发行版）如何管理服务。记住`SHUTDOWN`是一条SQL命令，也是`mysqladmin`的一个子命令。\n\n**学习建议:**\n掌握`mysqladmin`工具的各种常用功能，包括`ping`, `processlist`, `status`, `variables`, 以及`shutdown`。学习如何使用系统服务管理工具（如`systemctl`或旧的`service`命令）来启动、停止和检查MySQL服务状态。了解MySQL的`SHUTDOWN`权限。"
    },
    {
        "question": "### 试题 19:\n\nChoose two. Examine this MySQL Shell command: `dba.rebootClusterFromCompleteOutage()`\nWhich two statements are true?",
        "selections": {
            "A": "It stops and restarts all InnoDB Cluster instances and initializes the metadata.",
            "B": "It only stops and restarts all InnoDB Cluster instances.",
            "C": "It is not mandatory that all instances are running and reachable before running the command.",
            "D": "It performs InnoDB Cluster instances rolling restart.",
            "E": "It reconfigures InnoDB Cluster if the cluster was stopped.",
            "F": "It picks the minimum number of instances necessary to rebuild the quorum and reconfigures InnoDB Cluster.",
            "G": "It only starts all InnoDB Cluster instances."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`dba.rebootClusterFromCompleteOutage()` 是 MySQL Shell AdminAPI 中用于从整个集群完全宕机（所有成员离线或不可达，失去法定数量）的状态下恢复 InnoDB 集群的命令。\n\nC) 在运行此命令之前，并非强制要求所有实例都正在运行且可达。该命令正是设计用来处理实例不可用或集群无主的情况 (C 正确)。\nD) 该命令会尝试启动并重新配置集群实例，这个过程通常涉及逐个启动实例并使其重新加入集群，形成一种“滚动重启”的效果，以重建法定数量并恢复集群服务 (D 正确)。\n\n错误选项分析：\nA) 该命令主要是尝试启动和重新配置实例，而不是“停止并重启”。元数据应该已经存在，命令是基于现有元数据进行恢复，而不是“初始化元数据”。\nB) 它不仅是停止和重启，更重要的是重新配置和重建法定数量。\nE) “如果集群已停止”这个条件是命令的前提。命令的作用是尝试启动并重新配置已停止（或不可用）的集群以恢复服务。\nF) 它会尝试恢复尽可能多的实例以形成一个健康的集群，而不仅仅是满足最低法定数量的实例。\nG) 它不仅是启动实例，还包括重新配置集群、选举主节点和建立法定数量等关键步骤。\n\n**考点总结:**\n此题考察对 MySQL Shell AdminAPI 中 `dba.rebootClusterFromCompleteOutage()` 命令功能的理解。该命令是 InnoDB Cluster 在灾难性故障后进行恢复的关键工具，核心在于其能够在实例不可用的情况下工作，并尝试通过启动和重新配置来恢复集群。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解命令名称中“FromCompleteOutage”的含义，这直接暗示了命令执行的前提条件（集群处于完全故障状态）。关注命令的核心目标：恢复集群服务。\n\n**学习建议:**\n学习 MySQL Shell AdminAPI 的使用，特别是 InnoDB Cluster 的部署、管理和故障恢复相关的命令。阅读官方文档中关于 `dba.rebootClusterFromCompleteOutage()` 的详细说明，了解其工作流程和适用场景。进行实验以加深理解。"
    },
    {
        "question": "### 试题 20:\n\nChoose two. Examine this command and output:\n```bash\nroot@dbhost:/var/lib/mysql# ls -al\ntotal 540\ndrwxrwxr-x 1 mysql mysql 4096 Aug 22 14:07 .\ndrwxr-xr-x 1 root  root  4096 May 22 00:42 ..\n-rw-r----- 1 mysql mysql   56 Aug 20 13:58 auto.cnf\ndrwxr-xr-x 1 mysql mysql 4096 Aug 21 10:28 accounting\n-rw-r--r-- 1 mysql mysql 1112 Aug 20 13:58 ca.pem\n-rw-r----- 1 mysql mysql 172040 Aug 22 14:07 ib_buffer_pool\n-rw-r----- 1 mysql mysql 12582919 Aug 22 14:07 ibdata1\n-rw-r----- 1 mysql mysql 50331648 Aug 22 14:07 ib_logfile0\n-rw-r----- 1 mysql mysql 50331648 Aug 20 13:47 ib_logfile1\n-rw-r----- 1 mysql mysql 292292 Aug 22 14:07 ibtmp1\ndrwxr-x--- 1 mysql users 4096 Aug 20 13:59 mysql\n-rw-rw---- 1 mysql mysql 64064 Aug 22 15:18 mysql-error.log\ndrwxr-x--- 1 mysql mysql 4096 Aug 20 13:59 performance_schema\n-rw-r----- 1 mysql mysql 1680 Aug 20 13:59 private_key.pem\n-rw-r--r-- 1 mysql mysql  452 Aug 20 13:59 public_key.pem\n-rw-r--r-- 1 mysql mysql 1112 Aug 20 13:58 server-cert.pem\n-rw-r----- 1 mysql mysql 1680 Aug 20 13:58 server-key.pem\ndrwxr-x--- 1 mysql mysql 4096 Aug 20 13:59 sys\n```\nWhich two options will improve the security of the MySQL instance?",
        "selections": {
            "A": "Remove the world read/execute privilege from the accounting directory.",
            "B": "Remove world read privileges from the public_key.pem file.",
            "C": "Change the group ownership of the mysql directory to the mysql user group.",
            "D": "Change the parent directory owner and group to mysql.",
            "E": "Remove world read privileges from the server-cert.pem certificate file.",
            "F": "Remove group read/write privileges from the private_key.pem file."
        },
        "answers": [
            "A",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n分析 `ls -al` 输出，寻找可以改进文件和目录权限以增强安全性的地方。\n\nA) `accounting` 目录权限为 `drwxr-xr-x` (755)。`world` 用户拥有读和执行权限。对于数据目录下的子目录，通常不需要给 `world` 这样的权限。移除 `world` 的 `r-x` 权限（例如改为750 `drwxr-x---`）可以提高安全性 (A 正确)。\nF) `private_key.pem` 文件权限为 `-rw-r-----` (640)。`group` 用户拥有读权限。私钥文件应该尽可能严格地限制访问，理想情况下是 `600` (`-rw-------`)，即只有所有者（`mysql`用户）可读写。移除 `group` 的读权限（`chmod g-r private_key.pem`）可以将其权限降为 `600`，从而提高安全性 (F 正确)。\n\n错误或非最佳选项分析：\nB) `public_key.pem` 文件权限为 `-rw-r--r--` (644)。公钥本身就是设计为公开的，允许 `world` 读取通常是可接受的，移除世界读权限对此类文件的安全性提升不大，甚至可能影响其正常使用（如果其他进程需要读取它）。\nC) `mysql` 目录（这里指MySQL schema目录，如 `performance_schema`, `sys` 以及用户数据库目录）权限为 `drwxr-x---`，但其组是 `users` (`drwxr-x--- 1 mysql users`)。将其组更改为 `mysql` (`chgrp mysql mysql`) 是一个好的实践，以保持一致性并遵循最小权限原则。但这可能不如直接限制过于宽松权限（如A和F）的优先级高。题目要求选择两个“改进安全”的选项，A和F是更直接的权限收紧。\nD) 父目录 `..` (即 `/var/lib/`) 的所有者是 `root:root`，权限是 `drwxr-xr-x`。这是标准的Linux目录结构和权限，将其所有者和组更改为 `mysql` 是不正确也不安全的，会破坏系统文件系统的标准所有权。\nE) `server-cert.pem` 文件权限为 `-rw-r--r--` (644)。服务器证书的公钥部分允许 `world` 读取通常是可接受的，类似于公钥文件。\n\n**考点总结:**\n此题考察对Linux文件系统权限的理解以及如何根据最小权限原则来保护MySQL数据目录及其内容。重点关注私密文件（如私钥）的严格权限设置和不必要开放的目录权限。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细阅读 `ls -al` 的输出，关注每个文件/目录的所有者、组、权限位。思考哪些权限是“多余的”或“不安全的”。特别是对于敏感数据（如密钥、数据库文件），权限应尽可能收紧。\n\n**学习建议:**\n复习Linux文件权限（读、写、执行对于文件和目录的不同含义，以及数字表示法如755、640、600等）。学习MySQL安全最佳实践中关于数据目录权限的部分。理解为什么某些文件（如公钥、证书）可以有较宽松的权限，而另一些文件（如私钥、数据文件）必须严格控制。"
    },
    {
        "question": "### 试题 21:\n\nChoose two. Which two statements are true about general tablespaces?",
        "selections": {
            "A": "General tablespaces support temporary tables.",
            "B": "Dropping a table from a general tablespace releases the space back to the operating system.",
            "C": "An existing table can be moved into a general tablespace.",
            "D": "A general tablespace can have multiple data files.",
            "E": "A new table can be created explicitly in a general tablespace."
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n通用表空间 (General Tablespaces) 是MySQL InnoDB存储引擎提供的一种共享表空间机制。\nC) 现有的表可以使用 `ALTER TABLE ... TABLESPACE = tablespace_name;` 语句移入一个通用表空间 (C 正确)。\nE) 新表可以使用 `CREATE TABLE ... TABLESPACE = tablespace_name;` 语句显式地在通用表空间中创建 (E 正确)。\n\n错误选项分析：\nA) 通用表空间不支持存储临时表。临时表有其自身的管理机制。\nB) 从通用表空间中删除表时，空间在表空间内部被标记为可用，但通常不会立即释放回操作系统。回收通用表空间文件占用的磁盘空间比较复杂，类似于系统表空间。\nD) 每个通用表空间由单个 `.ibd` 数据文件组成，不支持多个数据文件。\n\n**考点总结:**\n此题再次考察了对InnoDB通用表空间特性的理解。关键在于其支持多表存储于单个数据文件，表可以被创建于其中或迁移至其中，但空间管理和对临时表的支持有特定限制。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n回顾试题13的考点。通用表空间是 `innodb_file_per_table=OFF` (共享表空间) 和 `innodb_file_per_table=ON` (独立表空间) 之间的一种折中或补充。记住其核心特性：多表共享单文件，但不是系统表空间。表的创建和迁移是其主要使用场景。\n\n**学习建议:**\n深入理解InnoDB的表空间管理，包括系统表空间、独立表空间、通用表空间、undo表空间和临时表空间的区别和用途。掌握如何创建和管理通用表空间，以及在其中创建或移动表的SQL语法。了解其在空间回收方面的限制。"
    },
    {
        "question": "### 试题 22:\n\nChoose three. Examine this command, which executes successfully: `cluster.addInstance('<user>@<host>:<port>', {recoveryMethod: 'clone'})`\nWhich three statements are true?",
        "selections": {
            "A": "It is always slower than recoveryMethod: 'incremental'.",
            "B": "InnoDB tablespaces outside the datadir are able to be cloned.",
            "C": "A target instance must exist, then it will be provisioned with data from an instance already in the cluster and joined to the cluster.",
            "D": "The account used to perform this recovery needs the BACKUP_ADMIN privilege.",
            "E": "A new instance is installed, initialized, and provisioned with data from an instance already in the cluster and joined to the cluster.",
            "F": "InnoDB redo logs must not rotate for the duration of the execution; otherwise, the recovery will fail."
        },
        "answers": [
            "B",
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`cluster.addInstance()` 使用 `recoveryMethod: 'clone'` 意味着新加入的实例将通过MySQL克隆功能从集群中的现有成员（donor）复制数据。\nB) MySQL克隆功能支持克隆位于数据目录之外的InnoDB表空间。只要这些表空间是InnoDB管理的，并且在donor上有相应的配置，它们可以被正确克隆到recipient (B 正确)。\nC) 目标实例（recipient）必须预先存在并且已配置好，但通常不包含数据（或是空实例）。`addInstance` 命令会将其连接到集群，并通过克隆从donor处获取数据来“供应”它，然后将其正式加入集群 (C 正确)。\nD) 执行克隆操作的用户（在donor和recipient上）需要特定的权限。在donor上，用户需要 `BACKUP_ADMIN` 权限来允许数据被克隆。在recipient上，用户需要 `CLONE_ADMIN` 权限来接收和应用克隆的数据 (D 正确，题目中指“执行此恢复的账户”，通常指donor上的权限需求)。\n\n错误选项分析：\nA) 克隆通常用于数据量较大或差异较大的情况，它传输的是物理数据副本。增量恢复（`incremental`，通常指基于binlog的追赶）适用于新实例与集群数据差异较小的情况。克隆不一定“总是”比增量慢，这取决于数据量、网络速度和具体场景。\nE) `addInstance` 本身不负责“安装”MySQL实例。它假设MySQL实例已经安装并基本配置好（例如，可以通过网络访问）。它负责的是初始化（如果需要）、通过克隆供应数据，并将其加入集群。\nF) 虽然在某些备份/恢复场景中，redo log的轮转可能需要注意，但对于MySQL克隆操作，它有自己的机制来确保数据一致性。克隆操作本身对redo log的轮转有特定的处理，不会简单因为redo log轮转而失败。\n\n**考点总结:**\n此题考察对MySQL InnoDB Cluster中添加实例时使用克隆作为恢复方法的理解。涉及克隆功能的能力（如处理外部表空间）、目标实例的状态、所需权限以及与增量恢复的区别。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解`recoveryMethod: 'clone'`的核心含义——物理数据复制。关注克隆操作的前提条件（如目标实例存在、权限）和克隆能处理的范围（如数据目录外的表空间）。\n\n**学习建议:**\n深入学习MySQL的克隆功能，包括其工作原理、优点、限制以及所需的权限（`BACKUP_ADMIN`, `CLONE_ADMIN`）。学习如何在InnoDB Cluster中使用AdminAPI的`addInstance`命令，并理解不同的`recoveryMethod`选项（`clone`, `incremental`, `auto`）之间的区别和适用场景。"
    },
    {
        "question": "### 试题 23:\n\nChoose three. Which three sets of item information are visible in the mysql system database?",
        "selections": {
            "A": "time zone information and definitions",
            "B": "help topics",
            "C": "plugins",
            "D": "audit log events",
            "E": "performance monitoring information",
            "F": "rollback segments",
            "G": "information about table structures"
        },
        "answers": [
            "A",
            "B",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysql`系统数据库存储了MySQL服务器运行所需的多种元数据和配置信息。\nA) 时区信息和定义：`mysql`数据库包含用于支持时区转换的表，如 `time_zone`, `time_zone_name` 等 (A 正确)。\nB) 帮助主题：`mysql`数据库包含 `help_topic`, `help_keyword` 等表，存储了`HELP`命令显示的内容 (B 正确)。\nC) 插件信息：`mysql`数据库的 `plugin` 表存储了已安装插件的信息 (C 正确)。\n\n错误选项分析：\nD) 审计日志事件：如果启用了MySQL Enterprise Audit，审计日志事件通常记录到文件或syslog，而不是直接存储在`mysql`数据库的表中供常规查询（虽然审计插件的配置可能在`mysql`库中）。\nE) 性能监控信息：性能监控信息主要由Performance Schema提供，它有自己的内存结构和表，而非存储在`mysql`数据库中。\nF) 回滚段（Rollback segments）：这是Oracle数据库的术语。MySQL InnoDB使用undo日志进行事务回滚和MVCC，undo日志的管理有其自身的表空间和机制，其元数据可能部分在数据字典，但“回滚段”这个概念和具体信息不在`mysql`库中以这种形式暴露。\nG) 表结构信息：在MySQL 8.0之前，部分表结构信息（如`.frm`文件内容）的元数据可能在`mysql`库的系统表中。但在MySQL 8.0及以后，表结构信息主要存储在数据字典中，尽管`mysql`库本身也是数据字典的一部分，但更精确地说，信息是统一管理在数据字典中，而非特指“可见于mysql系统数据库”。对于用户表，其定义在数据字典，Information Schema提供视图访问。\n\n**考点总结:**\n此题考察对`mysql`系统数据库存储内容的了解。它包含了用户账户、权限、时区、帮助信息、插件配置、存储过程/函数定义（在8.0之前较多，8.0后主要在数据字典）等关键信息。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n思考哪些信息是MySQL服务器运行和管理所必需的“静态”配置或元数据。排除那些动态的、运行时产生的数据（如性能数据、审计事件本身）。\n\n**学习建议:**\n浏览`mysql`系统数据库中的表结构（可以使用`SHOW TABLES FROM mysql;`然后`DESCRIBE mysql.table_name;`）。了解每个主要系统表存储了什么类型的信息。特别注意MySQL 8.0引入数据字典后，元数据存储方式的变化，虽然`mysql`库仍然重要，但数据字典是更核心的元数据存储。",
        "suggestion_detail": "对于G选项，在MySQL 5.7及更早版本，`mysql`数据库确实包含一些与表结构相关的系统表。然而，随着MySQL 8.0数据字典的引入，所有元数据（包括表结构）都集中存储在事务性的数据字典中。`mysql`模式下的表本身也成为了数据字典的一部分。题目问“visible in the mysql system database”，如果从广义上数据字典也算，则G可能是对的。但如果指传统意义上通过查询`mysql`库中的特定表来直接查看用户表的完整结构定义，这在8.0后不那么直接了，`INFORMATION_SCHEMA`是标准接口。考虑到其他选项的明确性，A, B, C是更稳妥的选择。"
    },
    {
        "question": "### 试题 24:\n\nWhich two situations will cause the binary log to rotate?",
        "selections": {
            "A": "FLUSH HOSTS executed",
            "B": "max_binlog_size exceeded",
            "C": "max_binlog_cache_size exceeded",
            "D": "SET sql_log_bin=0 executed",
            "E": "SET sync_binlog=1 executed",
            "F": "FLUSH LOGS executed"
        },
        "answers": [
            "B",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n二进制日志轮转（rotate）指的是关闭当前的二进制日志文件，并开启一个新的二进制日志文件进行写入。\nB) `max_binlog_size` 参数定义了单个二进制日志文件的最大大小。当写入操作导致当前binlog文件大小超过这个限制时，会自动发生轮转 (B 正确)。\nF) `FLUSH LOGS;` 命令会关闭并重新打开所有MySQL正在使用的日志文件，包括二进制日志。这会强制二进制日志进行轮转 (F 正确)。也可以使用 `FLUSH BINARY LOGS;` 只轮转二进制日志。\n\n错误选项分析：\nA) `FLUSH HOSTS;` 用于清空主机缓存，与日志轮转无关。\nC) `max_binlog_cache_size` 定义了事务期间用于缓存binlog事件的内存大小。如果事务的binlog事件超出了这个缓存，会写入临时文件，但这与binlog文件本身的轮转是两回事。\nD) `SET sql_log_bin=0;` 会在当前会话中禁用二进制日志记录，不会导致轮转。\nE) `SET sync_binlog=1;` 控制二进制日志同步到磁盘的频率（每1次写入就同步），影响性能和持久性，但本身不直接导致轮转。\n\n**考点总结:**\n此题考察触发MySQL二进制日志轮转的条件。主要包括达到最大文件大小和手动执行`FLUSH LOGS`或`FLUSH BINARY LOGS`命令。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分自动轮转条件（如大小限制）和手动触发轮转的命令。理解各个`FLUSH`命令的作用。\n\n**学习建议:**\n学习二进制日志的管理，包括其配置参数（`log_bin`, `binlog_format`, `max_binlog_size`, `expire_logs_days`, `sync_binlog`等）。掌握如何手动轮转和清理二进制日志。理解二进制日志在复制和时间点恢复中的重要性。"
    },
    {
        "question": "### 试题 25:\n\nChoose three. Which three statements are true about MySQL replication?",
        "selections": {
            "A": "Each slave must have its own MySQL user for replication.",
            "B": "A replication user must have the SELECT privilege for all tables that need to be replicated.",
            "C": "Each instance in a replication topology must have a unique server ID.",
            "D": "Any instance can have multiple slaves, but it can have only one master.",
            "E": "Binary logs contain only transactions originating from a single MySQL instance.",
            "F": "Replication can use only TCP/IP connections.",
            "G": "Binary logging must be enabled on the master in order to replicate to other instances."
        },
        "answers": [
            "C",
            "F",
            "G"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nC) 复制拓扑中的每个MySQL实例都必须配置一个唯一的`server_id`。这是区分不同服务器并防止复制循环的关键 (C 正确)。\nF) 标准的MySQL异步复制和半同步复制使用TCP/IP网络连接在主从之间传输数据 (F 正确)。虽然理论上可以通过其他方式传输binlog文件，但实时复制依赖网络连接。\n注：MySQL也支持基于Unix套接字的本地连接，但通常复制场景指的是不同服务器之间的网络连接。\nG) 主服务器上必须启用二进制日志（`log_bin`参数开启），因为从服务器通过读取主服务器的二进制日志来复制更改 (G 正确)。\n\n错误选项分析：\nA) 多个从服务器可以共享同一个用于复制的MySQL用户账户，只要该账户在主服务器上被正确创建并授予了`REPLICATION SLAVE`权限。当然，为每个从服务器创建独立用户也是一种好的安全实践，但不是“必须”。\nB) 复制用户（在主库上创建，供从库连接使用）需要的是 `REPLICATION SLAVE` 权限。这个权限允许从库连接并请求binlog。从库应用binlog事件时，是以从库自身的权限执行，或者在特定配置下模拟原始用户。复制用户本身不需要对表有`SELECT`权限。\nD) 一个实例可以作为多个从服务器的主服务器。一个实例也可以是其他多个主服务器的从服务器（多源复制）。一个实例也可以同时作为主服务器和从服务器（例如在链式复制或环形复制中）。因此，“只能有一个主服务器”这个说法不完全准确，取决于拓扑结构。但通常一个从实例直接连接到一个主实例拉取日志。\nE) 二进制日志记录的是在其所在MySQL实例上发生的修改数据的事件。在复杂的复制拓扑中（如主主复制后又作为其他从的主），一个实例的binlog可能包含了源自其他实例通过复制应用过来的更改。但每个binlog文件是特定于它所在的实例的。\n\n**考点总结:**\n此题考察MySQL复制的基本原则和配置要求。核心概念包括`server_id`的唯一性、二进制日志在主库的必要性以及网络连接的使用。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n回顾MySQL复制的基础架构。哪些是硬性要求（如`server_id`, `log_bin`），哪些是常见的实践或配置选项。考虑不同的复制拓扑。\n\n**学习建议:**\n深入理解MySQL异步复制的设置步骤和关键参数。学习不同复制拓扑（如主从、主主、链式、星型、多源）的特点和适用场景。掌握复制用户的创建和权限授予 (`REPLICATION SLAVE`, `REPLICATION CLIENT`)。了解GTID（全局事务标识符）在现代复制中的作用。"
    },
    {
        "question": "### 试题 26:\n\nThe data in this instance transient; no backup or replication will be required. It is currently under performing. The database size is static and including indexes is 19G. Total system memory is 32G. After profiling the system, you highlight these MySQL status and global variables:\n```\nCom_rollback 85408355\nCom_commit 1234342\nInnodb_buffer_pool_pages_free 163840\nmysqld Buffer_pool_size=20G\nInnodb_flush_log_at_trx_commit=2\nDisable-log-bin\n```\nThe OS metrics indicate that disk is a bottleneck. Other variables retain their default values.\nWhich two changes will provide the most benefit to the instance?",
        "selections": {
            "A": "sync_binlog=0",
            "B": "buffer_pool_size=24G",
            "C": "innodb_flush_log_at_trx_commit=1",
            "D": "innodb_doublewrite=0",
            "E": "max_connections=10000",
            "F": "innodb_log_file_size=1G"
        },
        "answers": [
            "D",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n题目描述：数据是瞬态的，不需要备份和复制，磁盘是瓶颈。目标是提高性能。\n- 数据库大小19G，InnoDB缓冲池20G，空闲页163840个 (163840 * 16KB / 1024 / 1024 ≈ 2.5G空闲)。这表明缓冲池略大于数据集，有一定空闲空间。\n- `Com_rollback` 远大于 `Com_commit`，可能意味着大量事务被回滚，或者存在长时间运行的事务导致undo段增长和清理问题，但这与磁盘瓶颈的直接关系不大。\n- `Innodb_flush_log_at_trx_commit=2`: 表示redo log每一秒刷盘一次，不是每次事务提交都刷盘。这在一定程度上牺牲了持久性以换取性能。\n- `Disable-log-bin`: 二进制日志已禁用，符合“不需要复制”的描述。\n\n针对磁盘瓶颈和性能提升：\n\nD) `innodb_doublewrite=0` (禁用双写缓冲): 双写缓冲是为了防止部分页写入导致的数据损坏，但会带来额外的写I/O。题目明确说明数据是“瞬态的”，意味着数据丢失的风险可以接受。禁用双写可以减少写I/O，从而缓解磁盘瓶颈，提升写性能 (D 正确)。\nF) `innodb_log_file_size=1G`: 当前`innodb_flush_log_at_trx_commit=2`（每秒刷盘）。适当增大redo log文件大小（例如从默认的48M增加到1G，通常由多个小文件组成，如2x512M）可以减少redo log刷盘的频率（因为更大的日志空间可以容纳更长时间的事务日志而无需频繁切换和刷盘），从而降低磁盘I/O压力，有助于缓解磁盘瓶颈，特别是对于写密集型操作 (F 正确，尤其是在`innodb_flush_log_at_trx_commit=2`时，更大的日志可以更好地平滑I/O)。\n\n错误选项分析：\nA) `sync_binlog=0`: 二进制日志已禁用 (`Disable-log-bin`)，所以此参数无效。\nB) `buffer_pool_size=24G`: 将缓冲池从20G增到24G。虽然有益，但鉴于数据集19G，20G缓冲池已能大部分覆盖。在磁盘瓶颈非常严重时，直接减少I/O操作（如D和F）可能比略微增加已基本足够的缓冲池更有“最大益处”。\nC) `innodb_flush_log_at_trx_commit=1`: 将其改为1会使每次事务提交都刷redo log到磁盘，这会增加磁盘I/O，加剧磁盘瓶颈，与目标相反。\nE) `max_connections=10000`: 当前没有信息表明连接数是瓶颈。随意增加大量连接数可能耗尽内存或其他资源，对性能不利。\n\n**考点总结:**\n此题考察在特定场景（瞬态数据、磁盘瓶颈）下如何通过调整MySQL参数来优化性能。关键在于识别哪些参数会影响磁盘I/O，并根据场景的特殊性（可接受数据丢失风险）做出取舍。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细阅读题目给出的所有信息，特别是场景约束（如瞬态数据、无备份要求）和性能瓶颈（磁盘I/O）。结合这些信息评估每个参数调整的影响。寻找那些能直接减少磁盘读写操作或优化磁盘使用模式的选项。\n\n**学习建议:**\n深入理解InnoDB的关键性能参数，如`innodb_buffer_pool_size`, `innodb_flush_log_at_trx_commit`, `innodb_doublewrite`, `innodb_log_file_size`等。了解它们各自的作用、对性能的影响以及在不同场景下的推荐配置。学习如何通过状态变量（如`Innodb_buffer_pool_pages_free`, `Com_commit`, `Com_rollback`）和OS指标来诊断性能问题。"
    },
    {
        "question": "### 试题 27:\n\nChoose two. User `fwuser`@`localhost` is registered with the MySQL Enterprise Firewall and has been granted privileges for the SAKILA database. Examine these commands that you executed and the results:\n```sql\nmysql> SELECT MODE FROM INFORMATION_SCHEMA.MYSQL_FIREWALL_USERS WHERE USERHOST = 'fwuser@localhost';\n+------------+\n| MODE       |\n+------------+\n| PROTECTING |\n+------------+\n```\n```sql\nmysql> SELECT RULE FROM INFORMATION_SCHEMA.MYSQL_FIREWALL_WHITELIST WHERE USERHOST = 'fwuser@localhost';\n+-----------------------------------------------------------------------------+\n| RULE                                                                        |\n+-----------------------------------------------------------------------------+\n| SELECT `first_name`, `last_name` FROM `customer` WHERE `customer_id` = ?    |\n| SELECT `get_customer_balance`(? , NOW())                                    |\n| UPDATE `rental` SET `return_date` = NOW() WHERE `rental_id` = ?             |\n| SELECT @@`version_comment` LIMIT ?                                          |\n+-----------------------------------------------------------------------------+\n```\nYou then execute this command: `mysql> CALL mysql.sp_set_firewall_mode('fwuser@localhost', 'RESET');`\nWhich two are true?",
        "selections": {
            "A": "The fwuser@localhost account is removed from the mysql.user table.",
            "B": "The information_schema.MYSQL_FIREWALL_WHITELIST table is truncated.",
            "C": "The whitelist of the fwuser@localhost account is truncated.",
            "D": "The mysql.firewall_users table is truncated.",
            "E": "The firewall resets all options to default values.",
            "F": "The fwuser@localhost account mode is set to DETECTING.",
            "G": "The fwuser@localhost account mode is set to OFF."
        },
        "answers": [
            "C",
            "G"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n调用 `mysql.sp_set_firewall_mode('fwuser@localhost', 'RESET')` 会对指定用户的防火墙配置执行重置操作。\n根据MySQL Enterprise Firewall的文档，将模式设置为`RESET`会导致以下行为：\n1.  删除该用户配置文件的所有规则（即清空白名单）。\n2.  将该用户配置文件的模式设置为`OFF`。\n\nC) `fwuser@localhost` 账户的白名单被清空（truncated）。这是`RESET`操作的一部分 (C 正确)。\nG) `fwuser@localhost` 账户的防火墙模式被设置为`OFF`。这也是`RESET`操作的直接结果 (G 正确)。\n\n错误选项分析：\nA) 防火墙操作不影响`mysql.user`表中的用户账户本身，用户账户仍然存在。\nB) `INFORMATION_SCHEMA.MYSQL_FIREWALL_WHITELIST` 是一个视图，它显示的是所有防火墙用户的白名单规则。`RESET`操作只针对特定用户`fwuser@localhost`的规则，不会清空整个视图（即所有用户的规则）。\nD) `mysql.firewall_users` 表（或类似的基础表）存储了所有已注册防火墙用户及其模式。`RESET`操作会更新特定用户的模式为`OFF`，但不会清空整个表。\nE) “重置所有选项为默认值”过于宽泛。`RESET`主要影响的是特定用户的规则列表和模式。其他防火墙相关的全局设置或不同用户的配置不受影响。\nF) 模式被设置为`OFF`，而不是`DETECTING`。\n\n**考点总结:**\n此题考察对MySQL Enterprise Firewall中`RESET`模式操作效果的理解。核心是它会清除特定用户的白名单规则并将该用户的防火墙模式设置为`OFF`。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解防火墙不同模式（如`OFF`, `DETECTING`, `PROTECTING`, `RECORDING`）的含义以及模式转换（特别是`RESET`）的影响。注意操作是针对特定用户还是全局。\n\n**学习建议:**\n学习MySQL Enterprise Firewall的配置和管理，包括如何注册用户、设置模式、管理白名单规则。查阅官方文档中关于`mysql.sp_set_firewall_mode`存储过程及其不同模式参数（包括`RESET`）的详细说明。"
    },
    {
        "question": "### 试题 28:\n\nChoose two. Examine this statement and output:\n```sql\nmysql> SHOW GRANTS FOR jsmith;\nGrants for jsmith@%\nGRANT USAGE ON *.* TO 'jsmith'@'%'\nGRANT UPDATE (Name) ON `world`.`country` TO 'jsmith'@'%';\n2 rows in set (0.00 sec)\n```\nWhich two SQL statements can `jsmith` execute?",
        "selections": {
            "A": "UPDATE world.country SET Name=CONCAT('New', Name);",
            "B": "UPDATE world.country SET Name='one' LIMIT 1;",
            "C": "UPDATE world.country SET Name='first' ORDER BY Name LIMIT 1;",
            "D": "UPDATE world.country SET Name='all';",
            "E": "UPDATE world.country SET Name='new' WHERE Name='old';"
        },
        "answers": [
            "B",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n用户`jsmith`拥有对`world.country`表`Name`列的`UPDATE`权限。\nB) `UPDATE world.country SET Name='one' LIMIT 1;`：这是一个合法的`UPDATE`语句，只更新`Name`列，并且使用了`LIMIT`子句。用户拥有对`Name`列的更新权限，因此可以执行 (B 正确)。\nD) `UPDATE world.country SET Name='all';`：这是一个合法的`UPDATE`语句，只更新`Name`列，会更新表中所有行的`Name`列。用户拥有对`Name`列的更新权限，因此可以执行 (D 正确)。\n\n错误选项分析：\nA) `UPDATE world.country SET Name=CONCAT('New', Name);`：这个语句在`SET`子句的右侧读取了`Name`列的值 (`CONCAT('New', Name)`)。用户`jsmith`只有对`Name`列的`UPDATE`权限，没有明确的`SELECT`权限。在列级权限下，如果`UPDATE`操作需要读取被更新列的旧值（如本例中的`Name`），则用户也需要对该列有`SELECT`权限。由于未授予`SELECT`权限，此操作可能会失败。\nC) `UPDATE world.country SET Name='first' ORDER BY Name LIMIT 1;`：`ORDER BY Name`子句需要对`Name`列进行读取和排序操作，这通常需要`SELECT`权限。由于用户没有`SELECT (Name)`权限，此操作可能会失败。\nE) `UPDATE world.country SET Name='new' WHERE Name='old';`：`WHERE Name='old'`子句需要对`Name`列进行读取操作以进行比较。由于用户没有`SELECT (Name)`权限，此操作可能会失败。\n\n**考点总结:**\n此题考察MySQL的列级权限。当用户只有对某列的`UPDATE`权限时，他们可以直接设置该列的值（如`SET Name = 'constant_value'`）。但是，如果`UPDATE`语句的`SET`子句的右侧表达式、`WHERE`子句或`ORDER BY`子句中引用了该列（或其他列），则用户还需要对这些被引用的列拥有相应的`SELECT`权限。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细分析`UPDATE`语句的每个部分。如果`SET`右侧、`WHERE`条件或`ORDER BY`中使用了某个列，就需要考虑对该列的读取权限（`SELECT`）。如果权限只授予了`UPDATE (column)`，则只能进行最简单的赋值更新。\n\n**学习建议:**\n深入理解MySQL的权限系统，特别是表级权限和列级权限。学习`GRANT`和`REVOKE`语句的详细语法。练习分析不同权限组合下用户能够执行哪些操作。注意列级权限的细微之处，例如`UPDATE`操作可能隐含地需要`SELECT`权限。"
    },
    {
        "question": "### 试题 29:\n\nChoose two. There are five MySQL instances configured with a working group replication. Examine the output of the group members:\n```sql\nmysql> SELECT MEMBER_ID, MEMBER_STATE FROM performance_schema.replication_group_members;\n+--------------------------------------+--------------+\n| MEMBER_ID                            | MEMBER_STATE |\n+--------------------------------------+--------------+\n| 1999b9fb-4aaf-11e6-bb54-28b2bd168d07 | UNREACHABLE  |\n| 199b2df7-4aaf-11e6-bb16-28b2bd168d07 | ONLINE       |\n| 199bb88e-4aaf-11e6-babe-28b2bd168d07 | ONLINE       |\n| 1ab72fc-4aaf-11e6-bb51-28b2bd168d07 | UNREACHABLE  |\n| 19b33846-4aaf-11e6-ba81-28b2bd168d07 | UNREACHABLE  |\n+--------------------------------------+--------------+\n```\nWhich two statements are true about network partitioning in the cluster?",
        "selections": {
            "A": "The group replication will buffer the transactions on the online nodes until the unreachable nodes return online.",
            "B": "A manual intervention to force group members to be only the working two instances is required.",
            "C": "The cluster will shut down to preserve data consistency.",
            "D": "There could be both a 2 node and 3 node group replication still running, so shutting down group replication and diagnosing the issue is recommended.",
            "E": "The cluster has built-in high availability and updates group_replication_ip_whitelist to remove the unreachable nodes."
        },
        "answers": [
            "B",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n输出显示5个成员中有3个是`UNREACHABLE`，只有2个是`ONLINE`。这是一个典型的网络分区（脑裂）情况。组复制为了保证数据一致性，需要大多数成员（quorum）在线才能继续处理写事务。默认情况下，多数派是 `floor(N/2) + 1`，其中N是配置的组成员总数。在这个例子中，N=5，多数派需要 `floor(5/2) + 1 = 2 + 1 = 3` 个成员在线。\n由于只有2个成员在线，少于3个，所以当前的2个`ONLINE`成员组成的分区无法形成法定多数，因此它们不能处理写事务以避免数据不一致。\n\nD) 这个描述是合理的。由于网络分区，可能存在一个包含2个在线节点的分区和一个（或多个）包含3个不可达节点（它们之间可能互相可见）的分区。如果那3个不可达节点之间仍然可以通信并形成一个3节点的多数派，那么它们可能会继续运行并处理事务，导致与2节点分区的数据分歧。因此，诊断并解决网络分区，可能需要停止部分或全部组复制以进行修复 (D 正确)。\nB) 在这种情况下，如果网络分区无法快速解决，并且希望让当前的2个在线节点恢复服务（即使是以可能丢失少数派分区数据为代价，或者在确认少数派分区确实无法恢复后），管理员可能需要手动干预。这可能包括调整组复制配置，例如强制将这2个节点形成一个新的、较小的组（这通常需要先解决旧组的多数派问题，或者在极端情况下重建组），或者使用`group_replication_force_members`等高级命令（需谨慎使用） (B 正确，指出了手动干预的必要性)。\n\n错误选项分析：\nA) 在线节点（如果它们是少数派）通常不会无限期缓冲事务等待不可达节点恢复。它们会因为无法形成多数派而停止处理写事务，或者进入只读模式。\nC) 集群不一定会“自动关闭”。少数派分区会失去处理写事务的能力，但节点本身可能仍然运行。多数派分区（如果存在且未被管理员干预）可能会继续运行。\nE) 虽然组复制提供高可用性，但它不能自动解决所有类型的网络分区，特别是当没有明确的多数派时。`group_replication_ip_whitelist` (或 `group_replication_ip_allowlist` 在新版本中) 用于限制哪些主机可以连接到组成员，它不直接用于从活动成员列表中移除因网络问题而不可达的节点。\n\n**考点总结:**\n此题考察对MySQL组复制中网络分区和法定数量（quorum）概念的理解。当发生网络分区导致没有分区能形成多数派时，集群的写操作会受阻。解决这类问题通常需要网络修复或管理员手动干预。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n计算法定多数（quorum）是解决此类问题的关键。根据组成员总数判断当前在线成员是否构成多数派。理解多数派机制是为了防止脑裂和数据不一致。当没有多数派时，思考集群的行为和可能的恢复步骤。\n\n**学习建议:**\n深入学习MySQL组复制的架构、成员状态、法定数量机制以及Paxos或其变种协议（如XCom）在达成共识中的作用。了解如何监控组复制状态（如`performance_schema.replication_group_members`表）。学习处理网络分区和成员故障的策略，包括自动恢复机制的限制和需要手动干预的场景。"
    },
    {
        "question": "### 试题 30:\n\nChoose two. Which two statements are true about InnoDB data-at-rest encryption?",
        "selections": {
            "A": "It supports all indexes transparently.",
            "B": "It decrypts data for use in memory.",
            "C": "It supports only non-blob datatypes.",
            "D": "It does not support the transportable tablespaces feature.",
            "E": "It enforces encryption from disk to memory and over network transmission."
        },
        "answers": [
            "A",
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nInnoDB静态数据加密 (data-at-rest encryption) 指的是对存储在磁盘上的表空间文件进行加密。\nA) 它透明地支持所有索引的加密。当表被加密时，其上的所有索引（包括主键和二级索引）也会被加密 (A 正确)。\nB) 当加密的数据页从磁盘读入内存（例如，InnoDB缓冲池）时，数据会被解密以供MySQL服务器使用。在内存中，数据是以未加密的形式存在的 (B 正确)。\n\n错误选项分析：\nC) InnoDB静态加密支持所有数据类型，包括BLOB、TEXT等大对象类型。\nD) 静态加密与可传输表空间（transportable tablespaces）功能是兼容的。加密的表空间可以被传输，但目标服务器需要有相应的密钥才能访问数据。\nE) 静态加密只负责磁盘上数据的加密。数据在内存中是解密的。网络传输的加密（data-in-transit）是由SSL/TLS连接负责的，与静态加密是两回事。\n\n**考点总结:**\n此题考察对InnoDB静态数据加密的关键特性和范围的理解。核心是加密作用于磁盘上的数据（包括表和索引），在内存中数据是解密的，并且它与网络加密是独立的功能。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分“静态数据加密”（data-at-rest）、“动态数据加密”（data-in-transit）和“使用中数据加密”（data-in-use，通常指内存中数据的处理）。明确InnoDB静态加密主要解决的是物理存储介质丢失或被未授权访问时的安全问题。\n\n**学习建议:**\n学习MySQL的透明数据加密（TDE）功能，特别是InnoDB的实现方式。了解其架构（如两层密钥管理：master key和tablespace keys）、配置步骤、支持的加密算法以及对性能的影响。熟悉如何管理加密密钥（如使用keyring插件）。"
    },
    {
        "question": "### 试题 31:\n\nChoose three. Which three statements are true about MySQL Enterprise Firewall?",
        "selections": {
            "A": "On Windows systems, it is controlled and managed using the Windows Internet Connection Firewall control panel.",
            "B": "System tables named firewall_users and firewall_whitelist in the mysql database provide persistent storage of firewall data.",
            "C": "It is available only in MySQL Enterprise versions.",
            "D": "It provides INFORMATION_SCHEMA tables that enable views into firewall data.",
            "E": "Firewall functionality is dependent on SHA-256 and ANSI-specific functions built in to the mysql.firewall table.",
            "F": "It shows only notifications for blocked connections, which originated outside of your network's primary domain."
        },
        "answers": [
            "B",
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL Enterprise Firewall 是一种应用层防火墙，用于监控和限制特定用户账户可执行的SQL语句。\nB) 防火墙的配置数据（如注册的用户、模式、白名单规则）持久化存储在`mysql`数据库的系统表中，例如`firewall_users`（存储用户和模式）和`firewall_whitelist`（存储规则）。这些表在MySQL 8.0中可能是类似名称的内部数据字典表 (B 正确)。\nC) MySQL Enterprise Firewall 是MySQL企业版提供的商业特性，在社区版中不可用 (C 正确)。\nD) MySQL Enterprise Firewall 提供了`INFORMATION_SCHEMA`下的视图（如`MYSQL_FIREWALL_USERS`, `MYSQL_FIREWALL_WHITELIST`）来方便用户查询和监控防火墙的状态和配置数据 (D 正确)。\n\n错误选项分析：\nA) MySQL Enterprise Firewall 是MySQL服务器内部的功能，其管理通过SQL接口（如存储过程`mysql.sp_set_firewall_mode`）或MySQL Enterprise Monitor进行，与Windows操作系统自带的防火墙控制面板无关。\nE) 防火墙功能的核心是SQL语句模式匹配和白名单管理，不依赖于特定的SHA-256或ANSI函数内置于`mysql.firewall`表（表名可能不准确，且功能实现并非如此）。规则的存储和匹配有其自身的逻辑。\nF) 防火墙可以记录和通知所有被阻止的连接或查询，而不仅仅是来自特定网络域外部的连接。其监控范围是基于注册的MySQL用户账户，而非网络来源。\n\n**考点总结:**\n此题考察对MySQL Enterprise Firewall的基本特性、可用性、数据存储和监控方式的理解。关键点在于它是企业版功能，通过内部表存储配置，并提供Information Schema视图进行访问。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分MySQL Enterprise Firewall与操作系统防火墙或网络防火墙。记住它是MySQL的一个高级安全特性，与特定版本（企业版）相关联。了解其数据如何持久化以及如何被用户查看。\n\n**学习建议:**\n学习MySQL Enterprise Firewall的工作原理、配置步骤（注册用户、训练模式、保护模式）、管理方法以及如何监控其活动。熟悉相关的存储过程和Information Schema视图。了解其在防止SQL注入和未授权数据访问方面的作用。"
    },
    {
        "question": "### 试题 32:\n\nChoose two. Which two storage engines provide a view of the data consistent with the storage system at any moment?",
        "selections": {
            "A": "InnoDB",
            "B": "ARCHIVE",
            "C": "MyISAM",
            "D": "MEMORY",
            "E": "NDB"
        },
        "answers": [
            "A",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n“在任何时刻提供与存储系统一致的数据视图”通常指的是事务型存储引擎提供的ACID特性，特别是原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation）。\nA) InnoDB：是MySQL默认的事务型存储引擎，完全支持ACID特性，通过MVCC（多版本并发控制）为不同事务提供一致性的数据视图 (A 正确)。\nE) NDB (MySQL Cluster)：是MySQL Cluster使用的存储引擎，也是一个完全支持ACID的事务型存储引擎，设计用于高可用和分布式环境，保证数据一致性 (E 正确)。\n\n错误选项分析：\nB) ARCHIVE：用于存储大量归档数据，支持压缩，但不支持事务，也不支持索引（除了自增ID）。它不保证复杂查询的一致性视图。\nC) MyISAM：是非事务型存储引擎。它不支持事务、行级锁或MVCC。在高并发读写情况下，数据一致性视图难以保证，可能发生脏读等问题。\nD) MEMORY (HEAP)：是内存表存储引擎，数据存储在内存中。它不支持事务（虽然某些操作可能是原子性的），并且在服务器重启后数据会丢失。它不提供严格的MVCC或跨事务的一致性视图。\n\n**考点总结:**\n此题考察对MySQL不同存储引擎事务特性和数据一致性保证的理解。核心在于识别哪些引擎是事务安全的并能提供MVCC等机制来确保一致性视图。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n将“一致的数据视图”与ACID特性（特别是事务和隔离级别）联系起来。回忆哪些存储引擎是事务型的。\n\n**学习建议:**\n详细学习MySQL中主要的存储引擎，如InnoDB, MyISAM, NDB, MEMORY, ARCHIVE, CSV等。重点掌握它们各自的特性、优点、缺点、适用场景，特别是对事务、锁机制（表锁/行锁）、MVCC、外键、全文索引等的支持情况。"
    },
    {
        "question": "### 试题 33:\n\nChoose three. Which three are requirements for a secure MySQL Server environment?",
        "selections": {
            "A": "Minimize the number of non-MySQL Server-related processes running on the server host.",
            "B": "Restrict the number of OS users that have access at the OS level.",
            "C": "Ensure appropriate file system privileges for OS users and groups.",
            "D": "Keep the entire software stack on one OS host.",
            "E": "Encrypt the file system to avoid needing exact file-system permissions.",
            "F": "Run MySQL server as the root user to prevent incorrect sudo settings."
        },
        "answers": [
            "A",
            "B",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n确保MySQL服务器环境的安全涉及多个层面，包括操作系统安全和MySQL自身安全。\nA) 最小化服务器主机上运行的非MySQL相关进程数量。这减少了潜在的攻击面和资源竞争，是服务器安全加固的一般原则 (A 正确，此处OCR标记为错误，但根据安全最佳实践应为正确)。\nB) 限制在操作系统级别拥有访问权限（特别是对MySQL数据目录或配置文件有权限）的OS用户数量。最小化特权OS用户，减少内部威胁或账户泄露的风险 (B 正确)。\nC) 为OS用户和组确保适当的文件系统权限。特别是MySQL数据目录、日志文件、配置文件等，应该严格限制访问权限，通常只允许`mysql`操作系统用户访问 (C 正确)。\n\n错误或不完全准确的选项分析：\nD) “将整个软件栈保留在一个OS主机上”本身不是一个安全要求。分布式架构或服务分离有时可以增强安全性或弹性。关注点应在于每个组件的安全配置，而非是否在同一主机。\nE) 文件系统加密是一种有用的安全措施，可以保护静态数据。但它不能完全替代正确的文件系统权限设置。权限控制了谁（用户/进程）可以对文件进行何种操作（读/写/执行），这是与加密不同的安全层面。\nF) 绝对不能以`root`操作系统用户身份运行MySQL服务器。这会带来巨大的安全风险，一旦MySQL进程被攻破，攻击者将获得整个系统的root权限。MySQL应该以专用的、低权限的`mysql`用户运行。`sudo`设置是为了让授权用户以root权限执行特定命令，与MySQL运行用户是两回事。\n\n**考点总结:**\n此题考察MySQL服务器运行环境的整体安全要求。遵循最小权限原则、减少攻击面、以及正确配置操作系统和文件系统权限是关键。\n\n**答案修正说明:** 根据安全最佳实践，A选项“Minimize the number of non-MySQL Server-related processes running on the server host”是一个重要的安全措施。因此，正确的答案组合应该是A, B, C。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n从“纵深防御”和“最小权限”的角度思考。安全不仅仅是MySQL本身的配置，还包括其运行的操作系统环境。排除那些明显违反安全原则（如以root运行）或与安全目标不直接相关的选项。\n\n**学习建议:**\n学习MySQL安全部署的最佳实践，这包括：\n1.  操作系统加固：最小化安装、禁用不必要的服务和进程、定期打补丁。\n2.  MySQL运行用户：使用专用的低权限`mysql`用户运行服务。\n3.  文件系统权限：严格限制对MySQL数据目录、配置文件、日志文件的访问。\n4.  网络安全：防火墙配置、`bind-address`、禁用不必要的网络协议。\n5.  MySQL内部安全：强密码策略、用户账户权限最小化、定期审计、使用SSL/TLS加密连接等。"
    },
    {
        "question": "### 试题 34:\n\nChoose two. Examine this list of MySQL data directory binary logs: `binlog.000001 binlog.000002 ... binlog.000289 binlog.000300 binlog.000301 binlog.index`\nNow examine this command, which executes successfully: `mysqldump --delete-master-logs --all-databases > /backup/db_backup.sql`\nWhich two are true?",
        "selections": {
            "A": "All databases are backed up to the output file.",
            "B": "All non-active binary logs are removed from the master.",
            "C": "All binary logs are backed up and then deleted.",
            "D": "All binary logs are deleted from the master.",
            "E": "All databases, excluding master metadata, are backed up to the output file.",
            "F": "All details regarding deleted logs and master metadata are captured in the output file."
        },
        "answers": [
            "A",
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqldump --delete-master-logs --all-databases > /backup/db_backup.sql` 命令的作用：\n1.  `--all-databases`: 备份所有数据库的结构和数据到指定的输出文件。\n2.  `--delete-master-logs`: 在成功完成dump操作后，会删除主服务器上那些在dump开始时刻之前已经不再活动的二进制日志文件。它不会删除当前正在写入的活动binlog文件，也不会删除dump期间新产生的binlog文件。\n\nA) 所有数据库都被备份到输出文件。这是`--all-databases`选项的作用 (A 正确)。\nB) 所有非活动的二进制日志（即那些在备份开始时已经关闭并且内容已完全包含在备份中的旧日志）会从主服务器上被移除。这对应`--delete-master-logs`的行为 (B 正确)。\n\n错误选项分析：\nC) 二进制日志本身不被“备份”（即复制其内容到备份文件）。`mysqldump`是逻辑备份，备份的是数据库内容。`--delete-master-logs`只是删除文件。\nD) 不是所有二进制日志都被删除。当前活动的binlog和在dump期间新生成的binlog不会被删除。\nE) `--all-databases`通常包含了主数据库的元数据信息（如存储过程、函数、事件等）。“排除主元数据”是不准确的。而且，`mysqldump`关注的是数据库内容，而不是主服务器二进制日志的元数据。\nF) 输出文件 `/backup/db_backup.sql` 主要包含SQL语句来重建数据库。它会包含记录备份时binlog位置点的信息（例如，通过`--master-data`选项，虽然本题未明确使用，但`--delete-master-logs`通常与之配合），但不会包含“已删除日志的详细信息”。\n\n**考点总结:**\n此题考察对`mysqldump`命令中`--all-databases`和`--delete-master-logs`选项的理解。关键在于区分备份内容和日志清理行为，以及日志清理的范围（仅限非活动日志）。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n准确理解`mysqldump`的各个选项含义。`--delete-master-logs`是一个清理操作，不是备份操作。注意其清理范围的精确性。\n\n**学习建议:**\n熟练掌握`mysqldump`工具的使用，包括常用选项如`--all-databases`, `--databases`, `--single-transaction`, `--master-data`, `--routines`, `--events`, `--triggers`, `--hex-blob`, `--delete-master-logs`, `PURGE BINARY LOGS` SQL命令等。理解逻辑备份和物理备份的区别。学习如何制定合理的备份和日志管理策略。"
    },
    {
        "question": "### 试题 35:\n\nYou want to install and configure MySQL on Linux server with tarball binaries in the `/app/mysql/` directory, where the bin directory is found at `/app/mysql/bin` and the data directory at `/app/data`. Which two parameters are required to configure the MySQL instance?",
        "selections": {
            "A": "The configuration basedir=/app/mysql is needed.",
            "B": "The configuration datadir=/app/data is needed.",
            "C": "The configuration log-bin=/app/data is needed.",
            "D": "The configuration datadir=/app/mysql/data is needed",
            "E": "The configuration innodb_log_group_home_dir=/datadir is needed.",
            "F": "The configuration basedir=/app/mysql/bin is needed."
        },
        "answers": [
            "A",
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n在通过tarball二进制包安装MySQL时，通常需要在配置文件（如`my.cnf`）中或在初始化命令中指定关键路径参数。\n- `basedir`: MySQL的安装基础目录，即包含`bin`, `lib`, `share`等子目录的顶级目录。根据题意，这是`/app/mysql/`。\n- `datadir`: MySQL的数据存储目录，用于存放数据库文件、日志文件等。根据题意，这是`/app/data/`。\n\nA) `basedir=/app/mysql` 是正确的，因为MySQL的`bin`目录位于`/app/mysql/bin`，所以`/app/mysql`是基础安装目录 (A 正确)。\nB) `datadir=/app/data` 是正确的，题目明确指出数据目录在`/app/data` (B 正确)。\n\n错误选项分析：\nC) `log-bin=/app/data`：虽然可以将二进制日志放在数据目录中（或者其子目录），但这本身不是一个“必需”的配置参数来启动和运行MySQL实例。是否启用二进制日志取决于需求。\nD) `datadir=/app/mysql/data`：这与题目给出的数据目录 `/app/data` 不符。\nE) `innodb_log_group_home_dir=/datadir`：这指的是InnoDB redo日志的存放目录。如果未指定，默认是在`datadir`下。它也不是启动MySQL实例的绝对必需参数（除非想将其放到`datadir`之外）。且这里的`/datadir`是一个占位符，不是具体路径。\nF) `basedir=/app/mysql/bin`：`basedir`应该是包含`bin`目录的父目录，而不是`bin`目录本身。\n\n**考点总结:**\n此题考察MySQL通过tarball安装时的基本配置要求，特别是`basedir`和`datadir`这两个核心路径参数的设定。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解`basedir`和`datadir`的含义和区别。`basedir`指向软件安装的根，`datadir`指向数据的存储位置。根据题目描述的目录结构来确定正确的值。\n\n**学习建议:**\n学习MySQL的不同安装方式（如RPM/DEB包、tarball二进制、源码编译）。掌握通过tarball安装的步骤，包括解压、创建`mysql`用户和组、初始化数据目录（使用`mysqld --initialize`）、配置`my.cnf`文件（特别是`basedir`和`datadir`）、启动服务器、设置root密码等。了解MySQL服务器启动时如何查找和使用这些路径参数。"
    },
    {
        "question": "### 试题 36:\n\nA valid raw backup of the `shop.customers` MyISAM table was taken. You must restore the table. You begin with these steps:\n1. Confirm that `secure_file_priv='/var/tmp'`\n2. `mysql> DROP TABLE shop.customers;`\n3. `shell> cp /backup/customers.MY* /var/lib/mysql/shop/`\nWhich two actions are required to complete the restore? (Choose two.)",
        "selections": {
            "A": "shell> cp /backup/customers.sdi /var/tmp",
            "B": "shell> cp /backup/customers.sdi /var/lib/mysql/shop/",
            "C": "mysql> SOURCE '/var/tmp/customers.sdi'",
            "D": "mysql> IMPORT TABLE FROM '/var/tmp/customers.sdi'",
            "E": "shell> cp /backup/customers.frm /var/lib/mysql/shop/",
            "F": "mysql> IMPORT TABLE FROM '/var/lib/mysql/shop/customers.sdi'",
            "G": "mysql> ALTER TABLE shop.customers IMPORT TABLESPACE",
            "H": "mysql> ALTER TABLE shop.customers DISCARD TABLESPACE"
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n题目描述的是恢复一个MyISAM表，并且提到了`.sdi`文件和`secure_file_priv`。这暗示了可能使用MySQL 8.0引入的基于SDI（Serialized Dictionary Information）文件的导入功能，尽管MyISAM表的元数据传统上存储在`.frm`文件中。\n然而，传统的MyISAM表恢复，在复制了`.MYD`（数据）和`.MYI`（索引）文件后，还需要表定义文件`.frm`。\n\n考虑到选项中出现了`IMPORT TABLE FROM`和`.sdi`文件，我们假设题目环境是MySQL 8.0+，并且备份可能包含了`.sdi`文件。\n`IMPORT TABLE FROM`语句用于从`.sdi`文件导入表定义。\n步骤3复制了`customers.MY*`（即`customers.MYD`和`customers.MYI`）到数据目录。现在需要恢复表结构。\n\nA) `shell> cp /backup/customers.sdi /var/tmp`：将SDI文件复制到`secure_file_priv`指定的目录 `/var/tmp`。这是因为`IMPORT TABLE FROM`需要从一个MySQL服务器可安全访问的位置读取SDI文件 (A 正确)。\nD) `mysql> IMPORT TABLE FROM '/var/tmp/customers.sdi';`：在MySQL中执行此命令，从位于`/var/tmp`的SDI文件导入表结构。这会创建表定义，并关联到已复制到数据目录的`.MYD`和`.MYI`文件 (D 正确)。\n\n如果题目意图是传统的MyISAM恢复（不使用SDI导入）：\n那么应该是E) `shell> cp /backup/customers.frm /var/lib/mysql/shop/`，然后可能需要`FLUSH TABLES;`。\n\n但是，鉴于`secure_file_priv`的提及和`IMPORT TABLE FROM`选项的存在，基于SDI的恢复流程是更有可能的考点。\n\n错误选项分析（基于SDI流程）：\nB) SDI文件不需要复制到MySQL的数据目录中给`IMPORT TABLE FROM`使用，而是复制到`secure_file_priv`指定的目录。\nC) `SOURCE`命令用于执行SQL脚本文件，不是导入SDI文件。\nE) 如果使用SDI导入，则不需要单独复制`.frm`文件。\nF) `IMPORT TABLE FROM`后面直接跟SDI文件的完整路径，而不是表名。\nG, H) `IMPORT TABLESPACE`和`DISCARD TABLESPACE`是用于InnoDB表空间传输的，与MyISAM表或SDI导入无关。\n\n**考点总结:**\n此题可能考察MySQL 8.0中基于SDI文件的表结构导入，或者传统的MyISAM表文件恢复。根据`secure_file_priv`和`IMPORT TABLE FROM`的提示，SDI导入流程是主要考点。这要求将SDI文件放到安全路径，然后使用SQL命令导入。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n注意题目中给出的所有线索，如`secure_file_priv`和特定SQL命令的出现。这有助于判断题目背景和可能的解决方案。区分不同存储引擎的备份恢复方法。\n\n**学习建议:**\n学习MySQL 8.0中引入的SDI（Serialized Dictionary Information）及其在备份恢复（特别是与`mysqldump`和传输表空间）中的作用。了解`IMPORT TABLE FROM`语句的使用方法。同时也要掌握传统MyISAM表（`.frm`, `.MYD`, `.MYI`文件）的备份和恢复步骤。理解`secure_file_priv`系统变量的含义和限制。"
    },
    {
        "question": "### 试题 37:\n\nChoose two. You are investigating performance problems in a MySQL database; all data fits in memory. You determine that SELECT queries to one table is the main cause for poor response times. Which two have the biggest potential for eliminating the problem?",
        "selections": {
            "A": "high concurrency",
            "B": "operating system resources",
            "C": "column definitions",
            "D": "innodb mutexes",
            "E": "non-transaction storage engine",
            "F": "table indexes"
        },
        "answers": [
            "A",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n问题是`SELECT`查询响应慢，且所有数据都在内存中。这意味着磁盘I/O不是瓶颈。\n需要寻找可能导致CPU瓶颈、锁争用或查询本身效率低下的原因。\n\nE) 如果该表使用的是非事务性存储引擎（如MyISAM），它可能使用表级锁。高并发的`SELECT`查询（即使是读操作）可能会因为其他写操作（或某些读操作）持有表锁而等待，导致响应时间变慢。将其改为支持行级锁和MVCC的事务性引擎（如InnoDB）可以显著改善并发`SELECT`性能 (E 选项指出非事务存储引擎是一个问题，暗示改为事务引擎是解决方案，因此E本身指出了一个**潜在原因**)。\nA) 高并发本身是导致性能问题的常见场景。即使数据在内存中，大量的并发查询也可能导致CPU竞争、上下文切换开销、或者在存储引擎内部（如InnoDB的latch/mutex争用）产生瓶颈 (A 指出了一个**潜在原因**)。\n\n错误或间接相关的选项分析：\nB) 操作系统资源：虽然CPU是OS资源的一部分，但该选项过于宽泛。如果特指CPU耗尽，那与A（高并发）相关。\nC) 列定义：不合适的列定义（如使用过大的数据类型）会增加内存消耗和CPU处理（如比较、转换），但通常不是`SELECT`慢的主要原因，除非它们导致了非常低效的查询计划（例如，无法使用索引）。\nD) InnoDB互斥锁（mutexes）：如果表是InnoDB，并且在高并发下确实存在内部互斥锁争用，这会导致性能下降。但这个选项太具体，而A（高并发）是更上层的原因，E（存储引擎类型）则是可能导致锁问题的基础。\nF) 表索引：如果查询没有合适的索引，或者索引选择不当，会导致全表扫描或低效的索引扫描，即使数据在内存中，CPU开销也会很大。**这是`SELECT`查询慢的最常见和最直接原因。** 然而，题目要求选择“两个最大的潜力”。如果E和A是更根本的架构或并发问题，解决它们可能带来更大范围的改善。\n\n**答案考量:**\n题目问“消除问题最大的潜力”。\n- 如果存储引擎是 MyISAM (E)，改为 InnoDB 能解决表锁问题，对并发`SELECT`有巨大提升。\n- 高并发 (A) 场景下，即使是 InnoDB，也可能需要优化查询、调整并发控制参数或扩展硬件来应对。\n- 索引 (F) 的优化是针对特定查询的，如果多个慢查询都指向一个表，且都是因为索引问题，那么优化索引潜力巨大。\n\n在许多情况下，索引(F)的缺失或不当是SELECT慢的首要原因。如果假设索引已经存在但仍慢，那么并发(A)和存储引擎特性(E)就成了主要考虑因素。原答案选择了A和E，可能是从更宏观或架构层面考虑。如果索引非常糟糕，F的潜力可能最大。\n\n**考点总结:**\n此题考察对SELECT查询性能瓶颈的诊断。当数据在内存中时，瓶颈通常转向CPU、锁争用或查询计划本身。需要考虑并发级别、存储引擎特性和索引优化。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n当题目说数据全在内存时，首先排除磁盘I/O瓶颈。然后分析查询慢的可能原因：\n1.  查询本身是否高效（索引是否使用得当）？\n2.  是否存在锁争用（表级锁 vs 行级锁）？\n3.  并发量是否过大导致CPU或其他资源竞争？\n选择那些能从根本上改变查询执行方式或并发处理能力的选项。\n\n**学习建议:**\n深入学习MySQL查询优化，特别是索引的设计和使用（选择合适的索引类型、覆盖索引、避免全表扫描、理解`EXPLAIN`输出）。学习不同存储引擎的锁机制及其对并发性能的影响。了解如何诊断和解决高并发下的性能问题，包括CPU分析、锁监控、InnoDB内部争用等。"
    },
    {
        "question": "### 试题 38:\n\nChoose two. You have semi-synchronous replication configured and working with one slave. `rpl_semi_sync_master_timeout` has never been reached. You find that the disk system on the master has failed and as a result, the data on the master is completely unrecoverable.\nWhich two statements are true?",
        "selections": {
            "A": "The slave automatically identifies that the master is unreachable and performs any required actions so that applications can start using the slave as the new master.",
            "B": "Reads from the slave can return outdated data until the value of the rpl_semi_sync_master_timeout variable is reached.",
            "C": "No committed transactions are lost.",
            "D": "Reads from the slave can return outdated data for some time, until it applies all transactions from its relay log.",
            "E": "A small amount of committed transactions may be lost in case they were committed just before the disk failure.",
            "F": "As soon as the incident happens, application can read data from the slave and rely on it to return a full and current set of data."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n半同步复制（Semi-synchronous replication）的机制是：主库在提交事务后，会等待至少一个从库确认已接收到该事务的binlog事件，然后主库才会将结果返回给客户端。`rpl_semi_sync_master_timeout`是主库等待从库确认的超时时间，如果超时，主库会自动转为异步复制。题目说这个超时“从未到达”，意味着在主库磁盘故障之前，所有在主库上成功提交并返回给客户端的事务，其binlog事件都已经被从库接收到了。\n\nC) 没有已提交的事务丢失。因为半同步保证了事务在主库提交（并返回给客户端）前，其binlog已被从库接收。所以从库上拥有所有主库已成功提交的事务数据 (C 正确)。\nD) 从库上的读操作可能会返回过时的数据，直到它应用完其中继日志（relay log）中所有已接收的事务。从库的I/O线程负责接收binlog到relay log，SQL线程负责应用relay log中的事件。在SQL线程应用完毕之前，从库的数据状态可能落后于其relay log中最新接收到的事件 (D 正确)。\n\n错误选项分析：\nA) 从库不会“自动”识别主库不可达并“自动”执行故障转移成为新主库。故障转移通常需要外部工具（如MHA, Orchestrator, InnoDB Cluster）或手动操作。\nB) `rpl_semi_sync_master_timeout`是主库端的设置，与从库数据是否过时以及何时更新没有直接关系。从库数据是否过时取决于SQL线程的应用进度。\nE) 因为半同步的保证，在主库磁盘故障前“已提交”的事务（即客户端已收到成功响应），其binlog已被从库接收，所以不会丢失。如果事务在主库本地提交了但还未等从库确认就发生了磁盘故障（且客户端未收到成功响应），那这个事务在主库上本身就是未完成的，谈不上“丢失已提交事务”。\nF) 从库数据不一定是“完全和当前的”。如D所述，SQL线程可能仍在应用中继日志，所以数据可能不是最新的。应用需要知道从库可能存在一定的复制延迟。\n\n**考点总结:**\n此题考察对半同步复制工作原理和数据一致性保证的理解。核心在于半同步复制通过等待从库确认来减少数据丢失的风险，但它不保证零数据丢失（例如，如果主库在等待确认时崩溃，而从库也恰好在那时崩溃）。题目中“超时从未到达”是一个关键条件。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解半同步复制与异步复制的关键区别——主库会等待从库的ACK。关注“超时从未到达”这个条件，它简化了数据丢失的分析。区分数据接收（I/O线程到relay log）和数据应用（SQL线程到数据库）。\n\n**学习建议:**\n深入学习MySQL半同步复制的配置、工作流程、参数（如`rpl_semi_sync_master_enabled`, `rpl_semi_sync_slave_enabled`, `rpl_semi_sync_master_timeout`, `rpl_semi_sync_master_wait_for_slave_count`）。了解其优缺点，以及它在“有损半同步”（AFTER_SYNC）和“无损半同步”（AFTER_COMMIT，MySQL 8.0.20+，但题目场景更像AFTER_SYNC）下的行为差异。学习故障转移的概念和常见实现方案。"
    },
    {
        "question": "### 试题 39:\n\nChoose three. You are considering using file-system snapshots to back up MySQL.\nWhich three statements are true?",
        "selections": {
            "A": "There is a slight performance cost while the snapshot is active.",
            "B": "The backup window is almost zero from the perspective of the application.",
            "C": "They allow direct copying of table rows with operating system copy commands.",
            "D": "They do not back up views, stored procedures, or configuration files.",
            "E": "They take roughly twice as long as logical backups.",
            "F": "They work best for transaction storage engines that can perform their own recovery when restored.",
            "G": "They do not use additional disk space."
        },
        "answers": [
            "A",
            "B",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n文件系统快照（如LVM快照、ZFS快照等）是一种物理备份方法，它在某个时间点创建文件系统的一致性副本。\nA) 在快照创建和维护期间，通常会有轻微的性能开销，因为文件系统需要跟踪原始卷和快照卷之间的块变化（例如，使用写时复制Copy-on-Write机制） (A 正确)。\nB) 从应用程序的角度看，创建快照本身的操作非常快，通常在秒级完成。这意味着数据库服务几乎不需要暂停或锁定很长时间，备份窗口非常小 (B 正确)。\nF) 文件系统快照是物理备份，恢复时是将整个数据文件恢复到快照创建时的状态。事务性存储引擎（如InnoDB）在启动时会进行崩溃恢复，应用redo log中未完成的事务并回滚未提交的事务，从而使数据库达到一个一致的状态。因此，快照备份对于能够进行自我恢复的事务性引擎效果最好 (F 正确)。\n\n错误选项分析：\nC) 文件系统快照是对整个文件系统或卷的块级复制，而不是直接复制“表行”。恢复后，数据库通过其内部机制（如InnoDB的崩溃恢复）来整理数据。\nD) 文件系统快照备份的是MySQL数据目录下的所有文件。如果视图定义、存储过程（通常存储在数据字典或系统表中，这些也是数据目录的一部分）以及配置文件（如果也位于被快照的卷上）都在这个范围内，它们会被一并备份。但配置文件通常在数据目录之外。\nE) 快照创建非常快。备份时间主要取决于从快照复制数据到备份介质的时间。与逻辑备份（如`mysqldump`，需要扫描和转换数据）相比，其速度取决于具体实现和数据量，不一定是“两倍长”，甚至可能更快（特别是对于大数据量）。\nG) 快照本身（特别是写时复制快照）初始时可能只占用少量元数据空间。但随着原始卷数据的修改，快照会开始占用额外的磁盘空间来存储旧的数据块。所以说“不使用额外磁盘空间”是不准确的。\n\n**考点总结:**\n此题考察对使用文件系统快照进行MySQL物理备份的理解。关键点包括快照的创建速度、对应用的影响、性能开销、对存储引擎的要求以及空间占用。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解文件系统快照的基本原理（如写时复制）。将其与逻辑备份（如`mysqldump`）和InnoDB的热物理备份（如MySQL Enterprise Backup, Percona XtraBackup）进行对比。关注快照在创建速度、一致性保证和恢复过程方面的特点。\n\n**学习建议:**\n学习不同的MySQL备份方法及其优缺点。了解如何结合文件系统快照（如LVM）与MySQL的`FLUSH TABLES WITH READ LOCK`（或不锁而依赖InnoDB崩溃恢复）来创建一致性备份。熟悉使用快照备份时，对事务性存储引擎（特别是InnoDB）进行恢复的步骤和注意事项。"
    },
    {
        "question": "### 试题 40:\n\nChoose two. Which two commands will display indexes on the `parts` table in the `manufacturing` schema?",
        "selections": {
            "A": "EXPLAIN manufacturing.parts;",
            "B": "SELECT * FROM information_schema.statistics WHERE table_schema = 'manufacturing' AND TABLE_NAME = 'parts';",
            "C": "DESCRIBE manufacturing.parts;",
            "D": "SHOW INDEXES FROM manufacturing.parts;",
            "E": "SELECT * FROM information_schema.COLUMN_STATISTICS;"
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n有多种方法可以查看表的索引信息：\nC) `DESCRIBE manufacturing.parts;` (或 `DESC manufacturing.parts;`, `EXPLAIN manufacturing.parts;`)：这个命令会显示表的列信息，其中 `Key` 列会指示哪些列是索引的一部分（如PRI为主键，UNI为唯一索引，MUL为普通索引） (C 正确)。\nD) `SHOW INDEXES FROM manufacturing.parts;` (或 `SHOW INDEX FROM manufacturing.parts;`)：这个命令专门用于显示指定表上的所有索引的详细信息，包括索引名、列名、唯一性、基数等 (D 正确)。\n\n错误选项分析：\nA) OCR中将`EXPLAIN`命令与选项D的注释`['description', 'EXPLAIN']`混淆。单独的`EXPLAIN manufacturing.parts;` 等同于 `DESCRIBE manufacturing.parts;`，可以显示索引信息。如果将此视为一个独立选项，则也正确。但通常`DESCRIBE`更直接。\nB) `SELECT * FROM information_schema.statistics WHERE table_schema = 'manufacturing' AND TABLE_NAME = 'parts';`：这个查询确实可以从`information_schema.statistics`表中获取索引信息，但题目通常倾向于更直接的SQL命令。此选项在OCR中标记为错误，可能是因为题目期望的是`SHOW`或`DESCRIBE`这类简便命令。但从功能上讲，它是可以获取索引信息的。\nE) `information_schema.COLUMN_STATISTICS` 存储的是列的统计信息（如直方图），用于查询优化，不直接显示索引定义。\n\n**考点总结:**\n此题考察查看MySQL表索引信息的常用命令。`SHOW INDEXES` 和 `DESCRIBE` (或 `EXPLAIN table_name`) 是最直接和常用的方法。通过`INFORMATION_SCHEMA`查询也是一种方式，但更底层和详细。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住显示表结构和索引的几个常用命令。`SHOW INDEXES` 最为直接明了。`DESCRIBE` 也能提供索引线索。当题目要求“命令”时，优先考虑SQL管理命令而非直接查询系统表（除非特定场景）。\n\n**学习建议:**\n熟练掌握 `SHOW CREATE TABLE table_name;`, `DESCRIBE table_name;`, `SHOW INDEXES FROM table_name;` 等命令的使用。了解`INFORMATION_SCHEMA`数据库中与元数据相关的表，如`TABLES`, `COLUMNS`, `STATISTICS`, `KEY_COLUMN_USAGE`等，知道如何通过查询它们来获取更详细或定制化的信息。"
    },
    {
        "question": "### 试题 41:\n\nOn examination, your MySQL installation datadir has become recursively world (所有用户) read/write/executable. What are two major concerns of running an installation with incorrect file privileges?",
        "selections": {
            "A": "Data files could be deleted. (datafiles)",
            "B": "Users could overwrite configuration files. (mysqld-auto.cnf)",
            "C": "SQL injections could be used to insert bad data into the database.",
            "D": "Extra startup time would be required for the MySQL server to reset the privileges."
        },
        "answers": [
            "A",
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL数据目录（datadir）的权限被设置为对所有用户可读、可写、可执行（通常是777权限），这是一个严重的安全漏洞。\nA) 数据文件可能被删除：由于所有用户都有写权限，任何能够访问该文件系统的用户（包括恶意的本地用户或通过其他漏洞获得访问权限的远程用户）都可以删除或修改数据文件，导致数据丢失或损坏 (A 正确)。\nB) 用户可能覆盖配置文件：配置文件（如`my.cnf`，或者在数据目录下的`mysqld-auto.cnf`）如果也具有过于宽松的权限，可能被未授权用户修改。修改配置文件可能导致服务器无法启动、行为异常或引入更多安全漏洞 (B 正确)。\n\n错误选项分析：\nC) SQL注入是应用层面的漏洞，利用的是应用程序在构造SQL查询时未正确处理用户输入。虽然不正确的文件权限会加剧被攻击后的损害程度（例如，攻击者通过SQL注入获得执行OS命令的权限后，可以利用宽松的文件权限进行更多破坏），但文件权限本身不直接导致SQL注入漏洞的产生。\nD) MySQL服务器启动时不会自动“重置文件权限”。文件权限是由操作系统管理的。如果权限不正确，MySQL服务器可能会因为无法安全运行而拒绝启动，或者在不安全的状态下运行。但它不会花额外时间去“重置”操作系统的文件权限。\nE) (未完整显示在OCR中，但从上下文推测) MySQL二进制文件（通常在`basedir`下，而非`datadir`）如果权限不当，也可能被损坏、删除或替换。但题目特指`datadir`的权限问题。\n\n**考点总结:**\n此题考察不正确的文件系统权限（特别是对MySQL数据目录）所带来的安全风险。核心在于数据和配置的机密性、完整性和可用性受到威胁。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解Linux文件权限（读、写、执行）的含义及其组合。当权限过于宽松时，思考可能发生的最坏情况，特别是针对敏感数据和关键配置文件。区分文件系统层面的安全问题和应用层面的安全问题（如SQL注入）。\n\n**学习建议:**\n学习MySQL安全部署的最佳实践，其中重要的一环就是正确设置文件和目录的权限。通常，MySQL数据目录及其内容应该只允许`mysql`操作系统用户拥有读写权限，其他用户不应有访问权限。配置文件也应类似保护。了解如何使用`chown`和`chmod`命令来设置正确的权限。"
    },
    {
        "question": "### 试题 42:\n\nChoose three. Which three requirements must be enabled for group replication?",
        "selections": {
            "A": "replication filters",
            "B": "semi-sync replication plugin",
            "C": "slave updates logging",
            "D": "binary log checksum",
            "E": "primary key or primary key equivalent on every table",
            "F": "binary log MIXED format",
            "G": "binary log ROW format"
        },
        "answers": [
            "C",
            "E",
            "G"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL组复制 (Group Replication) 对服务器配置有一些特定要求：\nC) `log_slave_updates` (或 `log_replica_updates` 在新版本中) 必须启用。这确保了从其他成员复制过来的更改也会被记录到当前成员的二进制日志中，这对于维持组成员之间的一致性和允许其他从库从组成员进行复制是必要的 (C 正确)。\nE) 参与组复制的所有表都必须有一个主键，或者在没有显式主键的情况下，必须有一个等效的非空唯一键。这是因为组复制在内部使用主键来识别和处理行更改 (E 正确)。\nG) 二进制日志格式必须设置为`ROW` (`binlog_format=ROW`)。组复制依赖于基于行的复制格式来确保数据在所有成员之间的一致性和确定性应用 (G 正确)。\n\n错误选项分析：\nA) 复制过滤器：通常不建议在组复制成员之间使用复制过滤器，因为这可能导致数据不一致。所有成员应该有相同的数据集。\nB) 半同步复制插件：组复制是MySQL原生的高可用和数据一致性解决方案，它有自己的同步和共识机制，不依赖于传统的半同步复制插件。\nD) 二进制日志校验和 (`binlog_checksum`)：虽然启用校验和是一个好的实践，可以帮助检测数据损坏，但它不是组复制的强制要求。组复制有其自身的机制来确保数据传输的完整性。\nF) 二进制日志`MIXED`格式：组复制强制要求使用`ROW`格式，不支持`STATEMENT`或`MIXED`格式。\n\n**考点总结:**\n此题考察MySQL组复制的关键配置要求。这些要求是为了保证组复制的正确运行、数据一致性和故障恢复能力。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住组复制的几个核心要求：ROW格式的binlog，所有表有主键（或等效），以及启用`log_slave_updates`。这些是确保数据一致性和分布式协调的基础。\n\n**学习建议:**\n详细阅读MySQL官方文档中关于组复制的章节，特别是其“要求和限制”部分。了解每个要求背后的原因。进行组复制的实验部署，熟悉配置过程和常见问题排查。"
    },
    {
        "question": "### 试题 43:\n\nYou are attempting to start your mysqld. Examine this log output:\n```\n2019-12-12T22:21:40.353800Z 0 [System] [MY-010116] [Server] /mysql/bin/mysqld (mysqld 8.0.18-commercial) starting as process 29740\n2019-12-12T22:21:40.458802Z 1 [ERROR] [MY-012592] [InnoDB] Operating system error number 2 in a file operation.\n2019-12-12T22:21:40.459259Z 1 [ERROR] [MY-012593] [InnoDB] The error means the system cannot find the path specified.\n2019-12-12T22:21:40.459423Z 1 [ERROR] [MY-012594] [InnoDB] If you are installing InnoDB, remember that you must create directories yourself, InnoDB does not create them.\n2019-12-12T22:21:40.459606Z 1 [ERROR] [MY-012646] [InnoDB] File ./ibdata1: 'open' returned os error 71. Cannot continue operation.\n2019-12-12T22:21:40.459891Z 1 [ERROR] [MY-012981] [InnoDB] Cannot continue operation.\n```\nWhich two things must you check?",
        "selections": {
            "A": "the configuration file for correct datadir setting",
            "B": "that you are using the correct version of MySQL",
            "C": "that the TLS/SSL certificates are still valid",
            "D": "for the possibility that the files are locked by another process",
            "E": "for the presence of the missing files in other locations",
            "F": "that the user attempting to connect to the database is using the correct username and password"
        },
        "answers": [
            "A",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n错误日志的关键信息：\n- `Operating system error number 2`: 这通常对应 'No such file or directory' (ENOENT)。\n- `The error means the system cannot find the path specified.`\n- `File ./ibdata1: 'open' returned os error 71. Cannot continue operation.` (OS error 71也可能与路径或文件访问问题相关，具体含义可能因OS而异，但结合前文的error 2，路径问题是主要嫌疑)。\n- `If you are installing InnoDB, remember that you must create directories yourself...`\n\n这些错误强烈指向MySQL服务器在启动时无法找到其数据目录或数据目录中的关键文件（如`ibdata1`）。\n\nA) 检查配置文件（如`my.cnf`）中`datadir`的设置是否正确。如果`datadir`指向了一个不存在的路径，或者MySQL进程没有权限访问该路径，就会出现这类错误 (A 正确)。\nE) 检查缺失的文件（如`ibdata1`）是否存在于其他位置，或者数据目录是否确实为空或不完整。如果`datadir`设置正确，但关键文件丢失或不在预期路径下（例如，`./ibdata1`相对于`datadir`），也会导致启动失败 (E 正确)。\n\n错误选项分析：\nB) 错误日志明确显示MySQL版本为8.0.18。版本问题本身不直接导致“找不到路径”的错误，除非配置文件或数据文件与该版本不兼容（但这通常会有更具体的错误信息）。\nC) TLS/SSL证书问题通常会在尝试建立加密连接时出现，或在服务器启动时加载证书阶段报错，与找不到`ibdata1`或路径的错误类型不同。\nD) 文件被其他进程锁定通常会导致“Permission denied”或“File in use”之类的错误，而不是“No such file or directory”。\nF) 这是客户端连接数据库时的问题，与服务器启动失败无关。\n\n**考点总结:**\n此题考察根据MySQL错误日志诊断启动失败原因的能力。核心在于识别操作系统错误码的含义，并将其与MySQL的配置（特别是`datadir`）和文件系统状态联系起来。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细阅读错误日志中的每一条信息，特别是`[ERROR]`级别的。关注操作系统错误码（如error 2）和MySQL自身的错误描述。将错误信息与可能的配置问题或文件系统问题关联起来。\n\n**学习建议:**\n熟悉MySQL服务器启动过程和常见的启动失败原因。学习如何解读MySQL错误日志。了解`datadir`参数的重要性及其在配置文件中的设置。掌握基本的Linux文件系统命令（如`ls`, `pwd`, `df`, `mount`）以帮助排查路径和权限问题。"
    },
    {
        "question": "### 试题 44:\n\nWhich three requirements must be enabled for group replication?",
        "selections": {
            "A": "primary key or primary key equivalent on every table",
            "B": "semi-sync replication plugin",
            "C": "binary log ROW format",
            "D": "binary log MIXED format",
            "E": "replication filters",
            "F": "binary log checksum",
            "G": "slave updates logging"
        },
        "answers": [
            "A",
            "C",
            "G"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题42内容几乎完全相同，只是选项顺序可能不同。\nA) 所有表必须有主键或等效的非空唯一键 (A 正确)。\nC) 二进制日志格式必须为`ROW` (C 正确)。\nG) `log_slave_updates` (或 `log_replica_updates`) 必须启用 (G 正确)。\n\n错误选项分析同试题42。\n\n**考点总结:**\n再次强调MySQL组复制的核心配置要求，这些是保证其功能和数据一致性的基础。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复的考点更应牢记。组复制的这三个核心要求（ROW格式binlog, 表主键, `log_slave_updates`）非常重要。\n\n**学习建议:**\n参考试题42的学习建议。对核心概念和要求的反复巩固有助于加深记忆。"
    },
    {
        "question": "### 试题 45:\n\nChoose two. Which two statements are true about raw binary backups?",
        "selections": {
            "A": "They are converted to a highly compressible binary format.",
            "B": "They are required to obtain FIPS security compliance.",
            "C": "The resulting files are easily human readable.",
            "D": "The data format is identical to how MySQL stores the data on disk.",
            "E": "They are faster than logical backups because the process is a simple file or file system copy."
        },
        "answers": [
            "D",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n“原始二进制备份”（Raw binary backups）通常指物理备份，即直接复制MySQL数据文件。\nD) 数据格式与MySQL在磁盘上存储数据的格式相同。物理备份直接拷贝数据文件（如`.ibd`, `.MYD`, `.MYI`文件）和日志文件，这些文件的内部格式就是MySQL原生的存储格式 (D 正确)。\nE) 物理备份通常比逻辑备份（如`mysqldump`）快，特别是在数据量很大时。因为物理备份是文件系统级别的复制，避免了SQL解析、数据转换和重新生成SQL语句的开销 (E 正确)。\n\n错误选项分析：\nA) 物理备份是直接复制原始文件，不会自动“转换”为其他高度可压缩的二进制格式。压缩可以在复制之后作为单独步骤进行，或者某些备份工具可能内置压缩功能，但“转换格式”不是物理备份的固有属性。\nB) FIPS安全合规性是一个广泛的标准，涉及加密、密钥管理等多个方面。备份方法本身（物理或逻辑）不直接决定是否满足FIPS合规，而是备份过程中的安全措施（如加密备份数据、安全存储密钥等）以及所用工具是否经过FIPS认证等因素共同决定。\nC) 物理备份的结果是二进制数据文件，它们不是人类可读的。逻辑备份（如`mysqldump`产生的SQL文件）才是人类可读的。\n\n**考点总结:**\n此题考察对物理备份（原始二进制备份）基本特性的理解。关键在于其直接复制磁盘数据格式，并且通常比逻辑备份速度快。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分物理备份和逻辑备份的核心差异。物理备份操作的是文件系统层面的数据文件，逻辑备份操作的是SQL层面的数据表示。\n\n**学习建议:**\n学习MySQL的各种备份恢复方法，包括逻辑备份（`mysqldump`, `mysqlpump`, `SELECT ... INTO OUTFILE`）、物理备份（冷备份直接拷贝文件、热备份工具如MySQL Enterprise Backup/Percona XtraBackup、文件系统快照）。理解它们各自的优缺点、适用场景、备份速度、恢复速度、一致性保证以及对服务器负载的影响。"
    },
    {
        "question": "### 试题 46:\n\nChoose two. Which two methods can be used to determine whether a query uses the hash join algorithm?\n",
        "selections": {
            "A": "EXPLAIN FORMAT=JSON",
            "B": "EXPLAIN FORMAT=TRADITIONAL",
            "C": "EXPLAIN FORMAT=TREE",
            "D": "EXPLAIN without any formatting argument",
            "E": "EXPLAIN ANALYZE"
        },
        "answers": [
            "A",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL从8.0.18版本开始引入哈希连接（Hash Join）。要查看查询是否使用了哈希连接，需要检查`EXPLAIN`的输出。\nA) `EXPLAIN FORMAT=JSON`：JSON格式的`EXPLAIN`输出提供了非常详细的执行计划信息。如果使用了哈希连接，会在JSON结构中明确标识出哈希连接操作及其相关的细节（如构建端、探测端、哈希条件等） (A 正确)。\nE) `EXPLAIN ANALYZE`：这个命令（从MySQL 8.0.18开始支持，并且在8.0.20中改进）不仅显示估计的执行计划，还会实际执行查询并显示实际的执行统计信息，包括时间、行数等。在其输出中，如果使用了哈希连接，会清晰地显示哈希连接操作以及相关的性能数据 (E 正确)。\n\n错误或不那么直接的选项分析：\nB) `EXPLAIN FORMAT=TRADITIONAL` (或默认的表格格式，即D选项)：传统的表格格式`EXPLAIN`输出可能不那么直接地显示哈希连接。虽然在`Extra`列或其他地方可能通过特定文本（如 `Using join buffer (Hash Join)` 或类似）间接提示，但JSON和ANALYZE格式更为明确和详细。\nC) `EXPLAIN FORMAT=TREE`：树形格式的`EXPLAIN`输出（从MySQL 8.0.16开始提供）比传统表格格式更易读，并且能够显示操作的层级关系。它应该也能显示哈希连接，但JSON和ANALYZE通常提供更全面的信息，特别是ANALYZE还包含实际执行数据。\nD) `EXPLAIN`（不带`FORMAT`参数）：默认使用表格格式，如B所述。\n\n**考点总结:**\n此题考察如何通过`EXPLAIN`命令来识别MySQL查询是否使用了哈希连接算法。`FORMAT=JSON`和`EXPLAIN ANALYZE`是查看详细执行计划并确认哈希连接使用的最有效方法。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n当需要获取最详细或特定格式的执行计划信息时，优先考虑`EXPLAIN`的`FORMAT`子句和`ANALYZE`选项。哈希连接是较新的特性，其信息在更现代的`EXPLAIN`输出格式中更为突出。\n\n**学习建议:**\n学习MySQL 8.0中引入的哈希连接算法，了解其工作原理、适用场景（特别是等值连接且无合适索引时）以及如何通过`EXPLAIN`（特别是`FORMAT=JSON`和`EXPLAIN ANALYZE`）来观察和分析。掌握不同`EXPLAIN`输出格式的优缺点。"
    },
    {
        "question": "### 试题 47:\n\nChoose two. You have an InnoDB Cluster configured with three servers. Examine this command, which executes successfully: `mysqldump -uroot -p -d mydatabase > mydatabase_backup.sql`\nDue to data loss, the cluster is initialized and a restore is attempted resulting in this error:\n`ERROR 13176 (HY000) at line 23: Cannot update GTID_PURGED with the Group Replication plugin running`\nWhich two actions, either one of which, can fix this error and allow a successful restore of the cluster?",
        "selections": {
            "A": "Remove the group replication plugin from each instance before restoring.",
            "B": "Remove the `@@GLOBAL.gtid_executed` statement from the dump file.",
            "C": "Stop all instances except the primary read/write master instance and run the restore.",
            "D": "Restore using the `--set-gtid-purged=OFF` option.",
            "E": "Remove the `@@GLOBAL.gtid_purged` statement from the dump file.",
            "F": "Create the backup by using the `--set-gtid-purged=OFF` option."
        },
        "answers": [
            "E",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n错误信息 `Cannot update GTID_PURGED with the Group Replication plugin running` 表明在尝试恢复备份（其中可能包含`SET @@GLOBAL.GTID_PURGED`语句）时，由于组复制插件正在运行，不允许直接修改`GTID_PURGED`。组复制有其自身的GTID管理机制。\n该备份命令 `mysqldump -uroot -p -d mydatabase ...` 中 `-d` 选项表示 `--no-data`，即只导出数据库结构，不导出数据。然而，即使是结构导出，如果GTID已启用，`mysqldump`默认会包含`SET @@SESSION.SQL_LOG_BIN=0;`和`SET @@GLOBAL.GTID_PURGED=...;`（或类似语句）。\n\n要解决这个问题，可以在备份或恢复时处理`GTID_PURGED`的设置：\nE) 从dump文件中移除`SET @@GLOBAL.gtid_purged=...;`（或类似的）语句。这样在恢复时就不会尝试修改这个全局变量，避免与组复制插件冲突 (E 正确)。\nF) 在创建备份时使用`--set-gtid-purged=OFF`选项。这个`mysqldump`选项会阻止在dump文件中输出`SET @@GLOBAL.GTID_PURGED`语句。这样产生的备份文件在恢复时就不会有这个冲突 (F 正确)。\n\n错误选项分析：\nA) 移除组复制插件是一个比较激进的措施，通常不是解决此类问题的首选。而且恢复后还需要重新配置组复制。\nB) dump文件中通常是`GTID_PURGED`，而不是`GTID_EXECUTED`。`GTID_EXECUTED`是服务器当前已执行的GTID集合，通常不应手动从备份中移除或修改。\nC) 即使只在主节点上恢复，只要组复制插件在运行，直接修改`GTID_PURGED`的问题仍然存在。\nD) `mysqldump`（用于备份）有`--set-gtid-purged`选项。`mysql`客户端（用于恢复）没有这个选项来控制导入行为。恢复时是通过执行dump文件中的SQL语句。\n\n**考点总结:**\n此题考察在启用了组复制和GTID的环境下，使用`mysqldump`进行备份和恢复时可能遇到的`GTID_PURGED`冲突问题，以及如何通过`mysqldump`选项或修改dump文件来解决。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n当看到GTID相关的错误，并且涉及到组复制时，要考虑它们之间的交互和限制。`GTID_PURGED`的设置是关键点。\n\n**学习建议:**\n学习在启用GTID的环境下如何正确使用`mysqldump`进行备份和恢复。掌握`--set-gtid-purged`选项（`AUTO`, `ON`, `OFF`）的含义和使用场景。了解组复制环境对GTID管理的特殊要求。熟悉在恢复数据到InnoDB集群（特别是初始化或重建后）时的最佳实践。"
    },
    {
        "question": "### 试题 48:\n\nChoose three. Which three are types of InnoDB tablespaces?",
        "selections": {
            "A": "data tablespaces",
            "B": "schema tablespaces",
            "C": "redo tablespaces",
            "D": "temporary table tablespaces",
            "E": "undo tablespaces",
            "F": "encryption tablespaces"
        },
        "answers": [
            "A",
            "D",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nInnoDB存储引擎管理多种类型的表空间来存储不同种类的数据和元数据。\nA) 数据表空间 (Data tablespaces)：这是最常见的类型，用于存储用户表和索引的数据。包括系统表空间（`ibdata1`）、独立表空间（file-per-table, `.ibd`文件）和通用表空间 (A 正确)。\nD) 临时表表空间 (Temporary table tablespaces)：用于存储用户创建的临时表和优化器在处理复杂查询时内部使用的磁盘临时表。可以是共享的临时表空间或（从MySQL 8.0.16开始）每个会话的临时表空间 (D 正确)。\nE) Undo表空间 (Undo tablespaces)：用于存储undo日志，这些日志是事务回滚和MVCC所必需的。从MySQL 5.7开始，undo日志可以配置为存储在独立的undo表空间中，而不是系统表空间 (E 正确)。\n\n错误选项分析：\nB) “Schema tablespaces”：模式（数据库）本身不是一个表空间类型。表空间是存储表和索引等对象的容器。一个模式下的表可以存储在不同类型的表空间中。\nC) “Redo tablespaces”：InnoDB有redo日志文件（`ib_logfile*`），它们对事务持久性和崩溃恢复至关重要。但通常不把它们称为“redo表空间”。它们是特定格式的日志文件，有自己的管理方式。\nF) “Encryption tablespaces”：加密是应用于数据表空间（如独立表空间或通用表空间）的一个属性或特性，而不是一种独立的表空间类型。加密的表空间仍然是数据表空间。\n\n**考点总结:**\n此题考察对InnoDB不同表空间类型的识别。核心包括存储实际数据的表空间、存储临时数据的表空间和存储undo日志的表空间。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n回忆InnoDB存储架构的组成部分。思考不同类型的数据（用户数据、临时数据、事务恢复数据）是如何存储的。\n\n**学习建议:**\n详细学习InnoDB的存储结构，包括：\n1.  系统表空间（System Tablespace）：存储数据字典、双写缓冲、修改缓冲、undo日志（旧版本）以及用户表和索引（如果`innodb_file_per_table=OFF`）。\n2.  独立表空间（File-per-table Tablespaces）：每个表的数据和索引存储在各自的`.ibd`文件中。\n3.  通用表空间（General Tablespaces）：可以存储多个表的共享表空间。\n4.  Undo表空间（Undo Tablespaces）：专门用于存储undo日志。\n5.  临时表空间（Temporary Tablespaces）：用于存储临时表和内部临时磁盘表。\n了解每种表空间的用途、配置和管理。"
    },
    {
        "question": "### 试题 49:\n\nChoose two. Examine this statement and output:\n```sql\nmysql> SELECT ROW_NUMBER() OVER() AS QN, query, exec_count, avg_latency, lock_latency FROM sys.statement_analysis ORDER BY exec_count DESC;\n\n```\n| QN | query                                                              | exec_count | avg_latency | lock_latency |\n|----|--------------------------------------------------------------------|------------|-------------|--------------|\n| 1  | SELECT SUM (`k`) FROM `mysch` ... INTERVAL ? SOL_TSI_HOUR          | 381268     | 31.44 ms    | 30.06 s      |\n| 2  | SELECT `id`, `val`, ... `updated` WHERE `created` < ?              | 150317     | 358.34 us   | 1.01 ms      |\n| 3  | SELECT `emp_no`, 'val', `created` + INTERVAL ? SOL_TSI_DAY         | 600        | 523.32 ms   | 120.24 ms    |\n| 4  | SELECT `a`, `b`, 'c' FROM 'm' ... ? AND ? OR 'k' BETWEEN ? AND ? | 200        | 10.32 s     | 40.19 ms     |\n| 5  | SELECT `a`, `b` FROM `myschem` ... G(`emp_no`) WHERE `val` = ?     | 1          | 21.03 s     | 274.00 us    |\n\nYou must try to reduce query execution time. Which two queries should you focus on?",
        "selections": {
            "A": "QN=2",
            "B": "QN=3",
            "C": "QN=4",
            "D": "QN=1",
            "E": "QN=5"
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n目标是减少查询执行时间。我们应该关注那些总执行时间（`exec_count * avg_latency`）较高，或者单次执行时间（`avg_latency`）非常高的查询。\n- QN=1: 执行次数非常高 (381268)，但平均延迟相对较低 (31.44 ms)。总时间 ≈ 381268 * 0.03144 s ≈ 11990 s。\n- QN=2: 执行次数较高 (150317)，平均延迟非常低 (358.34 us)。总时间 ≈ 150317 * 0.00035834 s ≈ 54 s。\n- QN=3: 执行次数中等 (600)，平均延迟中等 (523.32 ms)。总时间 ≈ 600 * 0.52332 s ≈ 314 s。\n- QN=4: 执行次数较低 (200)，但平均延迟非常高 (10.32 s)。总时间 ≈ 200 * 10.32 s ≈ 2064 s。\n- QN=5: 执行次数最低 (1)，但平均延迟最高 (21.03 s)。总时间 ≈ 1 * 21.03 s ≈ 21 s。\n\n要“减少查询执行时间”，我们应该优先关注那些单次执行就很慢的查询，因为优化它们可以带来立竿见影的单次性能提升，也可能对总时间有显著影响。\nC) QN=4: 平均延迟高达10.32秒，即使执行次数不多，优化它对单次用户体验和潜在的累积影响都很大 (C 正确)。\nE) QN=5: 平均延迟是所有查询中最高的，达到21.03秒。虽然只执行了一次，但这么高的延迟表明查询本身存在严重性能问题，优化潜力巨大 (E 正确)。\n\nQN=1虽然总时间最长，但因为其执行次数极高，优化它可能需要更细致的分析，而且单次优化的效果可能不那么“显著”（例如，从31ms降到25ms）。而QN=4和QN=5的单次延迟非常突出，是明显的优化目标。\n\n**考点总结:**\n此题考察如何根据`sys.statement_analysis`（或类似性能视图）的输出来识别需要优化的查询。通常关注两个指标：单次平均延迟 (`avg_latency`) 和总执行时间 (`exec_count * avg_latency`)。高`avg_latency`的查询通常是首要优化目标。\n\n**OCR中的解析“看 avg_latency, 执行次数多的sql语句已经没有优化的空间了”是不准确的。** 执行次数多的SQL如果`avg_latency`仍然较高，或者其总执行时间占比巨大，仍然是重要的优化对象。只是说，如果它的`avg_latency`已经非常低了，再优化的空间可能有限。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n分析性能数据时，要综合考虑执行频率和单次耗时。对于用户体验而言，单次响应时间长的查询通常更需要关注。对于系统总负载而言，总耗时长的查询更重要。题目说“减少查询执行时间”，可以理解为减少单次执行时间，也可以是减少总体消耗。优先选择那些`avg_latency`异常高的查询。\n\n**学习建议:**\n学习使用MySQL的`sys` schema中的性能分析视图，如`statement_analysis`, `statements_with_full_table_scans`, `statements_with_sorting`等。了解这些视图中各个列的含义（如`exec_count`, `avg_latency`, `lock_latency`, `rows_sent`, `rows_examined`等）。掌握如何根据这些数据来定位慢查询和高负载查询，并结合`EXPLAIN`进行进一步分析和优化。"
    },
    {
        "question": "### 试题 50:\n\nYou are asked to review possible options for a new MySQL instance. It will be a large, busy reporting data warehousing instance. The `innodb_data_file_path` setting needs to be configured. Which two configurations would satisfy long-term storage demands?",
        "selections": {
            "A": "ibdata1:12M:autoextend",
            "B": "ibdata1:12M;ibdata2:12M:autoextend",
            "C": "ibdata1:12M;ibdata2:12M;ibdata3:12M",
            "D": "ibdata1:12M;/tmp/ibdata2:12M:autoextend",
            "E": "ibdata1:12M",
            "F": "ibdata1:12M:autoextend;ibdata2:12M:autoextend"
        },
        "answers": [
            "A",
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`innodb_data_file_path` 用于配置InnoDB系统表空间的数据文件。对于长期存储需求，特别是数据仓库这种可能持续增长的场景，配置数据文件能够自动扩展是重要的。\n- `autoextend` 属性允许最后一个指定的数据文件在空间不足时自动增长。\n\nA) `ibdata1:12M:autoextend`：定义一个名为`ibdata1`的数据文件，初始大小12MB，并且可以自动扩展。这是满足长期存储需求的有效配置 (A 正确)。\nB) `ibdata1:12M;ibdata2:12M:autoextend`：定义两个数据文件，`ibdata1`初始大小12MB（不可自动扩展），`ibdata2`初始大小12MB，并且可以自动扩展。由于最后一个文件`ibdata2`可以自动扩展，这也满足了长期存储需求 (B 正确)。\n\n错误选项分析：\nC) `ibdata1:12M;ibdata2:12M;ibdata3:12M`：定义了三个固定大小的数据文件，没有一个可以自动扩展。这不适合长期存储和数据增长的需求。\nD) `ibdata1:12M;/tmp/ibdata2:12M:autoextend`：将第二个数据文件放在`/tmp`目录下是不明智的，因为`/tmp`目录中的数据通常在系统重启后会丢失。而且，只有最后一个数据文件才能指定`autoextend`。\nE) `ibdata1:12M`：定义了一个固定大小12MB的数据文件，不可自动扩展，不满足长期存储需求。\nF) `ibdata1:12M:autoextend;ibdata2:12M:autoextend`：`autoextend`属性只能应用于`innodb_data_file_path`中定义的最后一个数据文件。此配置语法错误。\n\n**考点总结:**\n此题考察对InnoDB系统表空间配置参数`innodb_data_file_path`的理解，特别是`autoextend`属性的使用规则。为了满足长期存储需求，至少最后一个数据文件应该配置为可自动扩展。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住`autoextend`只能用于`innodb_data_file_path`中指定的最后一个数据文件。对于需要增长的系统，自动扩展是必要的。避免将关键数据文件放在临时目录。\n\n**学习建议:**\n学习InnoDB系统表空间的配置和管理。理解`innodb_data_file_path`参数的语法和各个部分的含义（文件名、初始大小、`autoextend`、最大大小等）。了解何时需要配置多个数据文件以及如何规划系统表空间的大小。同时，也要了解`innodb_file_per_table`和通用表空间等其他表空间管理方式，它们在现代MySQL中更常用，可以避免系统表空间过度膨胀。"
    },
    {
        "question": "### 试题 51:\n\nChoose two. An existing asynchronous replication setup is running MySQL 8.\n\n Which two steps are a part of implementing GTID replication?",
        "selections": {
            "A": "Enable GTID by executing this on the master and the slave: SET GLOBAL GTID_ENABLED=on;",
            "B": "On the slave, alter the MySQL master connection setting with: ALTER channel CHANGE MASTER TO MASTER_AUTO_POSITION = 1;",
            "C": "Execute this on the slave to enable GTID: RESET SLAVE; START SLAVE GTID_NEXT=AUTOMATIC;",
            "D": "Execute this on the slave to enable GTID: START SLAVE IO_THREAD WITH GTID;",
            "E": "Restart MySQL (master and slave) with these options enabled: --gtid_mode=ON --log-bin --log-slave-updates --enforce-gtid-consistency",
            "F": "On the slave, alter the MySQL master connection setting with: CHANGE MASTER TO MASTER_AUTO_POSITION = 1;"
        },
        "answers": [
            "E",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n从传统的基于二进制日志文件和位置的复制迁移到基于GTID的复制，通常涉及以下步骤（简化流程）：\n1.  在所有服务器（主库和从库）上启用GTID模式并强制GTID一致性。这通常需要在`my.cnf`中配置相关参数并重启服务器。\n2.  在从库上，将其配置为使用`MASTER_AUTO_POSITION = 1`，这样从库就会自动根据GTID来确定从主库的哪个事务开始复制。\n\nE) 在主库和从库的配置文件中启用`gtid_mode=ON`和`enforce_gtid_consistency=ON`，并确保`log_bin`和`log_slave_updates`（或`log_replica_updates`）也已启用，然后重启MySQL服务。这是启用GTID模式的基础步骤 (E 正确)。\nF) 在从库上，执行`CHANGE MASTER TO MASTER_AUTO_POSITION = 1;`（对于单源复制）或 `CHANGE REPLICATION SOURCE TO SOURCE_AUTO_POSITION = 1;`（对于多源复制，MySQL 8.0.23+）。这告诉从库使用GTID自动定位复制点 (F 正确)。\n\n错误选项分析：\nA) `GTID_ENABLED`不是一个有效的全局变量。启用GTID是通过`gtid_mode`和`enforce_gtid_consistency`参数在配置文件中设置并重启服务器。\nB) `ALTER channel CHANGE MASTER TO ...` 语法不正确。应该是 `CHANGE MASTER TO ...` (针对默认复制通道) 或 `CHANGE REPLICATION SOURCE TO ... FOR CHANNEL 'channel_name'` (针对特定复制通道)。\nC) `GTID_NEXT=AUTOMATIC` 是在会话级别控制GTID行为的，不直接用于启用全局GTID复制。`RESET SLAVE`会清除复制信息，但启用GTID的核心在于服务器配置和`MASTER_AUTO_POSITION`。\nD) `START SLAVE IO_THREAD WITH GTID;` 这种语法不存在。启动从库线程使用 `START SLAVE;` 或 `START REPLICA;`。\n\n**考点总结:**\n此题考察从传统复制迁移到GTID复制的关键步骤。核心在于服务器端启用GTID模式和一致性，以及在从库端配置为使用自动GTID定位。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分服务器级别的GTID配置（通过`my.cnf`和重启）和从库连接配置（通过`CHANGE MASTER TO`）。记住`MASTER_AUTO_POSITION = 1`是GTID复制的关键设置。\n\n**学习建议:**\n详细学习MySQL GTID（全局事务标识符）的概念、优点以及如何部署和管理GTID复制。掌握从基于文件和位置的复制在线或离线迁移到GTID复制的完整步骤。了解`gtid_mode`, `enforce_gtid_consistency`, `MASTER_AUTO_POSITION`等关键参数的作用。熟悉相关的监控和故障排除。"
    },
    {
        "question": "### 试题 52:\n\nChoose two. You plan to install MySQL Server by using the RPM download. Which two statements are true?",
        "selections": {
            "A": "You must manually initialize the data directory.",
            "B": "You can provide the root password interactively.",
            "C": "The MySQL RPM package installation supports deploying multiple MySQL versions on the same host.",
            "D": "MySQL uses the RPM relocatable installation target feature.",
            "E": "You can find the root password in the error log after the first start.",
            "F": "The functionality is split among several RPM package files."
        },
        "answers": [
            "E",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n通过RPM包安装MySQL时的一些特性：\nE) 在首次启动通过RPM安装的MySQL服务器后（特别是较新版本如MySQL 5.7+和8.0），一个临时的root用户密码通常会自动生成并记录在MySQL的错误日志文件中。用户需要从错误日志中找到这个临时密码，然后用它登录并设置新的root密码 (E 正确)。\nF) MySQL的RPM安装通常由多个包组成，例如核心服务器包 (`mysql-community-server`)、客户端工具包 (`mysql-community-client`)、共享库 (`mysql-community-libs`)、开发文件 (`mysql-community-devel`)等。这种模块化的包结构允许用户根据需要安装不同的组件 (F 正确)。\n\n错误选项分析：\nA) 通过RPM包安装MySQL时，安装过程通常会自动处理数据目录的初始化（例如，执行`mysqld --initialize`或类似操作）。用户一般不需要手动初始化。\nB) RPM安装过程通常不会提供交互式设置root密码的环节。密码是自动生成（如E所述）或在某些自动化部署场景下通过预配置方式设置。\nC) 标准的MySQL RPM包（如来自Oracle官方的`mysql-community-*`系列）通常不支持在同一主机上轻松部署多个MySQL版本。要实现多版本共存，可能需要使用特殊的RPM包（如SCL - Software Collections）或手动进行复杂配置。\nD) MySQL的官方RPM包通常安装到固定的标准路径（如`/usr/sbin/mysqld`, `/var/lib/mysql`等），不广泛使用RPM的“可重定位安装”特性允许用户随意指定安装目标。\n\n**考点总结:**\n此题考察通过RPM包安装MySQL的一些常见行为和特性，特别是初始密码的获取和包的模块化结构。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n了解通过不同方式（RPM, DEB, tarball, 源码）安装MySQL的异同点。特别是RPM安装的自动化程度和初始设置流程。\n\n**学习建议:**\n实际操作一次通过官方RPM包安装MySQL的过程。注意安装后如何找到初始root密码，以及如何进行首次安全配置（如运行`mysql_secure_installation`脚本）。熟悉MySQL RPM包的命名约定和不同组件包的作用。"
    },
    {
        "question": "### 试题 53:\n\nChoose four. Which four connection methods can MySQL clients specify with the `--protocol` option when connecting to a MySQL server?",
        "selections": {
            "A": "IPv4",
            "B": "SOCKET",
            "C": "MEMORY",
            "D": "PIPE",
            "E": "IPv6",
            "F": "FILE",
            "G": "TCP",
            "H": "DIRECT"
        },
        "answers": [
            "B",
            "C",
            "D",
            "G"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL客户端的`--protocol`选项用于指定连接到服务器时使用的连接协议。\nB) `SOCKET`：在类Unix系统上，用于通过Unix域套接字文件进行本地连接 (B 正确)。\nC) `MEMORY`：用于通过共享内存进行本地连接（主要在Windows上，并且服务器也需要启用共享内存连接） (C 正确)。\nD) `PIPE`：用于通过命名管道进行本地连接（主要在Windows上） (D 正确)。\nG) `TCP`：用于通过TCP/IP网络进行连接，可以是本地连接（连接到`127.0.0.1`或`localhost`）或远程连接 (G 正确)。\n\n错误选项分析：\nA) `IPv4`：这不是`--protocol`的一个值。TCP/IP连接可以使用IPv4或IPv6地址，但这由主机名解析或直接指定的IP地址决定，而不是由`--protocol=IPv4`指定。\nE) `IPv6`：同A，不是`--protocol`的值。\nF) `FILE`：没有名为`FILE`的连接协议。\nH) `DIRECT`：没有名为`DIRECT`的连接协议。\n\n**考点总结:**\n此题考察MySQL客户端支持的连接协议类型。核心是TCP/IP网络连接、Unix套接字（类Unix系统）、命名管道（Windows）和共享内存（Windows）。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住MySQL客户端常用的几种连接方式及其对应的`--protocol`值。注意区分协议类型和网络地址类型（IPv4/IPv6）。\n\n**学习建议:**\n学习MySQL的网络连接配置和客户端连接选项。了解不同操作系统平台上支持的本地连接方式（如Unix套接字、命名管道、共享内存）以及它们与TCP/IP网络连接的区别。熟悉`mysql`命令行客户端的常用连接参数，如`--host`, `--port`, `--user`, `--password`, `--protocol`, `--socket`, `--pipe`, `--shared-memory-base-name`等。"
    },
    {
        "question": "### 试题 54:\n\nYou have a MySQL client installed on your Linux workstation with a default installation. You have your admin login credentials to connect to a MySQL server running Microsoft Windows on remote host `192.0.2.1:3306` to connect to the `world` database. Which four options need to be specified to complete this task with a single command?",
        "selections": {
            "A": "--port=3306",
            "B": "--protocol=pipe",
            "C": "--host=192.0.2.1",
            "D": "--protocol=UDP",
            "E": "--user=admin",
            "F": "--password",
            "G": "--socket=/tmp/mysql.sock",
            "H": "--shared-memory-base-name=world",
            "I": "--database=world"
        },
        "answers": [
            "C",
            "E",
            "F",
            "I"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n要通过`mysql`命令行客户端连接到远程MySQL服务器并指定数据库，通常需要以下参数：\n- 主机名或IP地址 (`--host` 或 `-h`)\n- 用户名 (`--user` 或 `-u`)\n- 密码 (可以通过`--password` 或 `-p`提示输入，或直接`--password=your_pass`但不推荐)\n- 要连接的数据库名 (可以直接在命令末尾指定，或使用`--database` 或 `-D`)\n- 端口号 (`--port` 或 `-P`) 如果不是默认的3306。\n\n根据题目描述：\n- 远程主机：`192.0.2.1`\n- 端口：`3306` (这是MySQL默认端口，如果客户端默认也用这个，则此选项不“必需”指定，但指定了更明确)\n- 数据库：`world`\n- 用户：`admin` (假设，题目说有admin登录凭据)\n- 密码：需要提供\n\nC) `--host=192.0.2.1`：指定远程服务器的IP地址 (C 正确)。\nE) `--user=admin`：指定登录用户名 (E 正确)。\nF) `--password` (或 `-p`): 提示用户输入密码。如果密码是命令行参数的一部分（不推荐），也算是一个“选项” (F 正确)。\nI) `--database=world` (或 `-D world` 或在命令最后写 `world`)：指定要连接的数据库 (I 正确)。\n\n错误或非必需选项分析：\nA) `--port=3306`：由于3306是默认端口，如果客户端也默认连接此端口，则此选项不是严格“必需”的，但指定无害。如果题目强调“最少必需选项”，则可能不算。但为了明确，它通常是好的实践。\nB) `--protocol=pipe`：命名管道是Windows本地连接方式，不适用于连接到远程Windows服务器（除非有特殊网络配置如SMB隧道等，但通常不用）。应使用TCP/IP。\nD) `--protocol=UDP`：MySQL不使用UDP进行标准客户端服务器连接。\nG) `--socket=/tmp/mysql.sock`：Unix套接字用于本地连接，不适用于连接到远程Windows服务器。\nH) `--shared-memory-base-name=world`：共享内存是Windows本地连接方式。\n\n**考点总结:**\n此题考察使用`mysql`命令行客户端连接远程服务器时所需的基本参数。核心是主机、用户、密码和数据库。\n\n**答案说明:** 若严格要求“必需”，且客户端默认端口是3306，则A选项可能不是绝对必需。但题目通常期望包含所有显式连接信息。C, E, F, I是最核心的四个。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n回忆连接MySQL所需的最基本信息：去哪里（主机/端口），我是谁（用户），怎么证明（密码），干什么（数据库）。区分本地连接和远程连接所需的参数。\n\n**学习建议:**\n熟练掌握`mysql`命令行客户端的常用选项及其简写形式。练习连接本地和远程MySQL服务器，并指定不同的参数。了解默认值（如默认端口3306）。注意密码在命令行上的安全处理（推荐使用`-p`提示输入，而不是直接写密码）。"
    },
    {
        "question": "### 试题 55:\n\nChoose three. Which three are characteristics of a newly created role?",
        "selections": {
            "A": "It is stored in the mysql.role table.",
            "B": "It can be dropped using the DROP ROLE statement.",
            "C": "It can be protected with a password.",
            "D": "It can be granted to user accounts.",
            "E": "It can be renamed using the RENAME ROLE statement.",
            "F": "It is created as a locked account."
        },
        "answers": [
            "B",
            "D",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL中的角色 (Role) 是一组权限的命名集合。\nB) 可以使用`DROP ROLE`语句删除一个已创建的角色 (B 正确)。\nD) 角色被创建后，可以像权限一样授予给用户账户（`GRANT role TO user;`）或授予给其他角色 (D 正确)。\nF) 根据MySQL文档，新创建的角色默认是“锁定的”（locked），这意味着即使角色被授予用户，如果该角色没有被设置为用户的默认角色或在会话中显式激活，用户也无法使用该角色包含的权限。但更准确地说，新创建的角色是空的，没有任何权限，并且没有密码。关于“locked account”的说法可能指角色本身不能直接登录，而是作为权限集合赋给用户。然而，在某些上下文中，也可能指角色创建后需要显式管理其激活状态。题目的“答案”提示“A role when created is locked, has no password.”，这暗示F是预期的答案之一，尽管“locked account”这个表述可能不完全精确，但它指向角色创建后的初始状态是受限的或需要进一步配置才能生效。\n\n错误选项分析：\nA) MySQL 8.0中，角色信息和其他元数据一样，存储在数据字典中。没有一个名为`mysql.role`的特定用户可见的表来存储角色。相关的系统表（如`mysql.user`可能间接涉及，或内部数据字典表）用于此目的。\nC) 角色本身不能直接用密码保护。密码是与用户账户关联的。角色是权限的集合。\nE) 可以使用`RENAME ROLE`语句重命名一个已创建的角色。所以这个陈述本身是正确的。但如果需要选三个“特征”，要看哪个更核心或更符合题目意图。如果F被认为是正确的话，B,D,F可能是最佳组合。\n\n**考点总结:**\n此题考察MySQL角色的基本特性和管理操作。核心在于角色是权限的容器，可以被授予、撤销、删除和重命名。\n\n**答案说明:** 结合OCR的答案提示 “A role when created is locked, has no password.”，可以推断出F选项被认为是正确的。那么，B, D, F是可能的三个答案。E选项（可重命名）也是角色的一个正确特征。如果必须三选，并且F成立，那么B,D,F是最符合“新创建角色”的特征，因为重命名是后续操作。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解角色的本质——权限的集合体。回忆与角色相关的SQL命令（`CREATE ROLE`, `DROP ROLE`, `GRANT role`, `REVOKE role`, `SET ROLE`, `SET DEFAULT ROLE`, `RENAME ROLE`）。\n\n**学习建议:**\n学习MySQL 8.0中引入的角色管理功能。掌握如何创建、管理和使用角色。理解角色与用户账户、权限之间的关系。了解角色激活（`SET ROLE`）和默认角色（`SET DEFAULT ROLE`）的概念。"
    },
    {
        "question": "### 试题 56:\n\nTable `t` is an InnoDB table. Examine these statements and output:\n```sql\nselect count(1) from t;\ncount(1) = 72\n\nmysql> show indexes from t \\G\n*************************** 1. row ***************************\n        Table: t\n   Non_unique: 0\n     Key_name: PRIMARY\n Seq_in_index: 1\n  Column_name: a\n    Collation: A\n  Cardinality: 72\n     Sub_part: NULL\n       Packed: NULL\n         Null:\n   Index_type: BTREE\n      Comment:\nIndex_comment:\n      Visible: YES\n   Expression: NULL\n*************************** 2. row ***************************\n        Table: t\n   Non_unique: 1\n     Key_name: b_idx\n Seq_in_index: 1\n  Column_name: b\n    Collation: A\n  Cardinality: 1\n     Sub_part: NULL\n       Packed: NULL\n         Null: YES\n   Index_type: BTREE\n      Comment:\nIndex_comment:\n      Visible: NO\n   Expression: NULL\n2 row in set (0.00 sec)\n```\nWhich two are true?",
        "selections": {
            "A": "ANALYZE TABLE t would update index statistics uniquely for the PRIMARY index.",
            "B": "Table t has two viable indexes to be used for queries.",
            "C": "SELECT b from t would perform a table scan.",
            "D": "Index b_idx has a low number of unique values.",
            "E": "SELECT a FROM t would perform a table scan."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n- 表`t`有一个主键在列`a`上，基数是72（与表行数相同），可见（Visible: YES）。\n- 表`t`有一个名为`b_idx`的索引在列`b`上，基数是1，不可见（Visible: NO）。不可见的索引不会被优化器用于查询。\n\nD) 索引`b_idx`的`Cardinality`（基数）为1，这意味着该索引列中只有1个唯一值。这确实是一个非常低的唯一值数量，表明该列的选择性很差 (D 正确)。\nC) 查询`SELECT b from t`：由于索引`b_idx`是`Visible: NO`（不可见），优化器不会使用它。因此，这个查询很可能会执行全表扫描来获取列`b`的值 (C 正确)。\n\n错误选项分析：\nA) `ANALYZE TABLE t`会更新表中所有索引的统计信息，而不仅仅是主键。它收集的统计信息（如基数）有助于优化器做出更好的查询计划选择。\nB) 表`t`只有一个可见的（即“可用的”）索引，那就是主键。索引`b_idx`是不可见的，因此优化器不会使用它来执行查询。所以说有两个“可用的”索引是错误的。\nE) 查询`SELECT a FROM t`：列`a`是主键。如果查询只是简单地选择主键列（`SELECT a FROM t`），并且没有`WHERE`子句或`ORDER BY`等，优化器可能会选择全表扫描或全索引扫描（如果主键是覆盖索引且比全表扫描更优）。但如果查询是`SELECT * FROM t WHERE a = value`，则会使用主键索引。题目中的简单`SELECT a FROM t`在某些情况下可能进行索引扫描（如果优化器认为比表扫描快），不一定总是表扫描。\n\n**考点总结:**\n此题考察对`SHOW INDEXES`输出的解读，特别是`Cardinality`和`Visible`字段的含义。基数反映索引的选择性，可见性决定优化器是否会使用该索引。不可见的索引对查询优化无效。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细阅读`SHOW INDEXES`输出的每一列。`Visible`列是MySQL 8.0引入的，非常重要。`Cardinality`与表总行数对比可以判断索引的选择性。\n\n**学习建议:**\n学习MySQL索引的创建、管理和监控。掌握`SHOW INDEXES`命令的输出格式和各字段含义。理解索引可见性（Visible/Invisible Indexes）的概念和用途（例如，在不影响查询的情况下测试移除索引的影响）。学习索引统计信息（如基数）如何影响查询优化器的决策。"
    },
    {
        "question": "### 试题 57:\n\nChoose two. Which two statements are true about the `mysqld-auto.cnf` file?",
        "selections": {
            "A": "It is always updated with changes to system variables.",
            "B": "This file is for logging purposes only and is never processed.",
            "C": "It is read and processed at the end of startup configuration.",
            "D": "This file is for storing MySQL Server configuration options in JSON format.",
            "E": "It is read and processed at the beginning of startup configuration.",
            "F": "This file is for storing MySQL server_uuid values only."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqld-auto.cnf`文件是MySQL 5.7引入的（并在8.0中继续使用），用于持久化通过`SET PERSIST`或`SET PERSIST_ONLY`命令设置的系统变量。\nD) 该文件以JSON格式存储配置选项 (D 正确)。\nC) 该文件在MySQL服务器启动时，在处理完所有其他选项文件（如`my.cnf`）和命令行参数之后被读取和处理。这意味着`mysqld-auto.cnf`中设置的变量会覆盖之前在其他地方设置的同名变量 (C 正确)。\n\n错误选项分析：\nA) 只有通过`SET PERSIST`或`SET PERSIST_ONLY`命令修改的系统变量才会被写入`mysqld-auto.cnf`。通过`SET GLOBAL`（不带`PERSIST`）修改的变量只在当前会话或服务器运行时有效，不会写入此文件。\nB) 该文件不是用于日志记录的，而是用于持久化配置。它在服务器启动时会被处理。\nE) 它是在启动配置的末尾被处理，而不是开头。\nF) `server_uuid`通常在`auto.cnf`文件（注意不是`mysqld-auto.cnf`）中生成和存储，该文件也在数据目录下，用于标识服务器实例。`mysqld-auto.cnf`用于存储用户通过`SET PERSIST`设置的变量。\n\n**考点总结:**\n此题考察对`mysqld-auto.cnf`文件作用、格式和处理时机的理解。核心在于它是`SET PERSIST`命令的后台存储，以JSON格式保存，并在启动配置的最后阶段加载。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分`SET GLOBAL`, `SET SESSION`, `SET PERSIST`, `SET PERSIST_ONLY`命令的作用和影响范围。记住`mysqld-auto.cnf`与`SET PERSIST`紧密相关，并且其加载优先级较高（覆盖其他配置）。\n\n**学习建议:**\n学习MySQL系统变量的设置和持久化机制。掌握`SET PERSIST`命令的使用方法和优点（无需手动编辑`my.cnf`并重启即可持久化配置）。了解MySQL服务器启动时选项文件的加载顺序和优先级。"
    },
    {
        "question": "### 试题 58:\n\nChoose two. Examine this command and output:\n```sql\nmysql> SELECT * FROM performance_schema.data_locks LIMIT 1\\G\n*************************** 1. row ***************************\n             ENGINE: INNODB\n    ENGINE_LOCK_ID: 1200:146\nENGINE_TRANSACTION_ID: 1200\n         THREAD_ID: 45\n          EVENT_ID: 11\n     OBJECT_SCHEMA: mydb\n       OBJECT_NAME: mytable1\n    PARTITION_NAME: NULL\nSUBPARTITION_NAME: NULL\n         INDEX_NAME: NULL\nOBJECT_INSTANCE_BEGIN: 118793337250203\n          LOCK_TYPE: RECORD\n          LOCK_MODE: X\n        LOCK_STATUS: GRANTED\n          LOCK_DATA: 1922,1922\n```\nWhich two statements are true?",
        "selections": {
            "A": "The lock is an exclusive lock.",
            "B": "The lock is a shared lock.",
            "C": "The lock is a row-level lock.",
            "D": "The lock is an intentional lock.",
            "E": "The lock is at the metadata object level.",
            "F": "The lock is at the table object level."
        },
        "answers": [
            "A",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n输出显示了从`performance_schema.data_locks`表中获取的一条锁信息。\n- `LOCK_TYPE: RECORD`：表示这是一个记录锁（record lock），即行级锁 (C 正确)。\n- `LOCK_MODE: X`：表示这是一个排他锁（Exclusive Lock） (A 正确)。\n\n错误选项分析：\nB) 锁模式是`X`（排他锁），不是`S`（共享锁）。\nD) 意向锁（Intentional Lock）的`LOCK_TYPE`通常是`TABLE`，并且`LOCK_MODE`会是`IX`, `IS`, `SIX`等。这里的`LOCK_TYPE`是`RECORD`。\nE) 元数据锁（Metadata Lock, MDL）与数据锁不同，通常在`performance_schema.metadata_locks`表中查看。这里的锁是数据锁。\nF) `LOCK_TYPE: RECORD`明确指出是记录锁（行级），而不是表级锁。表级锁的`LOCK_TYPE`会是`TABLE`。\n\n**考点总结:**\n此题考察对`performance_schema.data_locks`表中锁信息字段的解读能力，特别是`LOCK_TYPE`和`LOCK_MODE`的含义。这是诊断InnoDB锁问题的重要工具。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住InnoDB常见的锁类型（记录锁、间隙锁、临键锁、表锁、意向锁）及其在`performance_schema`中可能的表示。`LOCK_MODE`的`X`代表排他，`S`代表共享。\n\n**学习建议:**\n学习InnoDB的锁机制，包括不同类型的锁（共享锁/排他锁、记录锁/间隙锁/临键锁、意向锁、表锁）以及它们的作用和兼容性。熟悉如何使用`performance_schema`下的`data_locks`, `data_lock_waits`, `metadata_locks`等表来监控和诊断锁问题。了解`SHOW ENGINE INNODB STATUS`输出中关于锁的信息。"
    },
    {
        "question": "### 试题 59:\n\nChoose two. Your MySQL installation is running low on space due to binary logs. You need to reduce your log space usage urgently. Which two sets of actions when completed will accomplish this?",
        "selections": {
            "A": "Use SET PERSIST binlog_expire_logs_seconds=`value`.",
            "B": "Use SET GLOBAL binlog_expire_logs_seconds=`value` and restart the server.",
            "C": "Use PURGE BINARY LOGS TO `binlog_name`;",
            "D": "Set binlog_expire_logs_seconds in my.cnf.",
            "E": "Use SET GLOBAL binlog_expire_logs_seconds=`value` and run the FLUSH BINARY LOGS command.",
            "F": "Set binlog_expire_logs_seconds = 0 in my.cnf and restart the server."
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n要紧急减少二进制日志占用的空间，需要立即删除旧的日志文件，并可能配置自动清理策略。\nC) `PURGE BINARY LOGS TO '<binlog_name>';` 或 `PURGE BINARY LOGS BEFORE 'datetime_expression';`：这个命令会立即删除指定文件名之前（或指定时间之前）的所有二进制日志文件。这是最直接和紧急的清理方法 (C 正确)。\nE) `SET GLOBAL binlog_expire_logs_seconds=<value>;`（或`expire_logs_days`）用于设置二进制日志的自动过期时间。设置后，MySQL会定期检查并删除超过此时间的旧日志。单独设置此变量不会立即删除日志，但如果配合`FLUSH BINARY LOGS;`（或等待下一次自动轮转或检查），新的过期策略会生效，并且如果已有符合条件的旧日志，它们可能会被清理。`FLUSH BINARY LOGS;`本身会轮转日志，也可能触发清理检查（取决于具体实现和版本）。这是一个结合立即操作（轮转）和配置长效策略的方法 (E 正确，虽然“立即”效果主要靠`PURGE`，但此组合能解决“紧急”并设置后续策略)。\n\n错误选项分析：\nA) `SET PERSIST binlog_expire_logs_seconds=<value>;`：这会持久化设置，但不会立即删除日志。效果与`SET GLOBAL`类似，只是会写入`mysqld-auto.cnf`。\nB) `SET GLOBAL binlog_expire_logs_seconds=<value>`后重启服务器：重启会使配置生效，但不会比`PURGE`更快地紧急清理。而且`SET GLOBAL`后通常不需要重启就能使动态变量生效（对于`binlog_expire_logs_seconds`，它会影响未来的自动清理）。\nD) 在`my.cnf`中设置`binlog_expire_logs_seconds`：这需要重启服务器才能生效，不符合“紧急”的需求。\nF) 将`binlog_expire_logs_seconds`设置为0意味着禁用自动过期清理。这与减少空间的目标相反（除非是想完全手动控制清理，但题目是“紧急减少”）。\n\n**考点总结:**\n此题考察如何管理和清理MySQL二进制日志以释放磁盘空间。`PURGE BINARY LOGS`是立即删除旧日志的命令。`binlog_expire_logs_seconds`（或`expire_logs_days`）用于配置自动过期策略。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分立即生效的命令（如`PURGE BINARY LOGS`）和配置参数（需要特定条件触发或重启生效）。“紧急”意味着需要快速看到效果的操作。\n\n**学习建议:**\n学习MySQL二进制日志的生命周期管理，包括手动清理（`PURGE BINARY LOGS`）、自动过期清理（`binlog_expire_logs_seconds`, `expire_logs_days`）、日志轮转（`FLUSH LOGS`, `max_binlog_size`）。了解这些操作如何影响磁盘空间和复制/恢复能力。制定合理的日志保留策略以平衡空间使用和数据恢复需求。"
    },
    {
        "question": "### 试题 60:\n\nYou must run multiple instances of MySQL Server on a single host. Which three methods are supported?",
        "selections": {
            "A": "Use system tools to lock each instance to its own CPU.",
            "B": "Use resource groups to lock different instances on separate CPUs.",
            "C": "Run mysqld with --datadir defined for each instance.",
            "D": "Run MySQL Server docker containers.",
            "E": "Start mysqld or mysqld_safe using different option files for each instance.",
            "F": "Use systemd with different settings for each instance."
        },
        "answers": [
            "D",
            "E",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n在单个主机上运行多个MySQL服务器实例有多种方法，关键在于隔离它们的配置、数据目录、端口和套接字文件。\nD) 运行MySQL服务器的Docker容器：每个Docker容器可以封装一个独立的MySQL实例，有其自身的配置和资源隔离。这是现代常用的方法 (D 正确)。\nE) 为每个实例使用不同的选项文件（option files）启动`mysqld`或`mysqld_safe`：每个选项文件可以指定不同的端口、套接字文件、数据目录、PID文件等，从而使多个实例可以共存 (E 正确)。\nF) 使用systemd并为每个实例配置不同的设置（例如，通过创建不同的systemd服务单元文件，每个单元文件指向不同的选项文件和参数）：systemd可以管理多个MySQL实例，并确保它们使用独立的配置 (F 正确)。\n\n错误选项分析：\nA) 和 B) CPU锁定（CPU affinity）和资源组是操作系统级别的资源管理工具，它们本身不直接“支持”运行多个MySQL实例，而是用于控制已运行实例的资源使用。虽然可以与多实例部署结合使用，但不是运行多实例的“方法”。\nC) 仅仅为每个实例定义`--datadir`是不够的。还需要确保端口号、套接字文件、PID文件、日志文件等也是唯一的，否则会发生冲突。所以这个选项不完整。\n\n**考点总结:**\n此题考察在单个主机上部署和管理多个MySQL实例的技术。核心在于配置隔离，包括使用不同的选项文件、利用容器化技术（如Docker）或使用现代服务管理框架（如systemd）进行精细化控制。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n思考运行多个服务实例时最关键的隔离点：配置文件、数据存储、网络端口、进程标识。选择那些能够系统性解决这些隔离问题的方法。\n\n**学习建议:**\n学习如何在Linux或Windows上配置和运行多个MySQL实例。掌握如何为每个实例创建独立的选项文件（`my.cnf`），并指定不同的`port`, `socket`, `datadir`, `pid-file`, `log-error`等参数。了解使用Docker运行MySQL的优势和方法。如果使用systemd，学习如何创建和管理多个MySQL服务单元。"
    },
    {
        "question": "### 试题 61:\n\nYour MySQL installation is running low on space due to binary logs. You need to reduce your log space usage urgently. Which two sets of actions when completed will accomplish this?",
        "selections": {
            "A": "Use PURGE BINARY LOGS TO `binlog_name`;",
            "B": "Use SET GLOBAL binlog_expire_logs_seconds=`value` and run the FLUSH BINARY LOGS command.",
            "C": "Use SET GLOBAL binlog_expire_logs_seconds=`value` and restart the server.",
            "D": "Use SET PERSIST binlog_expire_logs_seconds=`value`.",
            "E": "Set binlog_expire_logs_seconds = 0 in my.cnf and restart the server.",
            "F": "Set binlog_expire_logs_seconds in my.cnf."
        },
        "answers": [
            "A",
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题59内容几乎完全相同，只是选项顺序可能不同。\nA) `PURGE BINARY LOGS TO '<binlog_name>';` (或 `PURGE BINARY LOGS BEFORE 'datetime_expression';`): 立即删除旧的二进制日志文件，这是最直接和紧急的清理方法 (A 正确)。\nB) `SET GLOBAL binlog_expire_logs_seconds=<value>;` 用于配置自动过期清理。单独设置不会立即删除，但配合 `FLUSH BINARY LOGS;`（轮转日志并可能触发清理检查）可以加速策略生效和潜在的旧日志清理 (B 正确)。\n\n错误选项分析同试题59。\n\n**考点总结:**\n再次强调管理和清理MySQL二进制日志以释放磁盘空间的方法。`PURGE BINARY LOGS`用于立即删除，而`binlog_expire_logs_seconds`（或`expire_logs_days`）用于配置自动清理策略。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复的考点更应牢记。对于“紧急”需求，优先选择能立即产生效果的操作（如`PURGE`）。\n\n**学习建议:**\n参考试题59的学习建议。熟练掌握二进制日志的各种管理命令和配置参数。"
    },
    {
        "question": "### 试题 62:\n\nThe replication for master and slave MySQL Server is up and running. The disk space occupied by the binary log files continues to grow. Which two methods manage this issue?",
        "selections": {
            "A": "Execute the FLUSH LOGS statement.",
            "B": "Delete all binary log files manually on the file system to release storage space.",
            "C": "Execute the PURGE BINARY LOGS statement.",
            "D": "On the master server, disable binary logging by removing the --log-bin option",
            "E": "Set the binlog_expire_logs_seconds variable."
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n管理二进制日志增长问题，主要有两种方法：手动清理和配置自动清理。\nC) 执行`PURGE BINARY LOGS`语句：可以手动删除指定日期之前或指定文件名之前的所有二进制日志文件，从而释放磁盘空间 (C 正确)。\nE) 设置`binlog_expire_logs_seconds`（或`expire_logs_days`）变量：配置这个动态或静态变量后，MySQL会自动删除超过指定保留时间的旧二进制日志文件。这是自动管理日志空间的推荐方法 (E 正确)。\n\n错误选项分析：\nA) `FLUSH LOGS`语句会关闭并重新打开所有日志文件，包括二进制日志（即轮转二进制日志）。轮转本身会创建一个新文件，但不会删除旧文件，除非同时配置了自动过期策略且有符合条件的旧日志。\nB) 手动在文件系统层面删除二进制日志文件是非常危险的，可能导致复制中断、数据不一致或影响时间点恢复。应始终使用MySQL提供的命令（如`PURGE BINARY LOGS`）来管理二进制日志。\nD) 禁用二进制日志会停止复制，这不是管理日志增长的方法，而是停止产生日志的方法。如果复制是必需的，则不能禁用二进制日志。\n\n**考点总结:**\n此题考察管理二进制日志磁盘空间占用的正确方法。核心是使用`PURGE BINARY LOGS`进行手动清理，以及配置`binlog_expire_logs_seconds`或`expire_logs_days`进行自动清理。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分安全有效的日志管理方法和危险或不解决问题的方法。记住`PURGE`是手动删除，`expire_logs`相关变量是自动删除。\n\n**学习建议:**\n学习二进制日志的生命周期管理。掌握`PURGE BINARY LOGS`命令的各种语法（按文件名、按日期时间）。理解`binlog_expire_logs_seconds`和`expire_logs_days`参数如何工作，以及它们与日志轮转的关系。制定合理的日志保留策略，平衡磁盘空间、复制需求和时间点恢复窗口。"
    },
    {
        "question": "### 试题 63:\n\nChoose two. You administer a three node, single primary InnoDB Cluster. Examine `cluster.status()` displayed here: `\"statusText\":\"Cluster is ONLINE and can tolerate up to ONE failure.\"`\nWhich two statements are true?",
        "selections": {
            "A": "If two instances are unreachable because of network failure, the cluster will reconfigure to work with a single instance.",
            "B": "Reconfiguring the cluster as multi-primary, will increase tolerance to two failures.",
            "C": "There is a quorum and transactions can be committed normally.",
            "D": "If two instances crash, it will produce an outage.",
            "E": "Restarting an arbitrary instance will always provoke primary instance failover.",
            "F": "Shutting down two instances with the SHUTDOWN command will produce an outage."
        },
        "answers": [
            "D",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n集群状态为`ONLINE`且能容忍`ONE failure`。这是一个3节点的单主模式InnoDB集群。法定数量（quorum）是 `floor(N/2) + 1 = floor(3/2) + 1 = 1 + 1 = 2`。这意味着至少需要2个节点在线才能正常运行并处理写事务。\n\nD) 如果两个实例崩溃，只剩下1个实例在线。1个实例无法满足法定数量（2个），因此集群将无法处理写事务，导致服务中断（outage） (D 正确)。\nF) 使用`SHUTDOWN`命令关闭两个实例，同样会导致只剩下1个实例在线，无法满足法定数量，从而产生服务中断 (F 正确)。\n\n错误选项分析：\nA) 如果两个实例因网络故障而不可达，剩下的单个实例也无法形成法定数量。集群不会“重新配置”为单实例工作模式来处理写事务，它会进入只读或不可用状态，直到足够多的成员恢复连接。\nB) 将3节点的单主集群重新配置为多主模式，并不会将其容错能力从“容忍一个故障”增加到“容忍两个故障”。在3节点多主模式下，如果丢失2个节点，同样只剩下1个节点，无法形成多数派，写操作会停止。\nC) “Cluster is ONLINE and can tolerate up to ONE failure”意味着当前所有3个节点都在线且健康，形成了法定数量（3 > 2），因此事务可以正常提交。但题目问的是基于这个状态的推断。如果这是一个选择题，C本身描述了当前状态的含义，但D和F描述的是故障场景下的结果，更能体现“容忍一个故障”的含义。\nE) 重启一个非主实例通常不会导致主实例故障转移，除非重启过程中该实例被错误地选为新的主实例（可能性较低）。重启主实例则会触发故障转移。所以“总是”引发故障转移是不准确的。\n\n**考点总结:**\n此题考察对InnoDB集群（基于组复制）法定数量（quorum）和容错能力的理解。在单主模式下，N个节点的集群能容忍 `floor((N-1)/2)` 个节点故障。对于3节点集群，N=3，容错能力是 `floor((3-1)/2) = floor(1) = 1`。这意味着至少需要 `N - floor((N-1)/2) = 3 - 1 = 2` 个节点在线才能维持法定数量。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解法定数量（quorum）是组复制和InnoDB集群的核心。对于N个节点的集群，多数派是`floor(N/2) + 1`。计算出法定数量后，判断不同故障场景下剩余节点数是否满足法定数量。\n\n**学习建议:**\n深入学习MySQL InnoDB Cluster的架构，特别是其底层的组复制技术。掌握法定数量的计算和意义，以及它如何保证数据一致性和防止脑裂。了解单主模式和多主模式的特性、优缺点和容错能力。学习如何监控集群状态（如使用`cluster.status()`）和处理成员故障。"
    },
    {
        "question": "### 试题 64:\n\nChoose two. Which two MySQL Server accounts are locked by default?",
        "selections": {
            "A": "any new ROLE accounts",
            "B": "any internal system accounts",
            "C": "any user created with a username, but missing the host name",
            "D": "any user set as DEFINER for stored programs",
            "E": "any user created without a password"
        },
        "answers": [
            "A",
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL中某些类型的账户在创建或存在时，默认可能是“锁定”的，或者具有使其无法直接登录的特性。\nA) 新创建的角色（ROLE accounts）本身不能用于登录。它们是权限的集合，需要被授予给用户账户，并且用户需要激活该角色才能使用其权限。从这个意义上说，角色账户可以被认为是“锁定的”（即不可直接登录） (A 正确)。\nB) MySQL有一些内部系统账户，例如用于内部进程或特定功能的账户（如`mysql.sys`, `mysql.session`, `mysql.infoschema`等，具体名称和行为可能因版本而异）。这些账户通常被设计为不能从外部登录，或者具有非常受限的权限，可以被视为默认“锁定”或不可用于常规登录 (B 正್ರೀ）。\n\n错误选项分析：\nC) 创建用户时如果只指定用户名而省略主机名，MySQL会报错，不允许创建这样的用户。必须指定主机部分（如`'user'@'localhost'`, `'user'@'%'`）。\nD) 作为存储过程、函数、视图或触发器的`DEFINER`的用户账户本身并不因此而被锁定。`DEFINER`指定了对象执行时的安全上下文。\nE) 在现代MySQL版本中（特别是启用了密码验证插件如`caching_sha2_password`），通常不允许创建没有密码的用户，或者创建后该用户也无法登录，直到设置密码。如果允许创建无密码用户（例如通过特定插件或旧版本行为），该用户理论上可以无密码登录（取决于服务器配置），所以不一定是“锁定”的。而且“锁定”通常指账户被显式禁用。\n\n**考点总结:**\n此题考察对MySQL中不同类型账户（用户、角色、系统账户）及其默认状态的理解。区分可登录的用户账户和用于其他目的（如权限集合、内部操作）的账户。\n\n**答案说明:** “锁定”的含义可能有些模糊。如果指“不能用于客户端直接登录”，那么A和B是合理的。如果指账户被显式`ACCOUNT LOCK`，则需要具体场景。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解角色和用户账户的区别。思考哪些账户不是设计用来让最终用户直接登录和操作的。\n\n**学习建议:**\n学习MySQL的用户账户管理，包括创建用户、授予权限、设置密码、账户锁定/解锁（`ALTER USER ... ACCOUNT LOCK/UNLOCK`）。学习角色的概念和使用。了解MySQL内部可能存在的一些特殊用途的系统账户及其安全含义。"
    },
    {
        "question": "### 试题 65:\n\nExamine this command, which executes successfully: `mysqlpump --user=root --password > full_backup.sql`\nWhich two databases will be excluded from this dump?",
        "selections": {
            "A": "world",
            "B": "employee",
            "C": "information_schema",
            "D": "mysql",
            "E": "sys"
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlpump`是MySQL提供的一个逻辑备份工具，类似于`mysqldump`但有一些增强功能（如并行备份）。\n当`mysqlpump`在没有任何数据库或表名指定的情况下执行时（如本题所示，它没有`--all-databases`或特定数据库名），其默认行为是备份**所有用户创建的数据库中的所有表**。它会自动排除某些系统数据库。\nC) `information_schema`：这是一个虚拟的元数据数据库，包含关于服务器、数据库、表等的只读信息。它通常不被逻辑备份工具备份，因为它的内容是动态生成的，并且在恢复时会由服务器自动创建 (C 正确)。\nE) `sys` schema：这是一个包含许多视图、存储过程和函数以帮助DBA监控和诊断MySQL性能的系统数据库。它的内容也是基于其他系统表（如Performance Schema和Information Schema）动态生成的。`mysqlpump`默认会排除`sys` schema (E 正确)。\n\n错误选项分析：\nA) `world`：如果这是一个用户创建的数据库，`mysqlpump`（在无特定数据库指定时）会备份它。\nB) `employee`：同上，如果这是用户数据库，会被备份。\nD) `mysql`：`mysql`系统数据库包含用户账户、权限、时区信息等关键元数据。与`mysqldump`不同（`mysqldump --all-databases`会包含`mysql`库），`mysqlpump`在默认情况下（即不指定数据库时）会备份`mysql`数据库中的用户和权限信息（通过特定的方式，而不是简单dump所有表）。但如果题目问的是“哪些数据库会被排除”，`mysql`库本身（特别是其所有表）的处理比较特殊。不过，相对于`information_schema`和`sys`的明确排除，`mysql`库的排除不是那么绝对，或者说其备份方式不同。更准确地说，`mysqlpump` 默认不备份 `performance_schema`, `sys`, `ndbinfo`, `information_schema`。它会备份 `mysql` 库，但可能不包括所有内容，或者以特殊方式处理权限。\n\n**考点总结:**\n此题考察`mysqlpump`工具在默认情况下的备份范围，特别是哪些系统数据库会被自动排除。\n\n**答案精确性:** 根据MySQL官方文档，`mysqlpump` 默认情况下会排除 `information_schema`, `performance_schema`, `sys` 和 `ndbinfo` (如果存在)。它会备份`mysql`数据库，但不会备份其中的 `SYS_CONFIG` 表。因此，严格来说，`mysql` 数据库本身不会被完全排除。但`information_schema` 和 `sys` 是确定会被排除的。\n\n如果题目要求选择两个，C和E是最明确的被`mysqlpump`默认排除的系统数据库。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n了解`mysqlpump`和`mysqldump`在默认行为和选项上的一些差异。记住哪些系统数据库通常不参与常规的逻辑备份。\n\n**学习建议:**\n学习`mysqlpump`工具的使用方法、主要选项和特性（如并行备份、压缩、用户账户处理、可扩展性等）。阅读官方文档中关于`mysqlpump`默认备份范围和排除规则的说明。进行实验以验证其行为。"
    },
    {
        "question": "### 试题 66:\n\nChoose three. Which three commands can report all the current connections running on the MySQL server?",
        "selections": {
            "A": "SELECT * FROM performance_schema.events_transactions_current",
            "B": "SELECT * FROM performance_schema.threads",
            "C": "SHOW FULL PROCESSLIST",
            "D": "SELECT * FROM information_schema.processlist",
            "E": "SHOW EVENTS",
            "F": "SELECT * FROM sys.metrics",
            "G": "SELECT * FROM information_schema.events",
            "H": "SELECT * FROM sys.statement_analysis"
        },
        "answers": [
            "B",
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n查看当前MySQL服务器上的所有连接（线程）信息，可以使用以下方法：\nB) `SELECT * FROM performance_schema.threads;`：Performance Schema中的`threads`表记录了服务器中当前存在的所有线程的详细信息，包括前台用户连接线程和后台系统线程。可以从中筛选出用户连接 (B 正确)。\nC) `SHOW FULL PROCESSLIST;`：这是一个SQL命令，显示当前所有MySQL线程的列表，包括线程ID、用户、主机、连接的数据库、命令、状态、执行时间等信息。`FULL`关键字会显示完整的`Info`字段内容 (C 正确)。\nD) `SELECT * FROM information_schema.processlist;`：`information_schema.processlist`表提供了与`SHOW PROCESSLIST`命令相同的信息，允许通过SQL查询进行更灵活的筛选和处理 (D 正确)。\n\n错误选项分析：\nA) `performance_schema.events_transactions_current`：记录当前正在进行的事务事件，而不是连接本身。\nE) `SHOW EVENTS;`：显示事件调度器中已定义的事件，与当前连接无关。\nF) `sys.metrics`：是`sys` schema中的一个视图，总结了MySQL服务器的各种性能指标（基于Performance Schema和Information Schema），不直接列出连接。\nG) `information_schema.events`：提供关于事件调度器中事件的元数据，与当前连接无关。\nH) `sys.statement_analysis`：是`sys` schema中的视图，提供SQL语句的聚合统计信息，而不是当前连接列表。\n\n**考点总结:**\n此题考察查看MySQL服务器当前连接信息的常用方法。`SHOW [FULL] PROCESSLIST`是最直接的命令，而查询`information_schema.processlist`或`performance_schema.threads`表可以提供更结构化的数据访问。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住“processlist”这个关键词，它与连接/线程列表密切相关。Performance Schema通常提供更底层和详细的信息。\n\n**学习建议:**\n熟练掌握`SHOW PROCESSLIST`命令及其输出的解读。学习如何通过`KILL`命令终止连接。了解`information_schema.processlist`表的列及其含义。学习使用Performance Schema中的`threads`表来获取更丰富的线程信息。了解`sys` schema中与连接和会话相关的视图，如`sys.session`, `sys.processlist`等，它们是对底层数据更友好的封装。"
    },
    {
        "question": "### 试题 67:\n\nChoose three. Identify three functions of MySQL Enterprise Monitor.",
        "selections": {
            "A": "Analyze query performance.",
            "B": "Start a logical backup.",
            "C": "Determine the availability of monitored MySQL servers.",
            "D": "Centrally manage users.",
            "E": "Start a MySQL Enterprise backup.",
            "F": "Centrally manage server configurations.",
            "G": "Start and stop MySQL Server.",
            "H": "Create customized alerts and provide notification alerts."
        },
        "answers": [
            "A",
            "C",
            "H"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL Enterprise Monitor (MEM) 是一个用于监控和管理MySQL服务器（包括社区版和企业版）的工具套件。\nA) 分析查询性能：MEM包含Query Analyzer功能，可以捕获、分析和诊断慢查询及高负载查询，提供执行计划、统计信息等 (A 正确)。\nC) 确定受监控MySQL服务器的可用性：MEM会持续监控服务器的健康状况和可连接性，并在服务器不可用时发出告警 (C 正确)。\nH) 创建自定义警报并提供通知：MEM允许用户配置基于各种指标和事件的警报规则，并通过邮件、SNMP等方式发送通知 (H 正确)。\n\n错误选项分析：\nB) 和 E) MEM本身不直接启动逻辑备份（如`mysqldump`）或物理备份（如MySQL Enterprise Backup）。它可以监控备份作业的状态（如果配置了相关顾问），但备份执行通常由专门的备份工具或脚本完成。\nD) 虽然MEM可以提供关于用户和权限的信息，但它主要是一个监控和建议工具，不是一个用于集中创建、修改或删除用户账户的管理工具。用户管理通常通过SQL命令或MySQL Workbench等工具进行。\nF) MEM可以监控服务器配置参数，并根据最佳实践提供建议，但它不直接提供一个界面来集中修改和推送服务器配置到多个实例。配置管理更多依赖配置文件或`SET PERSIST`等。\nG) MEM通常不直接用于启动和停止MySQL服务器实例。这通常由操作系统服务管理工具（如systemd, service）、脚本或MySQL Shell等完成。MEM可以报告服务器的启停状态。\n\n**考点总结:**\n此题考察对MySQL Enterprise Monitor核心功能的了解。主要包括性能监控（特别是查询分析）、可用性监控、基于规则的警报和通知，以及提供基于最佳实践的建议（Advisors）。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n将MEM定位为一个“监控、分析、告警、建议”的平台。排除那些属于直接“操作”或“执行”（如启动备份、启停服务、管理用户）的选项，除非该操作是其核心监控反馈环的一部分。\n\n**学习建议:**\n了解MySQL Enterprise Monitor的架构（Service Manager, Agent, Repository, Dashboard/UI）。学习其主要功能模块，如实时监控、历史数据分析、Query Analyzer、Replication Monitor、Advisors（如安全、性能、复制相关的建议）。如果可能，实际部署和使用MEM以获得直观体验。"
    },
    {
        "question": "### 试题 68:\n\nChoose three. Which three actions will secure a MySQL server from network-based attacks?",
        "selections": {
            "A": "Construct a perimeter network to allow public traffic",
            "B": "Place the MySQL instance behind a firewall.",
            "C": "Use network file system (NFS) for storing data.",
            "D": "Change the listening port to 3307.",
            "E": "Use MySQL Router to proxy connections to the MySQL server.",
            "F": "Allow connections from the application server only."
        },
        "answers": [
            "A",
            "B",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题4内容相似，考察网络层面的安全防护措施。\nB) 将MySQL实例置于防火墙之后：防火墙可以根据预定义的规则（如允许特定IP、端口）过滤网络流量，阻止未授权访问 (B 正确)。\nF) 只允许来自应用服务器的连接：限制连接来源，将MySQL服务器的访问权限收紧到最小必要的范围，大大减少攻击面 (F 正确)。\nA) 构建边界网络（Perimeter Network，也称DMZ）来允许公共流量：这个选项有些歧义。如果MySQL服务器本身不直接暴露在公共网络，而是通过DMZ中的应用服务器或代理访问，这是一种安全架构。如果理解为“允许公共流量（访问MySQL）”，那就不安全。但如果理解为通过设计良好的网络分区（如DMZ）来隔离和保护内部MySQL服务器，同时允许受控的公共访问（例如通过Web应用），则可以视为一种安全措施。与B和F相比，这个选项的直接性稍差，但从网络架构安全角度是相关的。 假设这里的意图是，公共流量访问的是前端应用，应用再访问内部的MySQL，那么构建这样的分层网络是安全的 (A 可以认为是正确的，但表述不够清晰)。\n\n错误选项分析（理由同试题4）：\nC) 使用NFS存储数据：与网络攻击防护关系不大，可能引入其他风险。\nD) 更改监听端口：安全靠隐晦，效果有限。\nE) MySQL Router：主要用于高可用和负载均衡，不是主要的安全防御工具。\n\n**考点总结:**\n再次强调网络安全的核心原则：防火墙、最小化访问权限（白名单）、网络分段和隔离。选择那些能直接阻止或限制未授权网络连接的措施。\n\n**答案说明:** 如果必须严格选择最直接的“安全MySQL服务器”的措施，B和F是最直接的。A选项描述的是一种更宏观的网络安全架构策略，其有效性依赖于具体实现。如果题目只要求选两个，B和F是首选。如果必须选三个，A可以作为补充，但其表述需要更精确。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复的考点要特别注意。防火墙和限制连接来源是网络安全的基础。考虑措施的直接性和有效性。\n\n**学习建议:**\n参考试题4的学习建议。学习网络安全的基本概念，如DMZ、网络分段、入侵检测/防御系统(IDS/IPS)等，以及它们如何应用于保护数据库服务器。"
    },
    {
        "question": "### 试题 69:\n\nChoose two. Which two statements are true about MySQL server multi-source replication?",
        "selections": {
            "A": "It must use GTID replication.",
            "B": "It is not compatible with auto-positioning.",
            "C": "It needs to be re-instanced after a crash to maintain consistency.",
            "D": "It uses only time-based replication conflict resolution.",
            "E": "It does not attempt to detect or resolve replication conflicts.",
            "F": "It relies on relay_log_recovery for resilient operations."
        },
        "answers": [
            "E",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n多源复制（Multi-Source Replication）允许一个从服务器从多个主服务器复制数据。\nF) 它依赖于`relay_log_recovery`来实现弹性操作：当从服务器（副本）上的SQL线程或I/O线程意外停止后，如果`relay_log_recovery=ON`（默认值），服务器在重启后会自动清理中继日志中可能已部分应用或损坏的事务，并从新的、一致的点重新开始应用。这对于所有复制类型（包括多源）的健壮性都很重要 (F 正确)。\nE) 它不尝试检测或解决复制冲突：多源复制本身不内置复制冲突（例如，来自不同主库的事务修改了从库上的同一行数据）的检测和解决机制。DBA需要自行设计数据模型和应用逻辑来避免冲突，或者使用第三方工具/策略来处理冲突 (E 正确)。\n\n错误选项分析：\nA) 多源复制的每个复制通道（channel）可以独立配置为使用GTID复制或传统的基于文件和位置的复制。并非所有通道都“必须”使用GTID。\nB) 自动定位（auto-positioning，即`MASTER_AUTO_POSITION=1`或`SOURCE_AUTO_POSITION=1`）是GTID复制的核心特性。多源复制的通道如果配置为GTID复制，就会使用自动定位。\nC) “re-instanced after a crash”描述过于模糊。像任何MySQL实例一样，崩溃后需要进行标准的恢复过程。多源复制本身不要求在崩溃后进行特殊的“re-instancing”来维护一致性，只要每个通道的复制状态正确恢复即可。\nD) 多源复制本身不提供基于时间的冲突解决。冲突解决是DBA的责任。\n\n**考点总结:**\n此题考察对MySQL多源复制的特性和限制的理解。关键在于其不内置冲突解决机制，以及依赖通用的复制健壮性特性（如中继日志恢复）。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解多源复制的核心功能——从多个源聚合数据。思考这可能带来的挑战，如数据冲突。了解其配置灵活性（如每个通道可独立配置GTID）。\n\n**学习建议:**\n学习MySQL多源复制的配置步骤（创建复制通道、为每个通道指定主库信息和复制方式等）。了解其使用场景（如数据聚合、分片数据的集中备份/分析）。重点关注复制冲突的潜在问题以及如何避免或处理它们。熟悉`relay_log_recovery`等与复制健壮性相关的参数。"
    },
    {
        "question": "### 试题 70:\n\nChoose two. Which two statements are true about using MySQL Enterprise Monitor Query Analyzer?",
        "selections": {
            "A": "It is possible to retrieve a normalized statement, but never the exact statement that was executed.",
            "B": "The single query QRTi pie chart in the Query Analyzer view is based on the average execution of all statements.",
            "C": "It is possible to import data into the Query Analyzer from heterogeneous sources, such as CSV.",
            "D": "It is possible to list and analyze statements in an arbitrary graph range selection from timeseries graphs.",
            "E": "It is possible to configure the Query Analysis built-in advisor to get notified about slow query execution."
        },
        "answers": [
            "D",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL Enterprise Monitor (MEM) 的 Query Analyzer 是一个强大的查询性能分析工具。\nD) Query Analyzer 提供了时间序列图表来展示查询的性能指标（如执行次数、延迟等）。用户可以在这些图表上选择一个任意的时间范围，然后查看并分析在该时间段内捕获到的SQL语句 (D 正确)。\nE) Query Analyzer 与MEM的顾问（Advisors）系统集成。可以配置与查询分析相关的顾问规则（例如，基于慢查询阈值、高执行频率等），当满足条件时，顾问会生成事件并可以触发通知 (E 正确)。\n\n错误选项分析：\nA) Query Analyzer 会捕获和显示执行的SQL语句。它通常会显示规范化（normalized）的语句（例如，将字面量替换为占位符以聚合相似查询），但它也会存储并可以显示语句的示例（example statements），这些示例就是实际执行的语句。所以说“从不显示确切语句”是错误的。\nB) QRTi (Query Response Time index) 是一个衡量查询响应时间的指标。Query Analyzer 中的饼图或条形图通常是基于总执行时间、平均延迟、执行次数等对各个查询进行排名和可视化，而不是“所有语句的平均执行”。它会区分不同的查询。\nC) Query Analyzer 的数据主要来源于MEM Agent从受监控MySQL服务器上收集的性能数据（如Performance Schema、慢查询日志等）。它不是一个通用的数据导入工具，不支持从CSV等异构源导入查询数据进行分析。\n\n**考点总结:**\n此题考察对MySQL Enterprise Monitor Query Analyzer功能的理解。核心功能包括捕获和分析SQL语句、提供时间序列性能视图、允许按时间范围筛选、显示规范化语句和示例语句，以及与顾问系统集成以进行告警和建议。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解Query Analyzer作为性能诊断工具的核心价值：找出慢查询、高负载查询，并提供分析依据。关注其数据来源、分析维度和交互方式。\n\n**学习建议:**\n学习MySQL Enterprise Monitor Query Analyzer的界面和主要功能。了解它如何收集查询数据（例如，通过Performance Schema的语句摘要表或慢查询日志）。掌握如何使用它来识别性能瓶颈查询，查看执行计划、统计信息和示例语句。熟悉其与MEM Advisors的集成。"
    },
    {
        "question": "### 试题 71:\n\nYou must export data from a set of tables in the `world_x` database. Examine this set of tables: `Tables (country, countryinfo, location)`\nWhich two options will export data into one or more files?",
        "selections": {
            "A": "shell> `mysqldump world_x country countryinfo location > mydump.sql`",
            "B": "mysql> ```SELECT * INTO OUTFILE '/output/country.txt' FROM world_x.country;\nmysql> SELECT * INTO OUTFILE '/output/countryinfo.txt' FROM world_x.countryinfo;\nmysql> SELECT * INTO OUTFILE '/output/location.txt' FROM world_x.location;```",
            "C": "shell> `mysqlexport world_x country countryinfo location > mydump.sql`",
            "D": "mysql> ```CLONE LOCAL DATA DIRECTORY = '/var/lib/mysql/world_x/country';\nmysql> CLONE LOCAL DATA DIRECTORY = '/var/lib/mysql/world_x/countryinfo';\nmysql> CLONE LOCAL DATA DIRECTORY = '/var/lib/mysql/world_x/location';```",
            "E": "shell> `mysql --batch world_x.country world_x.countryinfo world_x.location > mydump.sql`"
        },
        "answers": [
            "A",
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n导出MySQL表数据到文件有多种方法。\nA) `shell> mysqldump world_x country countryinfo location > mydump.sql`：`mysqldump`是一个常用的逻辑备份工具。这个命令会将`world_x`数据库中的`country`, `countryinfo`, `location`这三个表的结构和数据导出到一个名为`mydump.sql`的SQL脚本文件中 (A 正确)。\nB) 使用`SELECT ... INTO OUTFILE`语句：这个SQL命令可以将查询结果导出到服务器主机上的一个文本文件中。为每个表执行一次该命令，可以将每个表的数据分别导出到不同的文本文件（如`.txt`或`.csv`格式） (B 正确)。\n\n错误选项分析：\nC) `mysqlexport`：没有名为`mysqlexport`的标准MySQL命令行工具。\nD) `CLONE LOCAL DATA DIRECTORY`：这是MySQL克隆功能的命令，用于创建实例的物理副本，不是导出数据到文本或SQL文件。\nE) `shell> mysql --batch world_x.country ... > mydump.sql`：`mysql`命令行客户端配合`--batch`（或`-B`）和重定向可以执行SQL并输出结果，但通常用于执行查询并获取其文本输出，而不是像`mysqldump`那样生成完整的建表和插入语句的SQL脚本。直接将表名作为参数传递给`mysql`命令来导出数据是不标准的。\n\n**考点总结:**\n此题考察导出MySQL数据的常用方法。`mysqldump`用于逻辑备份（导出SQL文件），`SELECT ... INTO OUTFILE`用于将查询结果导出到文本文件。需要注意工具的名称和正确用法。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分逻辑导出（生成SQL或文本数据）和物理复制。记住`mysqldump`是标准的逻辑备份工具。`SELECT ... INTO OUTFILE`是SQL层面的数据导出方法。\n\n**学习建议:**\n熟练掌握`mysqldump`工具的各种选项，包括如何备份整个数据库、特定数据库、特定表，以及如何只备份数据、只备份结构或同时备份两者。学习`SELECT ... INTO OUTFILE`和`LOAD DATA INFILE`语句的使用，以及它们与`secure_file_priv`系统变量的关系。了解不同导出格式（SQL, CSV, TSV等）的特点和适用场景。"
    },
    {
        "question": "### 试题 72:\n\nChoose three. Which are three benefits of using mysqlbackup instead of mysqldump?",
        "selections": {
            "A": "mysqlbackup can perform partial backup of stored programs.",
            "B": "mysqlbackup allows logical backups with concurrency resulting in faster backups and restores.",
            "C": "mysqlbackup integrates tape backup and has the virtual tape option.",
            "D": "mysqlbackup can back up tables with the InnoDB engine without blocking reducing wait times due to contention.",
            "E": "mysqlbackup does not back up MySQL system tables, which shortens backup time.",
            "F": "mysqlbackup restores data from physical backups, which are faster than logical backups."
        },
        "answers": [
            "C",
            "D",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlbackup` (即 MySQL Enterprise Backup) 是一个企业级物理备份工具，与逻辑备份工具`mysqldump`相比有一些优势。\nC) `mysqlbackup`支持与介质管理软件（MMS）集成以进行磁带备份，并提供了虚拟磁带（virtual tape）选项。这使得它可以用于更复杂和企业级的备份归档策略 (C 正确)。\nD) `mysqlbackup`执行的是热物理备份。对于InnoDB表，它可以在不阻塞读写操作的情况下进行备份（或阻塞时间非常短），从而减少因锁争用导致的等待时间。这对于高并发环境非常重要 (D 正确)。\nF) `mysqlbackup`创建的是物理备份。从物理备份恢复数据通常比从逻辑备份（如`mysqldump`产生的SQL文件，需要逐条执行SQL语句）恢复要快得多，特别是在数据量很大时 (F 正确)。\n\n错误选项分析：\nA) `mysqlbackup`是物理备份，它备份整个数据文件。存储过程等对象作为数据字典或系统表的一部分被物理备份，它不专门执行“部分备份存储程序”。部分备份通常指备份特定的数据库或表。\nB) `mysqlbackup`主要执行物理备份，而不是逻辑备份。虽然它有一些选项可以进行类似逻辑的操作（如传输表空间），但其核心是物理的。逻辑备份的并发性是`mysqlpump`的特点。\nE) `mysqlbackup`作为物理备份，会备份包括系统表（如`mysql`数据库中的表）在内的所有构成MySQL实例的文件。不备份系统表会使恢复后的实例不完整。\n\n**考点总结:**\n此题考察MySQL Enterprise Backup (`mysqlbackup`) 相对于`mysqldump`的主要优势。核心在于物理备份的热备能力（减少阻塞）、恢复速度快以及对企业级特性（如磁带备份集成）的支持。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解物理备份和逻辑备份的根本区别。物理备份通常更快、对在线业务影响更小（热备），但可能不够灵活（如跨版本、跨平台恢复）。逻辑备份更灵活，但备份和恢复时间较长。\n\n**学习建议:**\n学习MySQL Enterprise Backup的使用方法、特性和不同类型的备份（完全备份、增量备份、压缩备份、加密备份等）。了解它如何与InnoDB存储引擎交互以实现热备份。对比其与`mysqldump`和开源物理备份工具（如Percona XtraBackup）的异同。熟悉其恢复流程。"
    },
    {
        "question": "### 试题 73:\n\nChoose two. All MySQL Server instances belonging to InnoDB Cluster have SSL configured and enabled. You must configure InnoDB Cluster to use SSL for group communication.\nWhich two statements are true?",
        "selections": {
            "A": "An existing InnoDB Cluster must be dissolved and created from scratch to enable SSL for group communication.",
            "B": "If only some InnoDB Cluster members are enabled for SSL group communication, and --ssl-mode=PREFERRED, communication will fall back to unencrypted connection.",
            "C": "SSL group communication must be enabled at cluster creation time by specifying createCluster(memberSslMode:'REQUIRED').",
            "D": "SSL group communication can be enabled for an existing cluster, one instance at time, by setting group_replication_ssl_mode.",
            "E": "SSL group communication requires the use of an additional set of parameters group_replication_recovery_*.",
            "F": "Configuring SSL group communication also configures SSL distributed recovery."
        },
        "answers": [
            "A",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n为InnoDB集群的组通信（Group Communication System, GCS）启用SSL加密有一些特定要求。\nA) 根据MySQL文档，为InnoDB集群的组通信启用或禁用SSL通常需要在集群层面进行，并且不能在现有集群上动态更改。这意味着如果集群创建时未启用组通信SSL，要启用它，通常需要解散现有集群并重新创建一个启用了SSL的集群 (A 正确)。\nC) 在使用MySQL Shell的AdminAPI创建InnoDB集群时，可以通过`createCluster()`命令的选项来指定组通信的SSL模式。例如，设置`memberSslMode: 'REQUIRED'`可以强制所有组内通信使用SSL (C 正确)。\n\n错误选项分析：\nB) 如果组通信SSL模式设置为`REQUIRED`，则所有成员都必须使用SSL。如果设置为`PREFERRED`，成员会尝试使用SSL，但如果无法建立SSL连接（例如，证书问题或部分成员未配置SSL），通信可能会失败或（在某些特定配置下，但不推荐）降级。但组复制通常要求所有成员在SSL配置上保持一致以保证安全。\nD) 组通信的SSL模式是集群级别的设置，不是在单个实例上通过设置`group_replication_ssl_mode`（这是一个MySQL服务器变量，用于组复制本身的SSL，与GCS的SSL配置方式不同）逐个启用的。更改GCS的SSL通常涉及集群重建。\nE) `group_replication_recovery_*`参数用于配置组复制的分布式恢复过程（如通过SSL进行状态传输），与组通信本身的SSL配置是相关的但不同的参数集。\nF) 组通信的SSL配置和分布式恢复的SSL配置是分开的，尽管它们都可能使用SSL。启用组通信SSL不自动意味着分布式恢复也配置为使用SSL（虽然通常建议两者都用SSL）。\n\n**考点总结:**\n此题考察为InnoDB集群的组内通信启用SSL加密的配置方法和限制。关键在于这通常是在集群创建时决定的，并且更改可能需要重建集群。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解InnoDB集群中不同层面的SSL：客户端到服务器的SSL连接、组复制成员之间的SSL（用于XCom/GCS通信）、分布式恢复的SSL。关注题目特指的“group communication”的SSL。\n\n**学习建议:**\n学习如何使用MySQL Shell AdminAPI部署和管理InnoDB集群。详细阅读官方文档中关于为InnoDB集群配置SSL/TLS的部分，包括`createCluster()`命令的相关选项（如`memberSslMode`, `ipAllowlist`等）以及与组复制相关的SSL参数（如`group_replication_ssl_mode`, `group_replication_recovery_use_ssl`等）。了解安全配置的最佳实践。"
    },
    {
        "question": "### 试题 74:\n\nAfter installing MySQL 8.0 on Oracle Linux 7, you initialize the data directory with the `mysqld --initialize` command. Which two will assist in locating the root password?",
        "selections": {
            "A": "the root_pw variable stored in the mysql.install table",
            "B": "the root password displayed on the screen via a Warning message",
            "C": "the root password inserted in the error log set by the --log-error=file_name variable",
            "D": "the root password written to the /root/.my.cnf file",
            "E": "as root, executing the SHOW PASSWORD command by using the SHA-256 password encryption plugin"
        },
        "answers": [
            "B",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n当使用`mysqld --initialize`（或`mysqld --initialize-insecure`）初始化MySQL 8.0数据目录时，会为`'root'@'localhost'`用户生成一个临时密码（除非使用`--initialize-insecure`，那样会创建无密码的root用户）。\nB) 如果`mysqld --initialize`是在前台运行且标准错误输出到屏幕，临时密码通常会作为一条`[Warning]`或`[Note]`信息直接显示在屏幕上 (B 正确)。\nC) 临时密码也会被记录到MySQL的错误日志文件中。错误日志文件的位置由`--log-error`参数指定（如果在初始化命令中或`my.cnf`中设置了），或者使用默认位置 (C 正确)。\n\n错误选项分析：\nA) 没有名为`mysql.install`的表，也不存在存储root密码的`root_pw`变量以这种方式暴露。\nD) 临时密码不会写入`/root/.my.cnf`文件。`.my.cnf`是MySQL的选项配置文件。\nE) `SHOW PASSWORD`命令用于加密一个给定的字符串，而不是显示现有用户的密码。并且，这需要在已登录MySQL的情况下执行，而此时我们正是需要密码来登录。\n\n**考点总结:**\n此题考察MySQL 8.0初始化数据目录后如何获取初始root用户的临时密码。主要途径是查看初始化命令的屏幕输出和MySQL错误日志。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住`mysqld --initialize`后的密码获取方式。区分“初始化时生成的临时密码”和“后续用户自己设置的密码”。\n\n**学习建议:**\n学习MySQL的初始化过程，特别是`mysqld --initialize`和`mysqld --initialize-insecure`命令的区别和作用。掌握如何定位MySQL错误日志文件。熟悉初始化后首次登录MySQL并修改root密码的步骤（使用`ALTER USER`命令）。"
    },
    {
        "question": "### 试题 75:\n\nChoose two. Identify two ways to significantly improve data security.",
        "selections": {
            "A": "Configure mysqld to run as the system admin account, such as root.",
            "B": "Use a private network behind a firewall.",
            "C": "Configure mysqld to use only networked disks.",
            "D": "Configure MySQL to have only one administrative account.",
            "E": "Configure mysqld to use only local disks or attached disks and to have its own account in the host system."
        },
        "answers": [
            "B",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n提升数据安全性的方法涉及网络、操作系统和MySQL自身配置等多个层面。\nB) 使用私有网络并将MySQL服务器置于防火墙之后：这限制了对MySQL服务器的网络访问，只允许来自受信任网络的连接，是重要的网络安全措施 (B 正确)。\nE) 配置`mysqld`使用本地或直连磁盘，并在主机系统上为其创建专用的、低权限的操作系统账户（如`mysql`用户）：使用专用账户运行`mysqld`服务遵循最小权限原则，即使服务被攻破，攻击者获得的权限也受限于该账户。使用本地或直连磁盘相对于网络磁盘（如NFS）可以减少网络相关的安全风险和依赖 (E 正确)。\n\n错误选项分析：\nA) 以系统管理员账户（如`root`）运行`mysqld`是极不安全的做法，会带来巨大风险。\nC) “只使用网络磁盘”本身不一定提升安全性，反而可能引入额外的网络依赖和安全考虑（如网络嗅探、NFS权限配置等）。安全性取决于网络磁盘的配置和管理。\nD) “只有一个管理账户”可能过于集中风险。通常建议根据职责分离原则创建多个具有不同管理权限的账户，并遵循最小权限原则。但如果这个“一个管理账户”指的是避免泛滥的、权限过高的账户，那么有一定的合理性，但表述不佳。更重要的是权限控制，而非数量。\n\n**考点总结:**\n此题考察提升MySQL数据安全性的综合措施。网络隔离（防火墙、私有网络）和操作系统层面的安全（专用低权限运行账户、安全的存储介质）是关键方面。\n\n**OCR中的分析“网络隔离最好，D的问题是administrator这个权限太大了，应该有多个administrative account, 每个只有部分权限”有一定的道理，但E选项结合了OS用户权限和磁盘选择，也是重要的安全实践。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n从多个层面思考数据安全：网络层、操作系统层、MySQL应用层。遵循安全的基本原则，如最小权限、纵深防御、职责分离。\n\n**学习建议:**\n全面学习MySQL安全最佳实践，包括：\n-   网络安全：防火墙、`bind-address`、SSL/TLS加密连接、禁用不必要的协议。\n-   操作系统安全：使用专用`mysql`用户运行服务、严格的文件系统权限、禁用不必要的OS服务。\n-   MySQL账户和权限管理：强密码策略、最小权限原则、角色管理、定期审计用户权限。\n-   数据加密：静态数据加密（TDE）、动态数据加密（SSL/TLS）、备份加密。\n-   定期打补丁和更新。\n-   应用安全：防范SQL注入等。"
    },
    {
        "question": "### 试题 76:\n\nWhich two are valid uses for binary logs on a MySQL instance?",
        "selections": {
            "A": "logging the duration and locks for all queries",
            "B": "replication",
            "C": "audit of all queries",
            "D": "point-in-time recovery",
            "E": "recording the order in which queries are issued"
        },
        "answers": [
            "B",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n二进制日志（binary logs）是MySQL中非常重要的日志类型，主要用于以下目的：\nB) 复制（Replication）：从服务器（副本）通过读取主服务器的二进制日志来复制数据更改，从而实现数据同步和负载均衡等 (B 正确)。\nD) 时间点恢复（Point-in-Time Recovery, PITR）：结合全量备份（如`mysqldump`或物理备份）和自备份以来产生的所有二进制日志，可以将数据库恢复到过去的任意一个精确时间点 (D 正确)。\n\n错误选项分析：\nA) 二进制日志记录的是导致数据更改的事件（语句或行更改），不直接记录所有查询的执行时长和锁信息。查询时长和锁信息通常由慢查询日志、Performance Schema或第三方监控工具提供。\nC) 二进制日志不用于审计所有查询。它主要记录修改数据的操作。要审计所有查询（包括SELECT），需要使用MySQL Enterprise Audit插件或通用查询日志（general query log，但后者对性能影响较大）。\nE) 二进制日志确实按顺序记录了导致数据更改的事件，但其主要用途不是简单地“记录查询发出的顺序”，而是用于复制和恢复。如果说“记录数据更改事件的顺序”则更准确。\n\n**考点总结:**\n此题考察MySQL二进制日志的两个核心用途：复制和时间点恢复。这是DBA必须掌握的基础知识。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住binlog的两大核心功能。将binlog与其他类型的日志（如错误日志、慢查询日志、通用查询日志、审计日志）区分开来。\n\n**学习建议:**\n深入理解二进制日志的格式（STATEMENT, ROW, MIXED）、内容和管理。学习如何配置和使用二进制日志进行复制（主从复制、组复制等）。掌握基于二进制日志进行时间点恢复的完整步骤。了解与二进制日志相关的工具（如`mysqlbinlog`）。"
    },
    {
        "question": "### 试题 77:\n\nChoose two. Which two are features of MySQL Enterprise Firewall?",
        "selections": {
            "A": "blocking of potential threats by configuring pre-approved whitelists",
            "B": "modifying SQL statement dynamically with substitutions",
            "C": "recording incoming SQL statement to facilitate the creation of a whitelist of permitted commands",
            "D": "automatic locking of user accounts who break your firewall",
            "E": "provides stateless firewall access to TCP/3306"
        },
        "answers": [
            "A",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL Enterprise Firewall 是一种应用层防火墙，用于保护MySQL服务器免受未授权SQL语句的攻击。\nA) 通过配置预先批准的SQL语句白名单来阻止潜在威胁：这是防火墙的核心功能。在`PROTECTING`模式下，只有在白名单中（或与白名单中的模式匹配）的SQL语句才允许执行 (A 正确)。\nC) 记录传入的SQL语句以帮助创建允许命令的白名单：防火墙具有`RECORDING`模式，在此模式下，它会记录特定用户执行的所有SQL语句的规范化形式，DBA可以审查这些记录并将其选入白名单 (C 正确)。\n\n错误选项分析：\nB) 防火墙不动态修改SQL语句并替换内容。它要么允许语句通过，要么阻止语句执行。\nD) 防火墙在`PROTECTING`模式下会阻止不符合白名单的语句，并可能记录这些事件。但它不直接“自动锁定用户账户”。账户锁定是MySQL用户账户管理的功能（`ALTER USER ... ACCOUNT LOCK`）。\nE) “无状态防火墙访问TCP/3306”描述更像是网络层防火墙的行为。MySQL Enterprise Firewall是应用层的、有状态的（因为它维护白名单和用户模式）。\n\n**考点总结:**\n此题考察MySQL Enterprise Firewall的关键特性，特别是其基于白名单的防护机制和用于生成白名单的记录模式。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解MySQL Enterprise Firewall的核心工作原理：学习（RECORDING模式）-> 定义白名单 -> 防护（PROTECTING模式）。\n\n**学习建议:**\n学习MySQL Enterprise Firewall的部署和配置流程。掌握不同操作模式（`OFF`, `DETECTING`, `RECORDING`, `PROTECTING`）的含义和用途。了解如何管理用户防火墙配置文件和白名单规则。熟悉相关的存储过程和Information Schema视图。"
    },
    {
        "question": "### 试题 78:\n\nChoose three. Which three methods display the complete table definition of an InnoDB table?",
        "selections": {
            "A": "hexdump -v -C table.frm",
            "B": "REPAIR TABLE table USE_FRM",
            "C": "mysqldump --no-data schema table",
            "D": "Query the Information Schema.",
            "E": "SELECT * FROM table1\\G",
            "F": "SHOW CREATE TABLE table"
        },
        "answers": [
            "C",
            "D",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n获取InnoDB表的完整定义（包括列、数据类型、索引、约束、表选项等）有多种方法。\nC) `mysqldump --no-data schema_name table_name`：`mysqldump`配合`--no-data`（或`-d`）选项可以只导出表的结构定义（`CREATE TABLE`语句），而不包含数据。指定数据库名和表名可以精确到特定表 (C 正确)。\nD) 查询`INFORMATION_SCHEMA`：`INFORMATION_SCHEMA`数据库包含许多元数据表（如`TABLES`, `COLUMNS`, `STATISTICS`, `TABLE_CONSTRAINTS`, `KEY_COLUMN_USAGE`等），通过组合查询这些表可以获取表的完整定义信息。虽然不如`SHOW CREATE TABLE`直接，但它提供了结构化的元数据访问 (D 正确)。\nF) `SHOW CREATE TABLE table_name;`：这个SQL命令会返回一个包含完整`CREATE TABLE`语句的结果，该语句可以用来重新创建具有相同定义的表。这是获取表定义最直接和常用的方法 (F 正确)。\n\n错误选项分析：\nA) `hexdump -v -C table.frm`：在MySQL 8.0之前，MyISAM和部分其他引擎的表定义存储在`.frm`文件中。`hexdump`可以查看文件的二进制内容，但这不是一个易于理解或“显示完整定义”的方式，且对InnoDB表（其定义主要在数据字典中）不适用。MySQL 8.0后，`.frm`文件已废弃，所有元数据在数据字典中。\nB) `REPAIR TABLE table_name USE_FRM`：这是一个修复表的命令，用于在`.frm`文件损坏或丢失时尝试从数据字典恢复（或反之），不是显示表定义的标准方法。\nE) `SELECT * FROM table_name\\G`：这个命令用于查询并显示表中的所有数据，以垂直格式展示。它不显示表的结构定义。\n\n**考点总结:**\n此题考察获取MySQL表结构定义（特别是InnoDB表）的常用方法。`SHOW CREATE TABLE`是最直接的，`mysqldump --no-data`用于导出结构，查询`INFORMATION_SCHEMA`提供底层元数据访问。\n\n**OCR答案提示“8里面没有frm”是正确的，这使得A和B选项在MySQL 8.0+环境中更不适用。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住`SHOW CREATE TABLE`是查看表定义最方便的命令。了解`mysqldump`在结构导出方面的能力。知道`INFORMATION_SCHEMA`是元数据的标准访问接口。\n\n**学习建议:**\n熟练掌握`SHOW CREATE TABLE`命令。学习`mysqldump`的各种选项，特别是与结构和数据导出相关的。熟悉`INFORMATION_SCHEMA`中与表定义相关的核心表及其列，练习通过查询它们来获取表信息。了解MySQL 8.0数据字典对元数据存储的改变（不再依赖`.frm`文件）。"
    },
    {
        "question": "### 试题 79:\n\nWhich two statements are true about the `mysql_config_editor` program?",
        "selections": {
            "A": "It provides an interface to change my.cnf files.",
            "B": "It manages the configuration of client programs. (only work for mysql client)",
            "C": "It can move datadir to a new location.",
            "D": "It manages the configuration of user privileges for accessing the server.",
            "E": "It will use client options by default unless you provide --login-path. (mysql = mysql --login-path=client)",
            "F": "It manages the configuration of the MySQL Firewall feature.",
            "G": "It can be used to create and edit SSL certificates and log locations."
        },
        "answers": [
            "B",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysql_config_editor`是一个用于创建和管理加密的登录路径选项文件（通常是`~/.mylogin.cnf`）的工具。这个文件允许MySQL客户端程序（如`mysql`, `mysqldump`等）使用预存的、加密的连接参数（如主机、用户、密码、端口等）通过`--login-path`选项进行连接。\nB) 它管理客户端程序的配置（通过创建登录路径）。虽然“only work for mysql client”这个括号里的说明可能不完全精确（其他客户端程序如果支持读取`.mylogin.cnf`和`--login-path`也可以使用），但其主要目的是为客户端提供安全的连接参数存储 (B 正确)。\nE) 如果`.mylogin.cnf`文件中存在一个名为`client`的默认登录路径，并且客户端程序在启动时没有指定`--login-path`，那么客户端可能会尝试使用这个`client`登录路径下的选项。或者更一般地说，客户端程序通常会按一定顺序查找选项（命令行 -> `~/.mylogin.cnf`（如果指定`--login-path`）-> 选项文件 -> 环境变量 -> 内建默认值）。`mysql_config_editor`创建的`.mylogin.cnf`中的条目（登录路径）只有在被客户端明确通过`--login-path`引用时才会被使用。然而，这个选项的表述“unless you provide --login-path”暗示了某种默认行为。如果`mysql = mysql --login-path=client`这部分是解释，它表明`mysql`客户端默认会查找`client`登录路径。 (E 的表述可能有些混淆，但核心是`mysql_config_editor`创建的登录路径需要客户端通过`--login-path`使用，或者客户端有某种默认查找行为）。更准确地说，`mysql_config_editor`本身不直接“使用”选项，而是创建供客户端使用的选项。\n\n错误选项分析：\nA) 它不直接修改`my.cnf`文件。它创建和管理的是一个独立的、加密的`.mylogin.cnf`文件。\nC) 它不用于移动`datadir`。`datadir`是服务器配置，通过`my.cnf`或服务器启动参数设置。\nD) 它不管理用户权限。用户权限是通过`GRANT`/`REVOKE`等SQL命令在服务器端管理的。\nF) 它不管理MySQL Enterprise Firewall的配置。防火墙配置通过特定的存储过程和系统表管理。\nG) 它不用于创建或编辑SSL证书。SSL证书是单独生成和管理的。它可以在登录路径中存储SSL相关的连接参数（如证书文件路径），但不能创建证书本身。日志位置通常在`my.cnf`或服务器启动参数中配置。\n\n**考点总结:**\n此题考察`mysql_config_editor`工具的主要功能：安全地存储和管理MySQL客户端连接参数（登录路径）。\n\n**答案E的进一步解释:** MySQL客户端程序在查找连接选项时，如果`--login-path`选项被使用，它会优先从`.mylogin.cnf`的指定登录路径中获取。如果`.mylogin.cnf`中存在一个名为 `[client]` 的组，并且没有其他更优先的选项（如命令行参数）覆盖，那么这个 `[client]` 组中的选项可能会被所有客户端程序作为默认选项使用。所以E选项可以理解为，如果你不指定特定的登录路径，客户端可能会尝试使用一个默认的（比如名为`client`的）登录路径配置。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住`mysql_config_editor`的核心功能是“加密存储客户端连接参数”。将其与其他配置工具或管理功能区分开。\n\n**学习建议:**\n学习如何使用`mysql_config_editor`命令（如`set`, `remove`, `print`, `reset`子命令）来创建、修改、查看和删除登录路径。了解`.mylogin.cnf`文件的作用和安全性。熟悉MySQL客户端程序如何通过`--login-path`选项使用这些预存的连接参数。"
    },
    {
        "question": "### 试题 80:\n\nChoose three. A MySQL server is monitored using MySQL Enterprise Monitor's agentless installation. Which three features are available with this installation method?",
        "selections": {
            "A": "MySQL Replication monitoring",
            "B": "security-related advisor warnings",
            "C": "CPU utilization",
            "D": "disk usage and disk characteristics including disk advisors warnings",
            "E": "MySQL Query Analysis data",
            "F": "operating system memory utilization",
            "G": "network-related information and network characteristics"
        },
        "answers": [
            "A",
            "B",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL Enterprise Monitor (MEM) 的“无代理安装”（agentless installation）指的是不直接在被监控的MySQL主机上安装MEM Agent，而是通过远程连接从MySQL服务器本身获取信息。这种方式收集的信息范围会受到限制，主要依赖于MySQL服务器通过SQL接口暴露的状态变量、Performance Schema、Information Schema等。\nA) MySQL复制监控：MEM可以通过查询复制相关的状态变量（如`SHOW REPLICA STATUS`或`SHOW SLAVE STATUS`的输出）和Performance Schema中的复制相关表来监控复制的健康状况、延迟等。这些信息可以通过远程SQL连接获取 (A 正确)。\nB) 安全相关的顾问警告：MEM的顾问功能可以分析MySQL的配置和状态，并根据安全最佳实践给出建议和警告。许多安全相关的配置（如密码策略、用户权限、网络配置等）可以通过查询系统表和变量来评估，因此无代理模式也可以提供一些安全相关的顾问警告 (B 正确)。\nE) MySQL查询分析数据：如果MySQL服务器配置为将查询信息记录到Performance Schema的语句摘要表（如`events_statements_summary_by_digest`）或慢查询日志（如果可以远程访问或配置为写入表），MEM可以通过远程查询这些数据来进行查询分析 (E 正确)。\n\n错误选项分析（通常需要Agent来收集操作系统级别的信息）：\nC) CPU利用率：操作系统级别的CPU利用率通常需要Agent直接在主机上收集。无代理模式很难精确获取实时的、详细的OS级CPU使用情况。\nD) 磁盘使用和特性，包括磁盘相关的顾问警告：详细的磁盘I/O统计、文件系统使用率、磁盘硬件特性等通常需要Agent从操作系统层面收集。\nF) 操作系统内存利用率：同CPU，OS级别的内存使用情况需要Agent收集。\nG) 网络相关信息和特性：详细的网络流量统计、网络接口状态等OS级别信息通常也需要Agent。\n\n**考点总结:**\n此题考察MySQL Enterprise Monitor无代理监控模式下可获取的信息范围。核心在于区分哪些信息可以纯粹通过MySQL服务器的SQL接口远程获取，哪些信息需要操作系统级别的访问（通常由Agent提供）。\n\n**OCR答案提示“无代理的情况下，只能监控mysql数据库自己的状态”是一个很好的概括。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n思考信息来源：如果信息直接存在于MySQL服务器内部（状态变量、系统表、P_S、I_S），则无代理模式可能获取到。如果信息是操作系统层面的（CPU、内存、磁盘、网络细节），则通常需要Agent。\n\n**学习建议:**\n了解MySQL Enterprise Monitor的不同部署模式（有代理 vs 无代理）及其各自的优缺点和监控范围。熟悉MEM Agent的作用和它能收集的额外信息类型。学习哪些MySQL内部组件（如Performance Schema, Information Schema, sys schema, status variables）可以用于远程监控。"
    },
    {
        "question": "### 试题 81:\n\nChoose four. Which four are types of information stored in the MySQL data dictionary?",
        "selections": {
            "A": "server runtime configuration",
            "B": "server configuration rollback",
            "C": "performance metrics",
            "D": "stored procedure definitions",
            "E": "InnoDB buffer pool LRU management data",
            "F": "view definitions",
            "G": "table definitions.",
            "H": "access control lists"
        },
        "answers": [
            "D",
            "F",
            "G",
            "H"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题10和试题11内容相似，要求选出存储在MySQL数据字典中的信息类型。\nD) 存储过程定义 (Stored procedure definitions)：包括存储过程、函数、触发器等的定义。\nF) 视图定义 (View definitions)：视图的SQL创建语句和结构。\nG) 表定义 (Table definitions)：包括表的列、索引、约束等元数据。\nH) 访问控制列表 (Access control lists)：用户账户、角色及其权限信息。\n\n无效选项的理由同试题10和11。\n\n**考点总结:**\n再次考察对MySQL 8.0数据字典存储内容的理解。数据字典是数据库对象的元数据中心，存储的是描述数据库结构、定义和管理的信息，而非运行时状态或性能数据。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复出现的考点需要重点记忆。理解数据字典的核心功能是存储“关于数据的数据”（元数据）。排除那些描述服务器内部操作细节、瞬时状态或性能监控数据的选项。\n\n**学习建议:**\n复习MySQL数据字典所包含的关键元数据类别。可以参考官方文档中关于数据字典的章节，明确其存储范围。对比MySQL 8.0之前版本（依赖.frm文件和mysql系统表）的元数据管理方式，有助于理解数据字典的改进和重要性。"
    },
    {
        "question": "### 试题 82:\n\nChoose two. Examine this statement: `mysql> DROP ROLE r_role1, r_role2;`\nWhich two are true?",
        "selections": {
            "A": "You must revoke r_role1 and r_role2 from all users and other roles before dropping the roles.",
            "B": "You must revoke all privileges from r_role1 and r_role2 before dropping the roles.",
            "C": "It fails if at least one of the roles does not exist.",
            "D": "Existing connections can continue to use the roles' privileges until they reconnect.",
            "E": "It fails if you do not have the ADMIN OPTION of the roles r_role1 and r_role2.",
            "F": "It fails if any of the roles is specified in the mandatory_roles variable."
        },
        "answers": [
            "C",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`DROP ROLE`语句用于删除一个或多个角色。\nC) 如果尝试删除的角色中至少有一个不存在，`DROP ROLE`语句会失败并报错 (C 正确)。可以使用`IF EXISTS`子句来避免因角色不存在而报错，例如`DROP ROLE IF EXISTS r_role1, r_role2;`。\nF) 如果要删除的角色被设置在`mandatory_roles`系统变量中（或者MySQL 8.0.16+的`activate_all_roles_on_login`变量行为类似，强制激活某些角色），则尝试删除这些角色会失败，因为它们是强制性角色，不能轻易移除 (F 正确)。\n\n错误选项分析：\nA) 删除角色时，不需要预先从所有用户或其他角色中撤销该角色。当角色被删除后，之前授予该角色的用户将不再拥有通过该角色获得的权限。\nB) 角色本身是权限的集合，不是直接从角色撤销权限。权限是从用户或角色撤销，或者修改角色包含的权限。删除角色前不需要对其包含的权限进行操作。\nD) 当角色被删除后，它所代表的权限集合就不存在了。对于已建立的连接，如果用户的权限是基于这个被删除的角色，那么这些权限会立即失效。用户不需要重新连接才能使更改生效。权限检查是动态的。\nE) 删除角色需要`DROP ROLE`权限，或者拥有对`mysql`数据库的全局`CREATE ROLE`和`DROP ROLE`权限。`WITH ADMIN OPTION`是用于将角色授予其他用户的权限，与删除角色本身无关。\n\n**考点总结:**\n此题考察`DROP ROLE`语句的行为和限制。关键在于角色不存在或被系统强制使用（如`mandatory_roles`）时会导致删除失败。理解角色删除后对现有用户权限的影响。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n考虑SQL DDL语句的常见行为，例如操作不存在的对象时是否报错。了解特殊系统变量（如`mandatory_roles`）如何影响对象管理。\n\n**学习建议:**\n学习MySQL角色管理的完整生命周期，包括创建（`CREATE ROLE`）、授权（`GRANT`权限给角色，`GRANT`角色给用户）、撤销（`REVOKE`）、删除（`DROP ROLE`）、重命名（`RENAME ROLE`）。了解与角色相关的系统变量和权限（如`DROP ROLE`权限）。熟悉`IF EXISTS`和`IF NOT EXISTS`等子句在DDL操作中的用法。"
    },
    {
        "question": "### 试题 83:\n\nChoose two. Which two are true about differences between logical and physical upgrades of MySQL databases?",
        "selections": {
            "A": "Logical upgrades are much faster because they do not require restarting the mysqld process.",
            "B": "Physical upgrades are much faster because they do not require restarting the mysqld process.",
            "C": "Physical upgrades are performed for current instances on bare metal deployments, whereas logical upgrades are used for virtual machines or containerized instances.",
            "D": "Post-upgrade table storage requirements after physical upgrades are usually smaller than that after logical upgrades.",
            "E": "Post-upgrade table storage requirements after logical upgrades are usually smaller than that after physical upgrades.",
            "F": "Physical upgrades leave data in place, whereas logical upgrades require data to be restored from mysqldump-type backups taken before the upgrades."
        },
        "answers": [
            "E",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL升级主要有两种方式：物理升级（通常是原地升级，in-place upgrade）和逻辑升级（通过导出/导入数据）。\nF) 物理升级（原地升级）通常是直接替换MySQL二进制文件，并在新版本的服务器上打开现有的数据文件。数据文件本身“保留在原地”，服务器在新版本下处理可能的数据格式或元数据更改。逻辑升级则涉及使用旧版本`mysqldump`（或类似工具）导出数据，然后在全新安装的新版本MySQL上导入这些数据 (F 正确)。\nE) 逻辑升级（导出再导入）的过程实际上是对数据进行了一次“重整”。例如，表中的碎片会被消除，索引可能会被更有效地重建。这通常会导致升级后表的存储需求（物理大小）比原始表或物理升级后的表要小，因为数据更紧凑 (E 正确)。\n\n错误选项分析：\nA) 逻辑升级（导出/导入）通常比物理升级慢得多，因为它涉及全量数据的导出和导入，以及索引重建。物理升级（原地升级）虽然也需要重启`mysqld`进程（通常多次），但其核心数据处理过程可能更快。\nB) 物理升级（原地升级）通常需要停止旧版本`mysqld`，替换二进制文件，然后启动新版本`mysqld`进行数据字典升级等步骤。这个过程肯定涉及重启。\nC) 物理升级和逻辑升级的选择与部署环境（裸金属、虚拟机、容器）没有直接的必然联系。两者都可以在各种环境中进行。选择哪种方式更多取决于升级的复杂度、可接受的停机时间、数据量、版本跨度等因素。\nD) 如E所述，逻辑升级后存储需求通常更小。物理升级保留了原始数据文件的碎片等，因此存储需求可能不会显著减小，甚至可能因为新版本的元数据等略有增加。\n\n**考点总结:**\n此题考察MySQL物理升级和逻辑升级的主要区别，特别是在数据处理方式、升级速度和升级后存储空间方面的差异。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解物理升级和逻辑升级的基本流程。物理升级是“就地改造”，逻辑升级是“推倒重建”。从这个角度思考它们对数据、速度和空间的影响。\n\n**学习建议:**\n学习MySQL的不同升级路径和方法。掌握原地升级（in-place upgrade）和逻辑升级（logical upgrade）的步骤、优缺点、适用场景和注意事项。了解`mysql_upgrade`工具（在MySQL 8.0中已集成到服务器启动过程中）的作用。熟悉跨大版本升级的挑战和最佳实践。"
    },
    {
        "question": "### 试题 84:\n\nChoose two. On examination, your MySQL installation datadir has become recursively world read/write/executable. What are two major concerns of running an installation with incorrect file privileges?",
        "selections": {
            "A": "Extra startup time would be required for the MySQL server to reset the privileges.",
            "B": "MySQL binaries could be damaged, deleted, or altered.",
            "C": "SQL injections could be used to insert bad data into the database.",
            "D": "Data files could be deleted.",
            "E": "Users could overwrite configuration files."
        },
        "answers": [
            "D",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题41内容几乎完全相同，只是选项顺序可能不同。\nD) 数据文件可能被删除：所有用户都有写权限，任何用户都可能删除或损坏数据文件 (D 正确)。\nE) 用户可能覆盖配置文件：如果配置文件（如`my.cnf`或数据目录下的`mysqld-auto.cnf`）权限也过于宽松，可能被未授权修改 (E 正确)。\n\n错误选项分析同试题41。\nB) 题目特指`datadir`（数据目录）的权限问题。MySQL二进制文件通常在`basedir`（安装目录）下，其权限是另一个独立的关注点。\n\n**考点总结:**\n再次强调不正确的文件系统权限（特别是对MySQL数据目录）所带来的直接安全风险，主要体现在数据和配置的完整性与可用性受到威胁。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复出现的考点应加强记忆。关注权限问题对数据和配置的直接影响。\n\n**学习建议:**\n参考试题41的学习建议。务必理解操作系统文件权限的重要性，并掌握如何为MySQL设置安全的权限。"
    },
    {
        "question": "### 试题 85:\n\nChoose two. You made some table definition changes to a schema in your MySQL Server.\nWhich two statements reflect how MySQL Server handles the table definition changes?",
        "selections": {
            "A": "MySQL Server stores a copy of the serialized data in the InnoDB user tablespace.",
            "B": "MySQL writes SDI to the binary log for distributed backups.",
            "C": "MySQL implicitly executes FLUSH TABLES and stores a snapshot backup of the metadata.",
            "D": "The metadata is serialized in (SDI).",
            "E": "MySQL keeps InnoDB metadata changes in .sdi files in datadir."
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL 8.0引入了事务性的数据字典，并使用SDI（Serialized Dictionary Information）来存储对象的元数据。\nD) 表定义的元数据被序列化为SDI格式。这是一种紧凑的JSON格式，包含了关于表、列、索引等所有定义信息 (D 正确)。\nA) 对于InnoDB表，其SDI数据存储在该表所属的表空间文件（`.ibd`文件）内部。这意味着每个InnoDB表空间文件都包含了自身的完整元数据定义。这里的“InnoDB user tablespace”可以理解为存储用户表数据的表空间（无论是独立表空间还是通用表空间） (A 正确)。\n\n错误选项分析：\nB) SDI信息不直接写入二进制日志。二进制日志记录的是导致数据或结构更改的SQL语句或行事件，而不是元数据的序列化表示。分布式备份（如使用复制）依赖于这些事件。\nC) 修改表定义（如`ALTER TABLE`）是一个DDL操作，它会更新数据字典。MySQL不一定会在每次DDL后隐式执行`FLUSH TABLES`或创建元数据快照备份。DDL操作本身是事务性的（在支持的引擎如InnoDB上）。\nE) 对于InnoDB表，SDI存储在表空间文件内部，而不是作为单独的`.sdi`文件存放在数据目录（datadir）中。对于使用其他存储引擎（如MyISAM，在8.0中仍支持但已废弃.frm）的表，MySQL 8.0可能会为它们创建独立的`.sdi`文件来存储元数据，但InnoDB的行为是SDI内嵌于表空间。\n\n**考点总结:**\n此题考察MySQL 8.0中表定义元数据的存储方式，特别是SDI的概念以及InnoDB表SDI的存放位置。核心是元数据序列化和内嵌于InnoDB表空间。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住MySQL 8.0数据字典和SDI是元数据管理的核心。理解SDI如何使得元数据与数据更紧密地结合（特别是对于InnoDB）。\n\n**学习建议:**\n学习MySQL 8.0数据字典的架构和优势。了解SDI（Serialized Dictionary Information）的格式（JSON）和作用。掌握不同存储引擎（特别是InnoDB）如何存储和管理SDI信息。理解这与旧版本（依赖`.frm`文件）的元数据管理的区别。"
    },
    {
        "question": "### 试题 86:\n\nChoose three. Which three settings control global buffers shared by all threads on a MySQL server?",
        "selections": {
            "A": "tmp_table_size",
            "B": "innodb_buffer_pool_size",
            "C": "table_open_cache",
            "D": "sort_buffer_size",
            "E": "key_buffer_size",
            "F": "read_buffer_size"
        },
        "answers": [
            "B",
            "C",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL服务器的内存缓冲区分为全局缓冲区（所有线程共享）和会话级缓冲区（每个连接线程独有）。\nB) `innodb_buffer_pool_size`：InnoDB存储引擎用于缓存数据和索引的主缓冲池。这是一个非常重要的全局共享缓冲区 (B 正确)。\nE) `key_buffer_size`：MyISAM存储引擎用于缓存索引块的缓冲区。这也是一个全局共享缓冲区（如果使用MyISAM表） (E 正确)。\nC) `table_open_cache`（或`table_definition_cache`）：`table_open_cache`控制服务器可以保持打开状态的表文件描述符的数量。虽然不直接是“数据”缓冲区，但它是一个全局共享的缓存结构，用于缓存打开表的元数据和状态，影响所有线程对表的访问性能。`table_definition_cache`则缓存表定义。这些可以广义地视为全局共享的缓存/缓冲机制 (C 正确，这里指`table_open_cache`作为一种全局共享资源)。\n\n错误选项分析（这些通常是会话级缓冲区）：\nA) `tmp_table_size`：控制内存中创建的内部临时表（MEMORY引擎）的最大大小。这是一个会话级设置，每个线程在需要时分配。\nD) `sort_buffer_size`：用于排序操作（如`ORDER BY`, `GROUP BY`）的缓冲区大小。每个需要排序的线程会分配自己的排序缓冲区，是会话级的。\nF) `read_buffer_size`：用于顺序扫描表时读取数据的缓冲区大小。每个进行顺序扫描的线程会分配，是会话级的。（注意：`read_rnd_buffer_size`用于随机读，也是会话级）。\n\n**考点总结:**\n此题考察对MySQL内存管理中全局共享缓冲区和会话级缓冲区的区分。InnoDB缓冲池和MyISAM键缓冲是典型的全局数据/索引缓存。表缓存（打开表缓存、表定义缓存）也是全局共享的。\n\n**OCR中对各个缓冲区的解释基本正确。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分哪些内存区域是所有连接共享的（如缓冲池、键缓冲、查询缓存（已废弃）），哪些是每个连接单独分配的（如排序缓冲、连接缓冲、读缓冲、临时表内存）。\n\n**学习建议:**\n学习MySQL内存架构，包括全局缓冲区和线程（会话）级缓冲区的种类、作用和配置参数。理解如何根据服务器负载和可用内存来合理配置这些缓冲区，以优化性能。特别是`innodb_buffer_pool_size`的调优至关重要。"
    },
    {
        "question": "### 试题 87:\n\nChoose two. You are using `mysqlcheck` for server maintenance. Which two statements are true?",
        "selections": {
            "A": "The mysqlcheck --check --all-databases command takes table write locks while performing a series of checks.",
            "B": "The mysqlcheck --repair --all-databases command can repair an InnoDB corrupted table.",
            "C": "The mysqlcheck --analyze --all-databases command performs a series of checks to spot eventual table corruptions.",
            "D": "The mysqlcheck command can be renamed mysqlrepair so that it repairs tables by default.",
            "E": "The mysqlcheck --optimize --all-databases command reclaims free space from table files."
        },
        "answers": [
            "D",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlcheck`是一个客户端工具，用于检查、修复、分析和优化表。它实际上是`REPAIR TABLE`, `ANALYZE TABLE`, `OPTIMIZE TABLE`, `CHECK TABLE`等SQL语句的命令行接口。\nD) `mysqlcheck`程序如果被重命名（或作为符号链接）为`mysqlrepair`，则其默认操作会变为修复表（相当于执行`mysqlcheck --repair`） (D 正确)。\nE) `mysqlcheck --optimize --all-databases`命令（等同于对所有表执行`OPTIMIZE TABLE`）会尝试回收表中的未使用空间并整理碎片，从而可能减小表文件的大小并提高性能 (E 正确)。\n\n错误选项分析：\nA) `mysqlcheck --check`（或`CHECK TABLE`）通常对表加读锁（READ lock）进行检查，以允许其他会话读取数据，但阻止写入。它不一定总是加写锁（WRITE lock），除非检查操作本身需要（例如，某些引擎的特定检查级别）。\nB) `mysqlcheck --repair`（或`REPAIR TABLE`）主要用于修复MyISAM表。对于InnoDB表，它通常只是报告表是InnoDB类型，并建议使用InnoDB自身的崩溃恢复机制或更高级的恢复方法（如从备份恢复）。InnoDB表损坏通常不能通过简单的`REPAIR TABLE`修复。\nC) `mysqlcheck --analyze`（或`ANALYZE TABLE`）用于更新表的键分布统计信息（如索引基数），以帮助查询优化器生成更好的执行计划。它不直接“检查表损坏”。检查损坏是`--check`选项的功能。\n\n**考点总结:**\n此题考察对`mysqlcheck`工具不同操作（`--check`, `--repair`, `--analyze`, `--optimize`）及其对应SQL语句功能的理解。注意不同存储引擎对这些操作的支持程度和行为差异（特别是InnoDB与MyISAM）。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n将`mysqlcheck`的选项与对应的SQL管理语句（`CHECK TABLE`, `REPAIR TABLE`, `ANALYZE TABLE`, `OPTIMIZE TABLE`）联系起来。理解这些语句对不同存储引擎（尤其是InnoDB和MyISAM）的适用性和效果。\n\n**学习建议:**\n学习使用`mysqlcheck`客户端工具进行表维护。掌握其常用选项（`--all-databases`, `--databases`, `--tables`, `--check`, `--repair`, `--analyze`, `--optimize`, `--auto-repair`等）。了解不同存储引擎的维护需求和方法。特别是对于InnoDB表，理解其崩溃恢复机制和通常不需要（也不能有效）使用`REPAIR TABLE`的原因。"
    },
    {
        "question": "### 试题 88:\n\nWhich two MySQL Server accounts are locked by default?",
        "selections": {
            "A": "any new ROLE accounts",
            "B": "any user created without a password",
            "C": "any internal system accounts",
            "D": "any user created with a username, but missing the host name"
        },
        "answers": [
            "A",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题64内容几乎完全相同，只是选项顺序和其中一个错误选项的表述略有不同。\nA) 新创建的角色（ROLE accounts）本身不能用于登录，它们是权限集合，从这个意义上讲可以视为“锁定的”（不可直接登录） (A 正确)。\nC) MySQL内部系统账户（如`mysql.sys`, `mysql.session`, `mysql.infoschema`等）通常被设计为不能从外部登录，或具有极受限的权限，可被视为默认“锁定” (C 正确)。\n\n错误选项分析同试题64。\n(OCR中试题64的E选项是“any user created without a password”，本题的B选项与之相同。试题64的D选项是“any user set as DEFINER for stored programs”，本题没有这个选项，而是有一个选项E“any user set as DEFINER for stored programs”，但它被标记为错误）。\n\n**考点总结:**\n再次强调对MySQL中不同类型账户及其默认登录或使用状态的理解。核心是区分可用于客户端登录的用户账户和用于其他目的（如权限聚合、系统内部操作）的账户。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复的考点应引起重视。如果“锁定”指“不能用于客户端直接登录”，则角色和内部系统账户符合这个描述。\n\n**学习建议:**\n参考试题64的学习建议。重点理解用户账户、角色、系统账户在MySQL安全模型中的不同角色和行为。"
    },
    {
        "question": "### 试题 89:\n\nChoose three. Your MySQL server is running on the Microsoft Windows platform.\nWhich three local connection protocols are available to you?",
        "selections": {
            "A": "UDP",
            "B": "shared memory",
            "C": "SOCKET",
            "D": "named pipes",
            "E": "X Protocol",
            "F": "TCP/IP"
        },
        "answers": [
            "B",
            "D",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n在Windows平台上，MySQL支持以下本地连接协议：\nB) 共享内存（Shared Memory）：如果服务器启用了共享内存连接，客户端可以使用此协议进行高效的本地连接 (B 正确)。\nD) 命名管道（Named Pipes）：这是Windows上另一种常用的本地进程间通信机制，MySQL支持通过命名管道进行连接 (D 正确)。\nF) TCP/IP：即使是本地连接，也可以通过TCP/IP连接到`localhost`或`127.0.0.1`。这在所有平台上都可用（只要网络栈启用） (F 正确)。\n\n错误选项分析：\nA) UDP：MySQL不使用UDP进行标准客户端-服务器连接。\nC) SOCKET（Unix域套接字）：这是类Unix系统（如Linux, macOS）上用于本地连接的机制，在Windows上通常不可用或不作为标准MySQL连接方式。\nE) X Protocol：X Protocol是一种新的MySQL通信协议（用于MySQL Shell和X DevAPI），它也运行在TCP/IP之上，或者可以使用本地套接字/管道。但它本身不是一个独立的“本地连接协议”类型，而是构建在现有传输层之上的应用层协议。题目问的是连接“协议”，TCP/IP是其基础。\n\n**考点总结:**\n此题考察在Windows平台上MySQL支持的本地连接方式。主要是TCP/IP（到本地地址）、命名管道和共享内存。\n\n**OCR答案提示“在windows上没有socket”是正确的。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分不同操作系统平台支持的本地连接机制。Windows有其特有的IPC方式（命名管道、共享内存），而类Unix系统常用Unix套接字。\n\n**学习建议:**\n学习MySQL在不同操作系统上的安装和配置差异。了解如何启用和使用Windows上的命名管道和共享内存连接。熟悉`--protocol`客户端选项以及与特定协议相关的其他连接参数（如`--pipe`, `--shared-memory-base-name`）。"
    },
    {
        "question": "### 试题 90:\n\nWhich two authentication plugins require the plain text client plugin (`mysql_clear_password`) for authentication to work?",
        "selections": {
            "A": "Windows Native authentication",
            "B": "PAM authentication",
            "C": "LDAP SASL authentication",
            "D": "LDAP authentication",
            "E": "SHA256 authentication",
            "F": "MySQL Native Password"
        },
        "answers": [
            "B",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题9内容几乎完全相同，只是选项顺序可能不同。\n客户端插件`mysql_clear_password`用于在客户端和服务器之间以明文形式传输密码，通常是当服务器端认证插件需要接收实际密码以进行验证时（例如，将其传递给外部认证系统如LDAP或PAM）。\nB) PAM认证插件：如果配置的PAM服务栈需要明文密码，则MySQL服务器端的PAM插件会要求客户端发送明文密码 (B 正确)。\nD) LDAP认证插件：如果配置为简单的LDAP绑定（Simple Bind），服务器端的LDAP插件通常需要从客户端接收明文密码 (D 正确)。\n\n错误选项分析同试题9。\n\n**考点总结:**\n再次考察MySQL认证插件中哪些需要客户端以明文形式发送密码。关键在于理解外部认证系统（如LDAP简单绑定、某些PAM模块）可能需要原始密码进行验证。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复的考点应熟记。明文密码传输通常与将认证委托给需要密码的外部系统有关。\n\n**学习建议:**\n参考试题9的学习建议。重点掌握需要`mysql_clear_password`的场景，并务必记住使用此插件时必须配合SSL/TLS加密连接以保护传输中的密码安全。"
    },
    {
        "question": "### 试题 91:\n\nChoose two. Which two statements are true about the data dictionary object cache?",
        "selections": {
            "A": "The dictionary object caches use a Least Recently Used (LRU) algorithm to manage entries in cache.",
            "B": "Character set and collation definition objects are not cached.",
            "C": "All dictionary object caches have a hard-coded size.",
            "D": "If the dictionary object cache becomes full, MySQL server will be unable to create any more tables/objects.",
            "E": "tablespace_definition_cache sets the number of tablespace objects that can be stored in the dictionary object cache."
        },
        "answers": [
            "A",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL 8.0的数据字典引入了对象缓存，以提高对常用元数据对象的访问性能。\nA) 数据字典对象缓存（如表定义缓存、存储过程缓存等）通常会使用某种缓存替换算法，如LRU（最近最少使用）或其变体，来管理缓存中的条目并在缓存满时逐出旧条目 (A 正确)。\nE) `tablespace_definition_cache` (MySQL 8.0.13前为`table_definition_cache`的一部分，8.0.13后独立) 是一个系统变量，用于设置可以缓存的表空间定义对象的数量。这是数据字典对象缓存大小配置的一个例子 (E 正确)。类似地，`table_definition_cache`控制表定义对象的缓存数量，`stored_routine_cache`控制存储过程和函数定义的缓存数量等。\n\n错误选项分析：\nB) 字符集和校对规则的定义信息也是元数据的一部分，它们会被缓存以加速处理。说它们不被缓存是错误的。\nC) 数据字典对象缓存的大小不是硬编码的，而是可以通过相关的系统变量进行配置（如`table_definition_cache`, `tablespace_definition_cache`, `stored_routine_cache`等）。\nD) 如果数据字典对象缓存已满，当需要加载新的对象定义时，会根据替换算法（如LRU）逐出现有条目为新条目腾出空间。服务器仍然能够创建新的表/对象，只是访问未缓存对象的元数据时需要从磁盘（数据字典表）加载，性能可能略有下降。它不会导致无法创建新对象。\n\n**考点总结:**\n此题考察对MySQL 8.0数据字典对象缓存机制的理解，包括其缓存管理算法（如LRU）和可配置性（通过系统变量）。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解缓存的基本工作原理：加速访问常用数据，使用替换算法管理有限空间。将数据字典对象缓存视为一种性能优化机制。\n\n**学习建议:**\n学习MySQL 8.0数据字典的内部实现，特别是其对象缓存的设计。了解相关的配置参数（如`table_definition_cache`, `tablespace_definition_cache`, `stored_routine_cache`），以及如何根据工作负载调整它们的大小以优化元数据访问性能。监控与数据字典缓存相关的状态变量（如果有的话）可以帮助评估缓存效率。"
    },
    {
        "question": "### 试题 92:\n\nChoose two. Examine this statement, which executes successfully: `CREATE USER mary@192.0.2.100 IDENTIFIED BY 'P@SSw0rd' REQUIRE NONE PASSWORD EXPIRE;`\nWhich two are true?",
        "selections": {
            "A": "Mary must connect using the username 'mary@192.0.2.100'.",
            "B": "Mary requires no password to connect to the MySQL server.",
            "C": "Mary must connect from the client machine 192.0.2.100.",
            "D": "Mary cannot connect to the MySQL server until the DBA resets her password.",
            "E": "Mary cannot query data until she changes her password."
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`CREATE USER`语句定义了一个用户账户及其属性。\n- `mary@192.0.2.100`: 用户名为`mary`，允许从主机`192.0.2.100`连接。\n- `IDENTIFIED BY 'P@SSw0rd'`: 设置了用户的密码为`P@SSw0rd`。\n- `REQUIRE NONE`: 表示连接时不强制要求SSL/TLS加密（这是默认行为，`REQUIRE NONE`通常可以省略）。\n- `PASSWORD EXPIRE`: 强制用户在首次登录后必须更改密码。\n\nC) Mary必须从客户端机器`192.0.2.100`连接。用户账户的主机部分限制了允许连接的来源IP或主机名 (C 正确)。\nE) Mary在首次登录后，由于`PASSWORD EXPIRE`选项，她会被要求立即更改密码，然后才能执行其他操作（如查询数据） (E 正确)。\n\n错误选项分析：\nA) 用户名是`mary`，主机是`192.0.2.100`。连接时，用户名部分只需要提供`mary`。MySQL服务器会根据客户端的连接来源IP与账户定义中的主机部分进行匹配。\nB) 用户设置了密码`P@SSw0rd`，因此连接时需要提供密码。\nD) `PASSWORD EXPIRE`是要求用户自己更改密码，而不是DBA重置密码。\n\n**考点总结:**\n此题考察对`CREATE USER`语句中各个子句含义的理解，特别是主机限制 (`@host`) 和密码过期策略 (`PASSWORD EXPIRE`)。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细阅读`CREATE USER`语句的每一个部分，理解其对用户账户行为的限制。区分用户名和完整账户名（`user@host`）。\n\n**学习建议:**\n学习MySQL用户账户管理，包括`CREATE USER`, `ALTER USER`, `DROP USER`, `RENAME USER`等命令。掌握密码管理策略，如密码过期（`PASSWORD EXPIRE [DEFAULT|NEVER|INTERVAL N DAY]`）、密码历史、密码复杂度校验等。理解用户账户的主机部分如何限制连接来源，以及通配符（如`%`）的使用。"
    },
    {
        "question": "### 试题 93:\n\nChoose two. Examine this command, which executes successfully on InnoDB Cluster: `dba.dropMetadataSchema()`\nWhich two statements are true?",
        "selections": {
            "A": "The mysql_innodb_cluster_metadata schema is dropped from the instance where the connection was established.",
            "B": "Group Replication is still operational, but InnoDB Cluster must be reimported under MySQL Shell.",
            "C": "The command drops the mysql_innodb_cluster_metadata schema and re-creates it.",
            "D": "Connections driven by MySQL Router are not affected by the command.",
            "E": "The mysql_innodb_cluster_metadata schema is dropped from all reachable members of the cluster.",
            "F": "Group Replication will be dissolved and all metadata purged."
        },
        "answers": [
            "B",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`dba.dropMetadataSchema()`是MySQL Shell AdminAPI中用于删除InnoDB集群元数据模式（通常名为`mysql_innodb_cluster_metadata`）的命令。这个模式存储了集群的配置信息、拓扑结构等。\nE) 该命令会尝试从集群中所有可达的成员实例上删除元数据模式 (E 正确)。\nB) 删除元数据模式后，底层的组复制（Group Replication）本身可能仍然在运行（因为数据和GTID信息还在），但InnoDB集群的“集群管理”层面会失效，因为它依赖元数据模式来理解集群状态和进行管理操作。MySQL Shell将无法再识别或管理这个集群。要恢复集群管理，通常需要重新配置或“重新导入”集群的元数据到MySQL Shell中（或者更彻底地，重建集群） (B 正确)。\n\n错误选项分析：\nA) 元数据模式的删除会尝试在所有成员上进行，而不仅仅是建立连接的实例。\nC) 该命令只删除元数据模式，不会自动重新创建它。\nD) MySQL Router依赖于集群元数据来路由连接。如果元数据模式被删除，Router将无法获取最新的集群拓扑信息，其路由功能会受到严重影响，甚至可能无法正常工作。\nF) 组复制本身不一定会因为元数据模式的删除而立即解散，但集群的管理和协调会停止。元数据是集群管理的核心，不是所有成员的“所有元数据”都被清除，主要是指集群配置元数据。\n\n**考点总结:**\n此题考察对InnoDB集群元数据模式及其管理命令`dba.dropMetadataSchema()`作用的理解。删除元数据模式会破坏集群的管理层面，但底层组复制可能短暂存活。恢复通常需要重新配置。\n\n**OCR答案提示“Drops the Metadata Schema”是正确的。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解InnoDB集群元数据模式的重要性——它是集群管理和协调的中心。思考删除它会对集群的哪些层面产生影响。\n\n**学习建议:**\n学习MySQL Shell AdminAPI中与InnoDB集群元数据管理相关的命令，如`dba.getCluster()`, `dba.createCluster()`, `dba.dropMetadataSchema()`等。了解元数据模式的结构和存储内容。熟悉集群的恢复和重建流程，特别是在元数据损坏或丢失的情况下的处理方法。"
    },
    {
        "question": "### 试题 94:\n\nChoose two. User account `baduser@hostname` on your MySQL instance has been compromised (攻击).\nWhich two commands stop any new connections using the compromised account?",
        "selections": {
            "A": "ALTER USER baduser@hostname PASSWORD DISABLED;",
            "B": "ALTER USER baduser@hostname DEFAULT ROLE NONE;",
            "C": "ALTER USER baduser@hostname MAX_USER_CONNECTIONS 0;",
            "D": "ALTER USER baduser@hostname IDENTIFIED WITH mysql_no_login;",
            "E": "ALTER USER baduser@hostname ACCOUNT LOCK;"
        },
        "answers": [
            "D",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n当用户账户被盗用后，需要立即阻止该账户建立新的连接。\nD) `ALTER USER baduser@hostname IDENTIFIED WITH mysql_no_login;`：将用户的认证插件更改为`mysql_no_login`。这个插件会阻止任何尝试使用该账户登录的连接，无论密码是否正确。这是一种有效的禁用账户登录的方法 (D 正确)。\nE) `ALTER USER baduser@hostname ACCOUNT LOCK;`：显式地锁定用户账户。被锁定的账户无法建立新的连接 (E 正确)。\n\n错误选项分析：\nA) `PASSWORD DISABLED`不是标准的`ALTER USER`子句来禁用密码或账户。要禁用密码登录，可以使用`IDENTIFIED WITH mysql_no_login`或`PASSWORD LOCK` (后者是`ACCOUNT LOCK`的同义词，但`ACCOUNT LOCK`更通用)。\nB) `DEFAULT ROLE NONE`只是设置用户的默认角色为空，不影响其登录能力，只影响登录后自动激活的权限。\nC) `MAX_USER_CONNECTIONS 0`会将该用户允许的最大并发连接数设置为0。这确实能阻止新连接，但如果该用户已经有活动的连接，这些连接可能不会立即断开（取决于具体实现和版本）。`ACCOUNT LOCK`或`mysql_no_login`是更直接和彻底的禁用登录方法。\n\n**考点总结:**\n此题考察禁用MySQL用户账户登录的有效方法。`ACCOUNT LOCK`和将其认证插件改为`mysql_no_login`是两种主要且推荐的方式。\n\n**OCR答案提示“use the mysql_no_login authentication plugin to prevent clients from using the accounts to log in directly to the MySQL server”是正确的。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分不同`ALTER USER`子句的作用。关注那些能直接阻止认证成功或连接建立的选项。\n\n**学习建议:**\n学习MySQL用户账户安全管理，包括如何锁定/解锁账户（`ACCOUNT LOCK`/`ACCOUNT UNLOCK`）、如何更改认证插件（`IDENTIFIED WITH`）、如何管理密码策略。了解`mysql_no_login`认证插件的用途（例如，用于那些只应通过代理用户或其他间接方式访问的账户）。"
    },
    {
        "question": "### 试题 95:\n\nChoose two. Which two are use cases of MySQL asynchronous replication?",
        "selections": {
            "A": "You can scale reads by adding multiple slaves.",
            "B": "MySQL Enterprise Backup will automatically back up from an available slave.",
            "C": "You can scale writes by creating a replicated mesh.",
            "D": "It guarantees near real-time replication between a master and a slave.",
            "E": "It allows backup to be done on the slave without impacting the master."
        },
        "answers": [
            "A",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL异步复制有多种应用场景。\nA) 通过添加多个从服务器来扩展读能力（Read Scaling）：可以将读密集型查询分发到从服务器上执行，从而减轻主服务器的读负载，提高整体系统的读吞吐量 (A 正确)。\nE) 允许在从服务器上执行备份，而不影响主服务器的性能：可以在从服务器上运行备份操作（如`mysqldump`或物理备份），这样主服务器可以继续处理正常的读写请求，避免了备份对主库性能的冲击 (E 正确)。\n\n错误选项分析：\nB) MySQL Enterprise Backup是一个备份工具，它可以配置为从主库或从库备份。但它本身不“自动”决定从哪个可用从库备份，这通常需要DBA的配置或脚本逻辑。\nC) 创建复制网状结构（replicated mesh，如主主环形复制）可以实现一定程度的写扩展（例如，将写操作分散到不同主库），但这通常比简单的异步复制更复杂，且更容易产生冲突。而且，异步复制本身不直接“扩展写”，它主要是复制写操作。\nD) 异步复制不保证近实时（near real-time）复制。由于网络延迟、从库应用速度等因素，从库数据可能落后于主库（复制延迟）。半同步复制或同步复制（如组复制的某些模式）更能接近实时性。\n\n**考点总结:**\n此题考察MySQL异步复制的典型应用场景。读扩展和在从库上进行备份是两个最常见的用途。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解异步复制的核心是“数据冗余”和“负载分担”。思考如何利用这些特性来改善系统性能或可用性。\n\n**学习建议:**\n学习MySQL复制的各种应用场景，包括读写分离（读扩展）、高可用性（故障转移）、数据分析/报表（在从库上运行）、备份（在从库上进行）、跨地域数据分发等。了解不同复制拓扑（主从、主主、链式、星型、树型）的特点和适用性。"
    },
    {
        "question": "### 试题 96:\n\nChoose two. Examine this command, which executes successfully: `mysqlpump --user=root --password > full_backup.sql`\nWhich two databases will be excluded from this dump?",
        "selections": {
            "A": "mysql",
            "B": "information_schema",
            "C": "world",
            "D": "employee",
            "E": "sys"
        },
        "answers": [
            "B",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题65内容几乎完全相同，只是选项顺序可能不同。\n`mysqlpump`在没有任何数据库或表名指定的情况下执行时，默认会排除某些系统数据库。\nB) `information_schema`：虚拟元数据数据库，通常不被备份 (B 正确)。\nE) `sys` schema：包含性能诊断视图和存储过程的系统数据库，通常不被备份 (E 正确)。\n\n错误选项分析同试题65。\n**OCR答案提示“mysqlpump does not dump the performance_schema, ndbinfo, or sys schema by default. information_schema 不存在数据库”**。这里“information_schema 不存在数据库”的说法不准确，它是一个标准的、总是存在的虚拟数据库。正确的说法是`mysqlpump`默认排除`information_schema`, `performance_schema`, `sys`等。\n\n**考点总结:**\n再次强调`mysqlpump`工具在默认情况下的备份范围，特别是哪些系统数据库会被自动排除。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复的考点要加强记忆。记住`mysqlpump`默认排除的几个主要系统schema。\n\n**学习建议:**\n参考试题65的学习建议。务必查阅`mysqlpump`的官方文档，明确其默认行为和可配置选项。"
    },
    {
        "question": "### 试题 97:\n\nA valid raw backup of the `shop.customers` MyISAM table was taken. You must restore the table. You begin with these steps:\n1. Confirm that `secure_file_priv = '/var/tmp'`\n2. `mysql> DROP TABLE shop.customers;`\n3. `shell> cp /backup/customers.MY* /var/lib/mysql/shop/`\nWhich two actions are required to complete the restore?",
        "selections": {
            "A": "shell> cp /backup/customers.sdi /var/tmp",
            "B": "mysql> SOURCE '/var/tmp/customers.sdi'",
            "C": "shell> cp /backup/customers.sdi /var/lib/mysql/shop/",
            "D": "mysql> ALTER TABLE shop.customers DISCARD TABLESPACE",
            "E": "shell> cp /backup/customers.frm /var/lib/mysql/shop/",
            "F": "mysql> IMPORT TABLE FROM '/var/lib/mysql/shop/customers.sdi'",
            "G": "mysql> IMPORT TABLE FROM '/var/tmp/customers.sdi'",
            "H": "mysql> ALTER TABLE shop.customers IMPORT TABLESPACE"
        },
        "answers": [
            "A",
            "G"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题36内容几乎完全相同，只是选项顺序和其中一个正确选项的表述略有不同（D选项变为G选项）。\n假设环境是MySQL 8.0+，并且使用基于SDI的恢复流程。\n步骤3复制了数据文件（`.MYD`）和索引文件（`.MYI`）。现在需要恢复表结构。\n\nA) `shell> cp /backup/customers.sdi /var/tmp`：将SDI文件复制到`secure_file_priv`指定的目录 `/var/tmp` (A 正确)。\nG) `mysql> IMPORT TABLE FROM '/var/tmp/customers.sdi';`：从位于`/var/tmp`的SDI文件导入表结构 (G 正确，与试题36的D选项内容一致)。\n\n错误选项分析同试题36。\n\n**考点总结:**\n再次考察MySQL 8.0中基于SDI文件的表结构导入恢复流程，或者传统的MyISAM表文件恢复。根据题目线索，SDI导入是主要考点。关键步骤是将SDI文件放到安全路径，然后使用`IMPORT TABLE FROM`导入。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，注意细节差异。`secure_file_priv`和`IMPORT TABLE FROM`是重要线索。\n\n**学习建议:**\n参考试题36的学习建议。重点掌握MySQL 8.0的元数据管理方式（SDI）及其对备份恢复的影响。"
    },
    {
        "question": "### 试题 98:\n\nChoose two. Which two MySQL Shell commands are excluded from the InnoDB Cluster creation procedure?",
        "selections": {
            "A": "cluster.addInstance()",
            "B": "dba.configureLocalInstance()",
            "C": "dba.checkInstanceConfiguration()",
            "D": "cluster.setPrimaryInstance()",
            "E": "dba.configureInstance()",
            "F": "dba.createCluster()",
            "G": "cluster.forceQuorumUsingPartitionOf()"
        },
        "answers": [
            "D",
            "G"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nInnoDB集群创建过程通常涉及以下MySQL Shell AdminAPI命令：\n1.  `dba.configureInstance()` 或 `dba.configureLocalInstance()`: 配置要加入集群的MySQL实例，使其满足组复制的要求。\n2.  `dba.checkInstanceConfiguration()`: 检查实例配置是否符合集群要求。\n3.  `dba.createCluster()`: 创建新集群（通常在第一个实例上执行）。\n4.  `cluster.addInstance()`: 将其他实例加入到已创建的集群中。\n\n题目问哪些命令被“排除”在创建过程之外，或者说不是创建过程的核心步骤。\nD) `cluster.setPrimaryInstance()`：在单主模式的InnoDB集群中，主实例通常是在集群创建时自动选举或指定的（例如，`createCluster()`在其上执行的实例成为种子主实例）。`setPrimaryInstance()`命令用于在集群已运行后，手动更改主实例。这不是集群“创建”过程的必需步骤 (D 正确，因为它更像是管理操作而非创建操作)。\nG) `cluster.forceQuorumUsingPartitionOf()`：这个命令用于在发生网络分区且集群失去法定数量（quorum）时，强制从某个分区恢复集群的写能力。这是一个高级的灾难恢复命令，不属于常规的集群“创建”过程 (G 正确)。\n\n其他选项是创建或准备过程的一部分：\nA) `cluster.addInstance()`: 用于添加后续节点到集群。\nB) `dba.configureLocalInstance()`: 配置本地实例以备加入集群。\nC) `dba.checkInstanceConfiguration()`: 检查配置是否正确。\nE) `dba.configureInstance()`: 同B，配置实例。\nF) `dba.createCluster()`: 创建集群的核心命令。\n\n**考点总结:**\n此题考察对InnoDB集群创建流程中涉及的MySQL Shell AdminAPI命令的理解。区分集群创建、配置、添加成员的核心命令和用于后续管理或故障恢复的命令。\n\n**OCR答案提示“第一个节点就是主节点，不用设置” 指的是`dba.createCluster()`在其上执行的实例通常默认为主，所以不需要在创建时显式调用`cluster.setPrimaryInstance()`。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解InnoDB集群从无到有的典型部署步骤。将命令按其在生命周期中的作用（创建、配置、添加、管理、恢复）进行分类。\n\n**学习建议:**\n学习使用MySQL Shell AdminAPI部署和管理InnoDB集群的完整流程。熟悉每个核心命令（如`dba.configureInstance`, `dba.createCluster`, `cluster.addInstance`, `cluster.status`等）的作用、参数和使用场景。了解集群的生命周期管理，包括如何处理成员故障、网络分区和进行维护操作。"
    },
    {
        "question": "### 试题 99:\n\nChoose two. Examine this command, which executes successfully: `shell> mysqldump --master-data=2 --single-transaction --result-file=dump.sql mydb`\nWhich two statements are true?",
        "selections": {
            "A": "This option uses the READ COMMITTED transaction isolation mode.",
            "B": "It enforces consistent backups for all storage engines.",
            "C": "It is a cold backup.",
            "D": "The backup created is a consistent data dump.",
            "E": "It executes flush tables with read lock."
        },
        "answers": [
            "D",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqldump --master-data=2 --single-transaction --result-file=dump.sql mydb` 命令的特性：\n- `--master-data=2`: 会在dump文件的开头注释掉`CHANGE MASTER TO`语句。它还会记录备份开始时的二进制日志文件名和位置。为了确保这个位置的准确性，`mysqldump`在获取此信息前，通常会持有全局读锁（`FLUSH TABLES WITH READ LOCK`）一小段时间，除非使用了`--single-transaction`并且所有被备份的表都是事务性的（如InnoDB）。\n- `--single-transaction`: 这个选项通过在备份开始时启动一个事务，并在该事务内读取所有数据，来为InnoDB等事务性存储引擎创建一致性快照。在此模式下，对于InnoDB表，通常不需要全局读锁。但`--master-data`为了精确的binlog位置，可能仍会短暂锁表（或依赖于事务开始时的binlog位置）。\n- `mydb`: 只备份`mydb`数据库。\n\nD) 创建的备份是一个一致的数据转储：由于`--single-transaction`选项，对于InnoDB表，备份是在一个事务快照中进行的，保证了这些表的数据一致性。对于非事务性表（如MyISAM），`--single-transaction`无效，它们的一致性可能无法保证。但如果`mydb`中所有表都是InnoDB，则备份是一致的 (D 正确，假设主要关注InnoDB)。\nE) 它执行`FLUSH TABLES WITH READ LOCK`：即使使用了`--single-transaction`，`--master-data`选项为了获取精确的二进制日志坐标，在某些情况下（特别是如果混合了非事务性表，或者为了绝对确保所有引擎的binlog位置准确性）仍然可能会执行`FLUSH TABLES WITH READ LOCK`来暂停写入并记录binlog位置。这个锁的持有时间会尽量短 (E 正确，这是`--master-data`可能触发的行为，尤其是在没有`--no-locking`或类似选项时)。\n\n错误选项分析：\nA) `--single-transaction`是在`REPEATABLE READ`（默认）隔离级别下启动事务。它不改变事务隔离级别为`READ COMMITTED`。\nB) `--single-transaction`只对支持事务的存储引擎（如InnoDB）保证一致性。对于MyISAM等非事务性引擎，它无法提供事务一致性快照。\nC) 这是一个逻辑热备份（对于InnoDB表）。“冷备份”通常指在服务器停止时进行的物理备份。\n\n**考点总结:**\n此题考察`mysqldump`中`--single-transaction`和`--master-data`选项的组合使用及其对备份一致性和锁行为的影响。关键在于理解它们如何为不同存储引擎提供一致性，以及`--master-data`为了获取binlog位置可能采取的锁机制。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分`--single-transaction`对事务性和非事务性表的不同影响。理解`--master-data`的核心目的是记录复制坐标，这可能需要短暂的全局操作。\n\n**学习建议:**\n深入学习`mysqldump`的常用选项，特别是与一致性（`--single-transaction`, `--lock-all-tables`, `--lock-tables`）、复制（`--master-data`, `--dump-slave`）、GTID（`--set-gtid-purged`）相关的选项。了解它们如何协同工作以及各自的适用场景和限制。进行实验来观察不同选项组合下的锁行为和备份内容。"
    },
    {
        "question": "### 试题 100:\n\nChoose two. Which two methods allow a DBA to reset a user's password?",
        "selections": {
            "A": "SET PASSWORD statement [eg: SET PASSWORD FOR 'root'@'localhost' = 'abc123';]",
            "B": "mysql_secure_installation utility",
            "C": "ALTER USER statement",
            "D": "GRANT statement",
            "E": "mysqladmin client program"
        },
        "answers": [
            "A",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nDBA重置用户密码有多种方法：\nA) `SET PASSWORD FOR 'user'@'host' = 'new_password';`：这是一个SQL语句，允许具有足够权限的DBA（通常是拥有`UPDATE`权限于`mysql.user`表或全局`CREATE USER`权限的用户）直接为指定用户设置新密码 (A 正确)。注意：在MySQL 8.0中，更推荐使用`ALTER USER`。\nC) `ALTER USER 'user'@'host' IDENTIFIED BY 'new_password';`：这是MySQL 5.7.6及以后版本推荐的修改用户密码的标准SQL语句。它提供了更丰富的功能来管理用户账户属性 (C 正确)。\n\n错误选项分析：\nB) `mysql_secure_installation`是一个交互式脚本，用于MySQL安装后的基本安全配置，包括设置root密码（如果之前未设置或使用临时密码）、移除匿名用户、禁止root远程登录等。它不直接用于重置任意已知用户的密码，更多是初始安全加固。\nD) `GRANT`语句用于授予权限，虽然在早期MySQL版本中，`GRANT ... IDENTIFIED BY 'password'`可以同时创建用户（如果不存在）并设置密码，或者修改现有用户的密码和权限，但在现代MySQL中，其修改密码的功能已被`ALTER USER`取代或不推荐。`GRANT`的核心功能是权限管理，不是密码重置。\nE) `mysqladmin password 'new_password'`命令用于更改当前连接用户（或通过`-u root -p`等指定的root用户）的密码。它可以用来重置root密码（如果知道旧密码或以root身份执行）。但题目问的是DBA重置“一个用户”的密码，`ALTER USER`或`SET PASSWORD`更通用。`mysqladmin`修改密码通常需要提供旧密码（除非是root修改自己或其他用户）。\n\n**考点总结:**\n此题考察DBA重置用户密码的SQL命令。`ALTER USER ... IDENTIFIED BY ...`是现代MySQL的首选方法，`SET PASSWORD FOR ... = ...`是较旧但仍可用的方法。\n\n**OCR答案提示“mysqladmin 只能改自己的”不完全准确。** 如果`mysqladmin`以具有足够权限的用户（如root）连接，它可以更改其他用户的密码，但其主要设计是更改当前用户的密码或在知道root密码时更改root密码。对于重置任意用户密码，SQL语句更为直接。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住修改用户账户属性（包括密码）的首选命令是`ALTER USER`。了解`SET PASSWORD`的历史用法。区分用于初始设置的工具和用于日常管理的命令。\n\n**学习建议:**\n学习MySQL用户账户和密码管理的各种SQL命令和工具。掌握`CREATE USER`, `ALTER USER` (特别是`IDENTIFIED BY`, `PASSWORD EXPIRE`, `ACCOUNT LOCK/UNLOCK`等子句), `DROP USER`, `SET PASSWORD`, `GRANT`, `REVOKE`等。了解`mysqladmin`客户端工具的常用功能。熟悉MySQL的密码策略和安全最佳实践。"
    },
    {
        "question": "### 试题 101:\n\nChoose two. The data in this instance is transient; no backup or replication will be required. It is currently under performing. The database size is static and including indexes is 19G. Total system memory is 32G. After profiling the system, you highlight these MySQL status and global variables: \n```Com_rollback 85408355 \nCom_commit 1242324 \nInnodb_buffer_pool_pages_free 163840 \n[mysqld] \nbuffer_pool_size=20G \ninnodb_flush_log_at_trx_commit=2 \ndisable-log-bin\n```\nThe OS metrics indicate that disk is a bottleneck. Other variables retain their default values.\nWhich two changes will provide the most benefit to the instance?",
        "selections": {
            "A": "sync_binlog=0",
            "B": "buffer_pool_size=24G",
            "C": "innodb_flush_log_at_trx_commit=1",
            "D": "innodb_doublewrite=0",
            "E": "max_connections=10000",
            "F": "innodb_log_file_size=1G"
        },
        "answers": [
            "D",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题26内容几乎完全相同，只是选项顺序和其中一个正确答案的评估可能略有不同，或者说对哪个“最有益”的判断差异。\n题目条件：瞬态数据，无备份复制需求，磁盘瓶颈。数据库19G，缓冲池20G，内存32G。\n\nD) `innodb_doublewrite=0` (禁用双写缓冲): 由于数据是瞬态的，可以接受数据丢失风险。禁用双写可以减少写I/O，缓解磁盘瓶颈 (D 正确)。\nF) `innodb_log_file_size=1G`: 当前`innodb_flush_log_at_trx_commit=2`（每秒刷盘）。适当增大redo log文件大小（例如从默认的48M增加到1G，通常由多个小文件组成，如2x512M）可以减少redo log刷盘的频率（因为更大的日志空间可以容纳更长时间的事务日志而无需频繁切换和刷盘），从而降低磁盘I/O压力，有助于缓解磁盘瓶颈，特别是对于写密集型操作 (F 正确，尤其是在`innodb_flush_log_at_trx_commit=2`时，更大的日志可以更好地平滑I/O)。\n\n错误选项分析（理由同试题26，或在此场景下优先级较低）：\nA) `sync_binlog=0`: 二进制日志已禁用，此参数无效。\nB) `buffer_pool_size=24G`: 将缓冲池从20G增到24G。虽然有益，但鉴于数据集19G，20G缓冲池已能大部分覆盖。在磁盘瓶颈非常严重时，直接减少I/O操作（如D和F）可能比略微增加已基本足够的缓冲池更有“最大益处”。\nC) `innodb_flush_log_at_trx_commit=1`: 会增加磁盘I/O，加剧瓶颈。\nE) `max_connections=10000`: 无信息表明连接数是瓶颈，随意增加可能有害。\n\n**考点总结:**\n再次考察在特定约束（瞬态数据、磁盘瓶颈）下如何通过参数调优来提升性能。重点是识别直接影响磁盘I/O操作频率和量的参数。\n\n**答案说明:** 试题26选择了B和D。本题如果也选两个，D是明确的。在B（增加缓冲池）和F（增加redo log大小）之间，如果磁盘写是主要瓶颈，且`flush_log_at_trx_commit=2`，那么增加redo log大小以平滑写入I/O可能比略微增加已基本够用的缓冲池更有针对性。但两者都有一定道理。OCR的答案可能基于更细致的场景判断或特定权重。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，注意分析题目中的所有约束和性能指标。当有多个看似合理的优化选项时，思考哪个对“当前瓶颈”的缓解最为直接和显著。\n\n**学习建议:**\n参考试题26的学习建议。特别关注InnoDB的I/O子系统调优，包括缓冲池、redo log、doublewrite buffer等。理解它们如何相互作用以及如何影响不同类型工作负载下的磁盘I/O。"
    },
    {
        "question": "### 试题 102:\n\nChoose two. Examine Joe's account: `CREATE USER 'joe'@'%' IDENTIFIED BY '*secret*' GRANT ALL PRIVILEGES ON *.* TO 'joe'@'%'`\nAll existing connections for joe are killed.\nWhich two commands will stop joe establishing access to the MySQL instance?",
        "selections": {
            "A": "ALTER USER 'joe'@'%' ACCOUNT LOCK",
            "B": "ALTER USER 'joe'@'%' PASSWORD HISTORY ...",
            "C": "REVOKE ALL PRIVILEGES ON *.* FROM 'joe'@'%'",
            "D": "ALTER USER 'joe'@'%' SET password='*invalid*'",
            "E": "ALTER USER 'joe'@'%' IDENTIFIED BY '*invalid*' PASSWORD EXPIRE",
            "F": "REVOKE USAGE ON *.* FROM 'joe'@'%'"
        },
        "answers": [
            "A",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n要阻止用户`joe@%`建立新的连接或访问权限，可以采取以下措施：\nA) `ALTER USER 'joe'@'%' ACCOUNT LOCK;`：显式锁定账户，使其无法登录 (A 正确)。\nE) `ALTER USER 'joe'@'%' IDENTIFIED BY '*invalid*' PASSWORD EXPIRE;`：更改用户的密码为一个无效/未知的值（`*invalid*`），并且设置密码立即过期。这样用户即使知道旧密码也无法登录，并且会被强制要求更改密码（但由于新密码未知，实际上也无法完成更改）。这有效地阻止了登录 (E 正确)。\n\n错误选项分析：\nB) `ALTER USER 'joe'@'%' PASSWORD HISTORY ...`：这是管理密码历史的子句，不直接阻止登录。\nC) `REVOKE ALL PRIVILEGES ON *.* FROM 'joe'@'%';`：这会移除用户的所有权限，用户仍然可以连接到服务器，但不能执行任何操作。题目要求“阻止建立访问”，这通常指阻止登录或连接。\nD) `ALTER USER 'joe'@'%' SET password='*invalid*'`：这种语法不规范。更改密码应使用`IDENTIFIED BY`子句。\nF) `REVOKE USAGE ON *.* FROM 'joe'@'%';`：`USAGE`是最低权限，表示允许用户连接到服务器但没有任何其他权限。撤销`USAGE`权限等同于删除用户账户（或者使其无法连接，取决于MySQL版本和具体实现）。这确实能阻止访问，但`ACCOUNT LOCK`和修改密码并过期是更直接的阻止“登录”的方法。如果账户仍然存在但无`USAGE`权限，其行为可能类似于账户不存在。\n\n**考点总结:**\n此题考察阻止用户访问MySQL实例的有效方法。锁定账户和使其密码无效/过期是两种直接的方式。\n\n\n-   关于F：`REVOKE USAGE`确实可以有效地阻止用户连接，因为它移除了用户的基本连接权限。如果`joe@%`除了`USAGE`没有其他权限，撤销`USAGE`后用户将无法连接。\n-   关于E：密码过期确实会导致用户在下次登录时被要求更改密码，如果他们无法提供有效的新密码（或者不知道被DBA设置的`*invalid*`密码），则无法完成登录。\n\n考虑到“阻止joe建立访问”，A（锁定账户）和E（改密码并过期）是非常直接的。F（撤销USAGE）也能达到类似效果，但其语义更接近于“移除连接能力”。如果题目强调阻止“登录”，A和E更贴切。如果广泛理解“阻止访问”，F也可以考虑。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解不同用户管理命令的精确效果。`ACCOUNT LOCK`是明确的账户禁用。密码管理（修改、过期）也是控制访问的手段。权限撤销（特别是`USAGE`）也能影响连接能力。\n\n**学习建议:**\n学习`ALTER USER`命令的各种子句及其对用户账户状态和行为的影响。掌握用户账户生命周期管理，包括创建、授权、修改（密码、锁定状态、过期策略等）、撤销权限和删除账户。了解`USAGE`权限的特殊含义。"
    },
    {
        "question": "### 试题 103:\n\nWhich two can minimize security risks when creating user accounts?",
        "selections": {
            "A": "Avoid the use of wildcards in host names.",
            "B": "Avoid the use of wildcards in usernames.",
            "C": "Require the use of mixed case usernames.",
            "D": "Do not allow accounts without passwords.",
            "E": "Require users to have the FIREWALL USER privilege defined."
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n创建用户账户时，遵循安全最佳实践可以最小化安全风险。\nA) 避免在主机名中使用通配符（如`'user'@'%'`）。尽可能将用户账户限制到特定的IP地址或主机名，以减少账户被未授权主机滥用的风险 (A 正确)。\nD) 不允许创建没有密码的账户，并强制使用强密码策略。无密码账户或弱密码账户是常见的安全漏洞 (D 正确)。\n\n错误选项分析：\nB) 用户名本身通常不使用通配符。用户名是账户的标识符。\nC) 要求使用混合大小写用户名对安全性提升不大，且可能增加管理复杂性。关键在于密码的复杂性和账户权限的最小化。\nE) `FIREWALL_USER`权限与MySQL Enterprise Firewall相关，用于管理特定用户的防火墙配置。并非所有用户都需要此权限，将其授予不必要的用户反而可能引入风险。\n\n**考点总结:**\n此题考察创建MySQL用户账户时的安全原则。核心在于限制账户的访问范围（主机限制）和确保账户认证的强度（密码要求）。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n从“最小权限”和“强认证”的角度思考用户账户安全。避免使用过于宽松的配置，如通配符主机和无密码账户。\n\n**学习建议:**\n学习MySQL用户账户管理的最佳实践，包括：\n1.  使用强密码策略，并定期更换密码。\n2.  精确指定账户的主机部分，避免使用`%`，除非确实需要。\n3.  遵循最小权限原则，只授予用户完成其工作所必需的权限。\n4.  定期审计用户账户和权限。\n5.  考虑使用密码过期、账户锁定等高级安全特性。\n6.  对于需要特定权限的系统组件（如复制用户、备份用户），创建专用的、权限受限的账户。"
    },
    {
        "question": "### 试题 104:\n\nChoose two. Mary connects to a Linux MySQL Server from a client on a Windows machine.\nExamine this statement and output:\n```sql\nmysql> SELECT USER(), CURRENT_USER();\n+------------------+----------------+\n| USER()           | CURRENT_USER() |\n+------------------+----------------+\n| mary@192.0.2.101 | mary@%         |\n+------------------+----------------+\n1 row in set (0.00 sec)\n```\nWhich two are true?",
        "selections": {
            "A": "Mary connected from a client machine whose IP address is 192.0.2.101.",
            "B": "Mary connected to the database server whose IP address is 192.0.2.101.",
            "C": "Mary has the privileges of account mary@%.",
            "D": "Mary connected using a UNIX socket.",
            "E": "Mary authenticated to the account mary@192.0.2.101."
        },
        "answers": [
            "A",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n- `USER()`: 返回客户端连接到服务器时提供的用户名和主机名。\n- `CURRENT_USER()` (或 `CURRENT_USER`): 返回当前会话在执行权限检查时使用的用户名和主机名。这通常是实际匹配到`mysql.user`表（或数据字典）中的账户。\n\n输出显示：\n- `USER() = 'mary@192.0.2.101'`\n- `CURRENT_USER() = 'mary@%'`\n\nA) Mary连接自IP地址为`192.0.2.101`的客户端机器。`USER()`函数的结果`'mary@192.0.2.101'`中的主机部分通常是客户端的实际IP地址或可解析的主机名 (A 正确)。\nC) Mary拥有账户`mary@%`的权限。`CURRENT_USER()`显示`'mary@%'`，这意味着MySQL服务器在权限验证时，将Mary的连接（来自`192.0.2.101`）匹配到了一个账户定义为`'mary'@'%'`的条目。因此，Mary在此会话中将使用`'mary'@'%'`这个账户被授予的权限 (C 正确)。\n\n错误选项分析：\nB) `USER()`函数中的IP地址是客户端的IP，不是数据库服务器的IP。\nD) Mary从Windows机器连接到Linux服务器，通常会使用TCP/IP网络连接，而不是Unix套接字（Unix套接字用于同一台Linux/Unix机器上的本地连接）。\nE) Mary认证时，服务器是将她的连接（`mary`来自`192.0.2.101`）匹配到了`'mary'@'%'`这个账户定义，而不是一个名为`'mary'@'192.0.2.101'`的特定账户（除非`'mary'@'%'`是唯一的匹配项，但`CURRENT_USER()`明确指出了是`'mary'@'%'`）。\n\n**考点总结:**\n此题考察对MySQL中`USER()`和`CURRENT_USER()`函数的理解和区别。`USER()`反映了客户端连接时“声称”的身份和来源，而`CURRENT_USER()`反映了服务器实际用于权限检查的账户。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n牢记`USER()`和`CURRENT_USER()`的区别。`USER()`是连接时客户端的标识，`CURRENT_USER()`是服务器认证和授权时实际使用的账户。当存在主机通配符（如`%`）时，这两者可能不同。\n\n**学习建议:**\n学习MySQL的用户认证和权限检查机制。理解服务器如何根据客户端提供的用户名和连接来源IP（或主机名）在`mysql.user`表（或数据字典）中查找匹配的账户条目，以及匹配的优先级（例如，更精确的主机匹配优先于通配符）。熟悉`USER()`, `CURRENT_USER()`, `SESSION_USER()`等函数的用途。"
    },
    {
        "question": "### 试题 105:\n\nChoose two. Which two actions can obtain information about deadlocks?",
        "selections": {
            "A": "Run the SHOW ENGINE INNODB MUTEX command from the mysql client.",
            "B": "Enable the innodb_status_output_locks global parameter.",
            "C": "Enable the innodb_print_all_deadlocks global parameter.",
            "D": "Run the SHOW ENGINE INNODB STATUS command from the mysql client.",
            "E": "Use the sys.innodb_lock_waits view."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n获取InnoDB死锁信息的方法：\nC) 启用`innodb_print_all_deadlocks`全局参数（通过`SET GLOBAL innodb_print_all_deadlocks = ON;`或在`my.cnf`中设置）：当此参数启用时，所有检测到的InnoDB死锁的详细信息都会被记录到MySQL的错误日志文件中。这对于分析历史死锁非常有用 (C 正确)。\nD) 从mysql客户端运行`SHOW ENGINE INNODB STATUS;`命令：这个命令的输出包含了大量InnoDB内部状态信息，其中包括`LATEST DETECTED DEADLOCK`部分，这里会显示最近一次检测到的死锁的详细信息（涉及的事务、语句、锁等）。但它通常只保留最后一次死锁的信息 (D 正确)。\n\n错误选项分析：\nA) `SHOW ENGINE INNODB MUTEX;`命令用于显示InnoDB内部互斥锁和读写锁的争用统计信息，与事务级死锁（通常指行锁或表锁导致的死锁）的直接诊断关系不大。\nB) `innodb_status_output_locks`参数启用时，`SHOW ENGINE INNODB STATUS`的输出会包含更详细的锁信息（所有活动的锁和等待），但它不直接“获取死锁信息”，而是提供分析锁争用的上下文。死锁信息仍在`LATEST DETECTED DEADLOCK`部分。\nE) `sys.innodb_lock_waits`视图（或Performance Schema中的`data_lock_waits`表）显示当前正在发生的锁等待情况，可以帮助诊断锁争用和潜在的死锁，但它不直接显示已发生并被解决（或回滚）的死锁的完整历史信息。它更多是实时监控。\n\n**考点总结:**\n此题考察获取InnoDB死锁信息的主要方法。`SHOW ENGINE INNODB STATUS`用于查看最近的死锁，启用`innodb_print_all_deadlocks`用于将所有死锁记录到错误日志以供后续分析。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分实时锁等待监控和历史死锁信息获取。`SHOW ENGINE INNODB STATUS`是快速查看最近死锁的标准方法。错误日志是排查疑难问题和历史事件的重要来源。\n\n**学习建议:**\n学习InnoDB的锁机制和死锁检测与处理。熟练掌握`SHOW ENGINE INNODB STATUS`命令输出的解读，特别是`TRANSACTIONS`和`LATEST DETECTED DEADLOCK`部分。了解如何配置和使用`innodb_print_all_deadlocks`参数。学习使用Performance Schema和`sys` schema中的视图（如`sys.innodb_lock_waits`, `performance_schema.data_locks`, `performance_schema.data_lock_waits`）来监控锁活动和诊断锁问题。"
    },
    {
        "question": "### 试题 106:\n\nChoose two. Which two are true about binary logs used in asynchronous replication?",
        "selections": {
            "A": "They contain events that describe all queries run on the master.",
            "B": "They contain events that describe database changes on the master.",
            "C": "They are pushed from the master to the slave.",
            "D": "They contain events that describe only administrative commands run on the master.",
            "E": "They are pulled from the master to the slave."
        },
        "answers": [
            "B",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题17内容几乎完全相同，只是选项顺序可能不同。\nB) 它们包含描述主库上数据库更改的事件：这是二进制日志的核心内容，无论是语句、行更改还是DDL (B 正确)。\nE) 它们由从库从主库拉取：从库的I/O线程连接到主库并请求binlog事件 (E 正确)。\n\n错误选项分析同试题17。\n\n**考点总结:**\n再次强调二进制日志在异步复制中的本质（记录数据更改）和传输方式（从库拉取）。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复的考点应熟记。明确数据流向和日志内容。\n\n**学习建议:**\n参考试题17的学习建议。对核心概念的理解是关键。"
    },
    {
        "question": "### 试题 107:\n\nA scientific data gathering application uses a MySQL instance back end for data management. There is a high concurrency of transactions at thousands of transactions per second of volatile data. A restore from binary logs is planned using the command: `mysqlbinlog --start-datetime='2019-08-01 11:00:00' --stop-datetime='2019-08-10 08:30:25' binlog.000238 binlog.000239 binlog.000240 mysql`\nWhich two characteristics cause the restore to be inconsistent to the original data?",
        "selections": {
            "A": "Transaction rate is too high to get a consistent restore.",
            "B": "Multiple binary logs cannot be specified on the command line.",
            "C": "Temporary tables cannot persist across binary logs.",
            "D": "The temporal values do not offer high enough precision.",
            "E": "The time span of binary logs is too long to restore."
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n使用`mysqlbinlog`基于时间范围进行恢复时，可能导致数据不一致的原因：\nA) 事务率过高，难以获得一致性恢复：如果事务并发非常高，并且某些事务跨越了`--start-datetime`或`--stop-datetime`指定的时间点，那么基于时间的过滤可能无法精确地包含或排除一个完整的事务。例如，一个事务在`start-datetime`之前开始，但在之后提交，或者在`stop-datetime`之前开始，但在之后提交。`mysqlbinlog`基于时间过滤事件时，可能只恢复了事务的一部分，导致数据不一致 (A 正确)。\nD) 时间值的精度不足：`DATETIME`类型的精度到秒。如果事务的提交时间戳非常接近指定的`start-datetime`或`stop-datetime`，并且在同一秒内有多个事务，基于秒级精度的时间过滤可能无法准确地界定事务边界，导致不一致 (D 正确)。MySQL 5.6.4及以后版本支持微秒级精度的时间戳 (`log_timestamps=SYSTEM`时)，这可以提高基于时间恢复的准确性，但如果原始binlog时间戳精度不足，或`mysqlbinlog`处理时仍有问题，则仍可能不一致。\n\n错误选项分析：\nB) `mysqlbinlog`命令可以指定多个二进制日志文件进行处理，如题目命令所示 (`binlog.000238 binlog.000239 binlog.000240`)。\nC) 临时表的操作通常不记录到二进制日志（或以特定方式记录，不用于常规数据恢复）。即使记录，它们在恢复时的行为也与持久表不同。这不是基于时间恢复不一致的主要原因。\nE) 二进制日志的时间跨度本身不是导致不一致的原因。只要时间点选择得当，并且工具能正确处理事务边界，长时间跨度的恢复也是可能的。问题在于高并发和时间精度下的事务边界界定。\n\n**考点总结:**\n此题考察使用`mysqlbinlog`进行基于时间的时间点恢复（PITR）时可能遇到的数据不一致问题。主要原因是高并发下事务可能跨越时间点，以及时间戳精度可能不足以精确界定事务边界。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n思考基于时间点恢复的内在挑战：如何确保只恢复完整的、应该被恢复的事务。高并发和时间精度是关键影响因素。\n\n**学习建议:**\n学习使用`mysqlbinlog`工具进行时间点恢复，包括其`--start-datetime`, `--stop-datetime`, `--start-position`, `--stop-position`等选项。理解基于GTID的恢复通常比基于时间和位置的恢复更可靠和简单。了解事务在二进制日志中的表示以及`mysqlbinlog`如何处理它们。熟悉`log_timestamps`参数对时间戳精度的影响。"
    },
    {
        "question": "### 试题 108:\n\nChoose two. Which two are contained in the InnoDB system tablespace (`ibdata1`) by default?",
        "selections": {
            "A": "doublewrite buffer",
            "B": "change buffer",
            "C": "InnoDB Data Dictionary",
            "D": "primary indexes",
            "E": "table data",
            "F": "user privileges"
        },
        "answers": [
            "A",
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nInnoDB系统表空间（通常是`ibdata1`文件）在默认情况下（特别是在MySQL 8.0之前，或8.0中如果未显式配置）包含以下一些关键组件：\nA) 双写缓冲区（Doublewrite Buffer）：InnoDB为了防止部分页写入导致的数据损坏，会将数据页先写入双写缓冲区，然后再写入实际的数据文件。双写缓冲区本身是系统表空间的一部分 (A 正确)。\nB) 修改缓冲区（Change Buffer，在MySQL 5.5前称为Insert Buffer）：用于缓存对二级索引页的非唯一修改操作，将随机I/O合并为顺序I/O，以提高性能。修改缓冲区也位于系统表空间 (B 正确)。\n\n错误或不完全准确的选项分析：\nC) InnoDB数据字典：在MySQL 8.0之前，InnoDB的数据字典（关于表、索引等的内部元数据）确实存储在系统表空间中。但在MySQL 8.0及以后，引入了新的事务性数据字典，它有自己的表（存储在`mysql.ibd`通用表空间中），不再完全依赖于旧的系统表空间内的数据字典结构。因此，这个选项的正确性取决于MySQL版本上下文。如果题目未指定版本，且考虑到现代版本，则不完全准确。\nE) 表数据和 D) 主键索引：如果`innodb_file_per_table`设置为`OFF`（MySQL 5.6.6之前的默认值），用户表的数据和索引（包括主键索引）会存储在系统表空间中。如果`innodb_file_per_table`设置为`ON`（MySQL 5.6.6及以后的默认值），则每个新表的数据和索引会存储在各自的`.ibd`独立表空间文件中，而不是系统表空间。题目问“默认情况下”，这取决于哪个版本的默认值。如果按最新版本的默认值，则用户表数据和索引不在系统表空间。\nF) 用户权限：用户权限信息存储在`mysql`系统数据库的表中（如`mysql.user`, `mysql.db`等）。这些表本身可能是InnoDB表，如果`innodb_file_per_table=OFF`，它们的数据会在系统表空间；如果`ON`，它们会有自己的`.ibd`文件。但“用户权限”这个信息本身不是系统表空间的“内容”，而是存储在特定表中的数据。\n\n**考点总结:**\n此题考察对InnoDB系统表空间默认包含组件的了解。双写缓冲区和修改缓冲区是其核心内部结构。数据字典、用户表数据和索引的存储位置则与MySQL版本和`innodb_file_per_table`配置有关。\n\n**答案说明:** 考虑到双写缓冲和修改缓冲是InnoDB系统表空间固有的、不随`innodb_file_per_table`配置而改变的核心组件，A和B是最稳妥的答案。C、D、E的存放位置会受配置和版本影响。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分InnoDB系统表空间中“总是存在”的内部结构（如双写缓冲、修改缓冲）和“可能存在”（取决于配置和版本）的内容（如数据字典、用户表数据）。\n\n**学习建议:**\n学习InnoDB的存储架构，特别是系统表空间的组成和作用。了解`innodb_file_per_table`参数如何影响用户表数据的存储位置。熟悉双写缓冲区和修改缓冲区的工作原理及其对性能和数据安全性的影响。了解MySQL 8.0数据字典的变化。"
    },
    {
        "question": "### 试题 109:\n\nChoose two. Examine these InnoDB Cluster parameter settings:\n```\ncluster.setInstanceOption('host1:3377', 'memberWeight', 40)\ncluster.setInstanceOption('host2:3377', 'memberWeight', 30)\ncluster.setInstanceOption('host3:3377', 'memberWeight', 40)\ncluster.setInstanceOption('host3:3377', 'exitStateAction', 'ABORT_SERVER')\ncluster.setOption('expelTimeout', 1)\n```\nNow examine the partial status.\nA permanent network failure isolates host3. Which two statements are true?\n```json\n{\n  \"topology\": {\n    \"host1:3377\": {\n      \"address\": \"host1:3377\",\n      \"mode\": \"R/O\",\n      \"status\": \"ONLINE\",\n      \"version\": \"8.0.18\"\n    },\n    \"host2:3377\": {\n      \"address\": \"host2:3377\",\n      \"mode\": \"R/O\",\n      \"status\": \"ONLINE\",\n      \"version\": \"8.0.18\"\n    },\n    \"host3:3377\": {\n      \"address\": \"host3:3377\",\n      \"mode\": \"R/W\", // Assuming host3 was primary before failure\n      \"status\": \"ONLINE\", // This would change after isolation\n      \"version\": \"8.0.18\"\n    }\n  }\n}\n```",
        "selections": {
            "A": "The instance deployed on host3 will automatically rejoin the cluster when connectivity is re-established.",
            "B": "Failure of the instance deployed on host1 provokes an outage.",
            "C": "The instance deployed on host3 is expelled from the cluster and must be rejoined using cluster.addInstance('host3:3377').",
            "D": "The primary instance can be specified by using the command cluster.setPrimaryInstance(<host>:<port>).",
            "E": "The instance deployed on host2 is elected as the new primary instance.",
            "F": "The issuing command cluster.switchToMultiPrimaryMode() will fail to enable multi-primary mode."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n场景：host3（假设是主节点，权重40）被网络隔离。集群有host1（权重40, R/O）、host2（权重30, R/O）。`expelTimeout`为1秒，意味着被隔离的成员会很快被驱逐。host3的`exitStateAction`为`ABORT_SERVER`，表示如果它意外离开集群（如被驱逐），MySQL服务会中止。\n\nC) 由于host3被网络隔离且`expelTimeout`很短，它会被集群驱逐。因为其`exitStateAction`是`ABORT_SERVER`，host3上的MySQL服务会停止。当网络恢复后，host3不会自动重新加入。它需要被手动启动，并且可能需要通过`cluster.rejoinInstance('host3:3377')`（如果实例配置仍然有效且数据未发散太多）或在某些情况下（如果实例状态不佳或需要重新供应数据）通过`cluster.addInstance('host3:3377')`（可能先`cluster.removeInstance()`）来重新加入集群 (C 正确，强调了被驱逐和需要手动操作重新加入)。\nD) `cluster.setPrimaryInstance(<host>:<port>)`命令用于在单主模式的InnoDB集群中手动指定哪个实例作为主（读写）实例。这是一个有效的管理命令 (D 正确，这是一个一般性陈述，与当前故障场景不直接相关，但作为命令本身是存在的)。\n\n错误选项分析：\nA) 由于`exitStateAction='ABORT_SERVER'`，host3的MySQL服务会停止，它不会自动重新加入。\nB) 如果host1（权重40）故障，集群剩下host2（权重30）和host3（权重40）。总权重80，多数派需要超过40。如果host3是主，且host2+host3 (30+40=70) 仍构成多数派，集群可以继续运行并从host2或host3中选举新的主（如果host3不是主）。所以不一定会立即导致outage，取决于当时的主节点和剩余节点的权重能否形成新的多数派并选举出主。但如果host3是主且也故障，则肯定outage。题目描述是“host1故障”，此时host2和host3可能仍然构成多数派。\nE) 当主节点host3被隔离和驱逐后，集群会在剩余的host1和host2中选举新的主节点。由于host1的权重（40）高于host2的权重（30），host1更有可能被选为新的主节点，而不是host2 (E 错误)。\nF) `cluster.switchToMultiPrimaryMode()`用于将集群从单主模式切换到多主模式。这个操作能否成功取决于集群当前的状态和配置，与host3被隔离的这个特定事件没有直接的因果关系说一定会失败。如果剩余成员构成法定数量且满足多主模式的要求，切换可能是成功的。\n\n**考点总结:**\n此题考察InnoDB集群在网络分区、成员故障时的行为，特别是`memberWeight`, `expelTimeout`, `exitStateAction`参数的影响，以及主节点选举和集群恢复操作。 \n**OCR答案提示中的分析“E答案也不对应该是权重高的 host1 成为 primary”是正确的。** \n**OCR答案提示“A不对，因为实例关闭了。原因如下: rejoinInstance(). If exitStateAction is set to ABORT_SERVER then in the event of leaving the cluster unexpectedly, the instance shuts down MySQL, and it has to be started again before it can rejoin the cluster.” 这段分析也是正确的。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细分析题目给出的所有配置参数和状态信息。理解权重在主节点选举中的作用。了解`exitStateAction`如何影响故障成员的行为。区分自动恢复和需要手动干预的场景。\n\n**学习建议:**\n深入学习MySQL InnoDB Cluster的故障容错机制，包括成员驱逐、自动故障转移、主节点选举（基于权重）、网络分区处理。掌握`memberWeight`, `expelTimeout`, `exitStateAction` (`OFFLINE_MODE`, `READ_ONLY`, `ABORT_SERVER`) 等关键参数的含义和配置。熟悉常用的集群管理和恢复命令（如`cluster.status()`, `cluster.rejoinInstance()`, `cluster.setPrimaryInstance()`, `cluster.forceQuorumUsingPartitionOf()`等）。"
    },
    {
        "question": "### 试题 110:\n\nChoose two. A clean shutdown was performed with `innodb_fast_shutdown=0`. While you were manipulating files, all files were accidentally deleted from the top-level data directory. Which two files must be restored from backup to allow the DB to restart cleanly?",
        "selections": {
            "A": "ib_buffer_pool",
            "B": "ib_logfile0",
            "C": "mysql.ibd",
            "D": "ibdata1",
            "E": "ibtmp1",
            "F": "undo_001"
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n在MySQL 8.0中，要使数据库能够干净地从备份中恢复并重启，至少需要以下核心文件：\n- 数据字典文件：MySQL 8.0的数据字典存储在`mysql.ibd`文件中（这是一个通用表空间）。它包含了所有数据库对象的元数据。\n- InnoDB系统表空间文件（如果独立配置，或者部分核心数据仍依赖它）：通常是`ibdata1`。即使大部分数据使用独立表空间，`ibdata1`仍可能包含一些系统信息，如undo日志（如果未配置独立undo表空间）。\n- Redo日志文件（`ib_logfile*`）：对于事务的持久性和崩溃恢复至关重要。\n- 用户数据的表空间文件（`.ibd`文件，如果使用`innodb_file_per_table`）。\n\n题目说“所有文件都被意外删除”，并且`innodb_fast_shutdown=0`表示进行了慢关闭（clean shutdown），这意味着所有脏页已刷盘，redo log中的事务已处理完毕。\n在这种情况下，要“重启干净地”，最核心的是元数据和系统级数据结构。\nC) `mysql.ibd`：这是MySQL 8.0数据字典的存储文件，包含了所有数据库对象的定义，是启动和运行MySQL的绝对核心 (C 正确)。\nD) `ibdata1`：这是InnoDB的系统表空间文件。即使在`innodb_file_per_table=ON`的情况下，它仍然可能包含重要信息，如undo日志（如果未独立配置）、修改缓冲、双写缓冲（尽管双写缓冲本身不是恢复所必需的“数据”，但`ibdata1`的结构完整性重要）。在干净关闭后，其内容应是一致的 (D 正确)。\n\n错误选项分析：\nA) `ib_buffer_pool`：这是InnoDB缓冲池在关闭时保存其状态的文件（如果启用了`innodb_buffer_pool_dump_at_shutdown`和`innodb_buffer_pool_load_at_startup`）。它有助于加速重启后的预热，但不是数据库“干净重启”的绝对必需文件。没有它，服务器仍能启动，只是缓冲池需要重新填充。\nB) `ib_logfile0` (和 `ib_logfile1`等redo日志文件)：在干净关闭（`innodb_fast_shutdown=0`）后，redo日志中的所有事务都已应用到数据文件，理论上redo日志可以被重新创建（尽管通常建议一起恢复）。但题目问的是“必须恢复”以“干净重启”。相对于`mysql.ibd`和`ibdata1`，它们的重要性稍低（在clean shutdown后）。\nE) `ibtmp1`：这是InnoDB的临时表空间文件。临时数据在重启后不需要保留，服务器会重新创建它。不是恢复所必需的。\nF) `undo_001` (和 `undo_002`等独立undo表空间文件)：如果配置了独立undo表空间，这些文件对于事务回滚和MVCC是必需的。在干净关闭后，它们也应处于一致状态。如果它们是恢复所“必须”的，那么这个选项也应考虑。但题目只要求选两个。\n\n**考点总结:**\n此题考察MySQL 8.0在数据目录完全丢失后，从备份中恢复哪些核心文件才能使数据库干净重启。数据字典（`mysql.ibd`）和系统表空间（`ibdata1`）是最为关键的。\n\n**答案说明:** 在MySQL 8.0中，数据字典的`mysql.ibd`是最核心的。`ibdata1`的重要性取决于其中是否还包含关键系统数据（如undo日志）。如果undo日志已分离到独立表空间，则`ibdata1`的重要性会降低。但题目没有提供这方面信息。通常，恢复这两个文件是保证基本结构和系统表空间完整性的起点。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解MySQL 8.0数据字典的核心地位。区分哪些文件是绝对必需的，哪些是辅助性的或可以重建的。注意“干净关闭”这个条件，它意味着redo日志已基本同步。\n\n**学习建议:**\n学习MySQL 8.0的数据目录结构和关键文件的作用，特别是`mysql.ibd`（数据字典）、`ibdata1`（系统表空间）、`ib_logfile*`（redo日志）、`ibtmp1`（临时表空间）、`undo_*`（独立undo表空间）以及用户表的`.ibd`文件。了解不同关闭模式（`innodb_fast_shutdown`）对文件状态的影响。熟悉物理备份和恢复的最佳实践，以及哪些文件是恢复过程中的关键组成部分。"
    },
    {
        "question": "### 试题 111:\n\nExamine this command and output: `mysql> SELECT * FROM performance_schema.table_io_waits_summary_by_table WHERE COUNT_STAR > 0\\G`\n```\n*************************** 2.row ***************************\n    OBJECT_TYPE: TABLE\n  OBJECT_SCHEMA: test\n    OBJECT_NAME: demo_test\n     COUNT_STAR: 61567093\n   SUM_TIMER_WAIT: 59009007572922\n  MIN_TIMER_WAIT: 395922\n  AVG_TIMER_WAIT: 958095\n   MAX_TIMER_WAIT: 558852005358\n      COUNT_READ: 38665056\n SUM_TIMER_READ: 20598719962188\n  MIN_TIMER_READ: 395922\n  AVG_TIMER_READ: 532728\n   MAX_TIMER_READ: 558852005358\n     COUNT_WRITE: 22902028\nSUM_TIMER_WRITE: 38410287610743\n MIN_TIMER_WRITE: 1130688\n AVG_TIMER_WRITE: 1677006\n MAX_TIMER_WRITE: 17205682920\n     COUNT_FETCH: 38665056\nSUM_TIMER_FETCH: 20598719962188\n MIN_TIMER_FETCH: 395922\n AVG_TIMER_FETCH: 532728\n MAX_TIMER_FETCH: 558852005358\n   COUNT_DELETE: 22902028\nSUM_TIMER_DELETE: 38410287610743\n MIN_TIMER_DELETE: 1130688\n AVG_TIMER_DELETE: 1677006\n MAX_TIMER_DELETE: 17205682920\n```\nWhich two are true?",
        "selections": {
            "A": "I/O distribution is approximately 50/50 read/write.",
            "B": "The I/O average time is 532728. These columns aggregate all fetch operations",
            "C": "22902028 rows were deleted. These columns aggregate all delete operations.",
            "D": "Average read times are approximately three times faster than writes.",
            "E": "The longest I/O wait was for writes."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n分析`performance_schema.table_io_waits_summary_by_table`的输出：\n- `AVG_TIMER_READ`: 532728 (皮秒，ps)\n- `AVG_TIMER_WRITE`: 1677006 (皮秒，ps)\n- `COUNT_READ`: 38665056\n- `COUNT_WRITE`: 22902028\n- `COUNT_DELETE`: 22902028 (这里 `COUNT_DELETE` 和 `AVG_TIMER_DELETE` 的值与 `COUNT_WRITE` 和 `AVG_TIMER_WRITE` 完全相同，这可能意味着对于这个表，写操作主要是删除操作，或者统计上将删除归为写操作的一部分。)\n- `MAX_TIMER_READ`: 558852005358 (ps)\n- `MAX_TIMER_WRITE`: 17205682920 (ps)\n\nC) `22902028`行被删除。`COUNT_DELETE`字段聚合了所有删除操作的计数 (C 正确，假设这里的统计是准确的，并且`COUNT_DELETE`确实代表删除的行数或操作次数)。\nD) 平均读时间 (`AVG_TIMER_READ` = 532728 ps) 大约是平均写时间 (`AVG_TIMER_WRITE` = 1677006 ps) 的 1/3。换句话说，平均读操作比平均写操作快大约3倍 (1677006 / 532728 ≈ 3.148) (D 正确)。\n\n错误选项分析：\nA) I/O操作次数分布：读操作次数 (`COUNT_READ` = 38,665,056) 大约是写操作次数 (`COUNT_WRITE` = 22,902,028) 的 1.69倍 (38.6M / 22.9M ≈ 1.69)。所以不是约50/50的读写分布。\nB) I/O平均时间是`AVG_TIMER_WAIT` = 958095 ps。`AVG_TIMER_FETCH` = 532728 ps，这个值聚合了所有`FETCH`（通常指读取行）操作的平均时间，而不是所有I/O操作的平均时间。\nE) 最长的I/O等待时间：`MAX_TIMER_READ` (约558秒) 远大于 `MAX_TIMER_WRITE` (约17秒)。所以最长的I/O等待是读操作，而不是写操作。\n\n**考点总结:**\n此题考察对Performance Schema中表I/O统计信息（特别是`table_io_waits_summary_by_table`视图或其底层表）的解读能力。需要理解各个统计字段（如`COUNT_*`, `SUM_TIMER_*`, `AVG_TIMER_*`, `MAX_TIMER_*`）的含义，并能进行简单的比较和计算。时间单位通常是皮秒(ps)。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细阅读每个统计字段的名称，理解它是计数、总时间、平均时间还是最大/最小时间。注意时间单位（通常是皮秒，1秒 = 10^12 皮秒）。进行比较时要小心数量级。\n\n**学习建议:**\n学习使用MySQL Performance Schema来监控数据库性能。熟悉与I/O相关的表和视图，如`events_waits_summary_by_table_io_latency` (底层表), `table_io_waits_summary_by_index_usage`, `table_io_waits_summary_by_table`等。了解如何通过这些统计信息来识别I/O瓶颈和分析特定表的I/O模式。"
    },
    {
        "question": "### 试题 112:\n\nChoose two. Which two statements are true about using backups of the binary log?",
        "selections": {
            "A": "Binary logs are relatively small, and therefore, excellent for long-term storage and disaster recovery.",
            "B": "Binary logs can always be used to unapply unwanted schema changes.",
            "C": "Multiple binary logs can be used to restore data.",
            "D": "They allow for point-in-time recovery of the data.",
            "E": "Multiple binary logs can be applied in parallel for faster data restoration."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n二进制日志（binary logs）是MySQL进行时间点恢复和复制的基础。\nC) 多个二进制日志文件可以被用来恢复数据。通常，在进行时间点恢复时，会先恢复一个全量备份，然后按顺序应用自该备份以来产生的所有相关二进制日志文件中的事件 (C 正确)。\nD) 它们允许进行数据的时间点恢复（Point-in-Time Recovery, PITR）。通过结合全量备份和后续的二进制日志，可以将数据库恢复到过去的任意一个特定时间点 (D 正确)。\n\n错误选项分析：\nA) 二进制日志的大小取决于事务量和`binlog_format`。在高负载的系统上，二进制日志可能会快速增长，变得非常大。因此，它们不一定“相对较小”。长期存储和灾难恢复通常依赖于定期全量备份和增量备份，以及对binlog的合理保留策略，而不是仅仅依赖binlog本身的小巧。\nB) 二进制日志记录的是已发生的更改。要“撤销”不想要的模式更改（如错误的`ALTER TABLE`），通常不能直接通过“反向应用”二进制日志来实现（除非是非常简单的、可逆的操作，并且有专门工具或技巧）。更常见的方法是从更改发生前的备份和binlog恢复，或者手动执行反向的DDL操作（如果可能）。\nE) `mysqlbinlog`工具通常是单线程地按顺序应用二进制日志事件以保证数据一致性。虽然可以将多个binlog文件串联起来输入给`mysqlbinlog`，但事件本身是串行应用的。并行应用binlog（如MySQL 5.6+的并行复制SQL线程）是在从库复制场景下，而不是`mysqlbinlog`直接恢复数据时。\n\n**考点总结:**\n此题再次考察MySQL二进制日志在数据恢复中的核心作用：支持多日志文件恢复和实现时间点恢复。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住二进制日志的两大核心用途：复制和时间点恢复。理解时间点恢复是如何通过全备+binlog实现的。区分binlog作为“事件流”的特性。\n\n**学习建议:**\n深入学习基于二进制日志的时间点恢复（PITR）的完整流程，包括如何找到正确的备份、如何确定需要应用的binlog范围（基于时间或位置/GTID）、如何使用`mysqlbinlog`工具提取和应用事件。了解binlog的管理策略，如保留周期、自动清理、轮转等。"
    },
    {
        "question": "### 试题 113:\n\nExamine this command, which executes successfully on InnoDB Cluster: `dba.dropMetadataSchema()`\nWhich two statements are true?",
        "selections": {
            "A": "The command drops the mysql_innodb_cluster_metadata schema and re-creates it.",
            "B": "The mysql_innodb_cluster_metadata schema is dropped from the instance where the connection was established.",
            "C": "Connections driven by MySQL Router are not affected by the command.",
            "D": "The mysql_innodb_cluster_metadata schema is dropped from all reachable members of the cluster.",
            "E": "Group Replication will be dissolved and all metadata purged.",
            "F": "Group Replication is still operational, but InnoDB Cluster must be reimported under MySQL Shell."
        },
        "answers": [
            "D",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题93内容几乎完全相同，只是选项顺序可能不同。\n`dba.dropMetadataSchema()`命令删除InnoDB集群的元数据模式。\nD) 该命令会尝试从集群中所有可达的成员实例上删除元数据模式 (D 正确)。\nF) 删除元数据模式后，底层的组复制本身可能仍然在运行，但InnoDB集群的管理层面会失效。要恢复集群管理，通常需要重新配置或“重新导入”集群的元数据到MySQL Shell中 (F 正确)。\n\n错误选项分析同试题93。\n**OCR答案提示“元数据已经没有”暗示C是错误的。**\n**OCR答案提示“不重建”暗示A是错误的。**\n**OCR答案提示“需要执行dissolve”暗示E是错误的，因为`dropMetadataSchema`不直接等同于`dissolveCluster`。**\n\n**考点总结:**\n再次强调删除InnoDB集群元数据模式会破坏集群的管理层面，但底层组复制可能短暂存活。恢复通常需要重新配置。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，加强记忆。理解元数据模式对集群管理的重要性。\n\n**学习建议:**\n参考试题93的学习建议。重点是区分集群管理元数据和组复制本身的运行状态。"
    },
    {
        "question": "### 试题 114:\n\nChoose two. You are backing up raw InnoDB files by using `mysqlbackup`.\nWhich two groups of files will be backed up during a full backup?",
        "selections": {
            "A": "*.ibd files",
            "B": "ibbackup files",
            "C": "*.CSM files",
            "D": "ib_logfile* files",
            "E": "*.sdi files"
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlbackup`（MySQL Enterprise Backup）执行的是物理备份，它会备份构成MySQL实例数据和结构的所有必要文件。\nA) `*.ibd`文件：如果`innodb_file_per_table=ON`（通常是默认值），每个InnoDB表的数据和索引会存储在各自的`.ibd`文件中。这些是用户数据的主要载体，物理备份必须包含它们 (A 正确)。\nD) `ib_logfile*`文件：这些是InnoDB的redo日志文件，对于事务的持久性和崩溃恢复至关重要。物理备份必须包含它们以确保恢复后数据的一致性 (D 正确)。\n\n除了A和D，一个完整的物理备份通常还会包括：\n-   系统表空间文件（如`ibdata1`），因为它包含数据字典（MySQL 8.0之前的版本）、双写缓冲、修改缓冲、undo日志（如果未独立配置）等。\n-   MySQL 8.0的数据字典文件（`mysql.ibd`）。\n-   二进制日志文件（如果需要进行时间点恢复）。\n-   MySQL配置文件（`my.cnf`或`my.ini`）通常也建议备份，但不一定是`mysqlbackup`工具直接备份的内容，可能需要手动复制。\n-   独立undo表空间文件（`undo_*`），如果配置了。\n\n错误选项分析：\nB) “ibbackup files”：`ibbackup`是早期InnoDB Hot Backup工具的名称，后来演变为MySQL Enterprise Backup。备份产生的是数据文件和日志文件的副本，而不是名为“ibbackup files”的特定类型文件。\nC) `*.CSM`文件：这是MyISAM表用于压缩索引的辅助文件，与InnoDB无关。如果数据库中没有MyISAM表，就不会有这些文件。\nE) `*.sdi`文件：在MySQL 8.0中，SDI（Serialized Dictionary Information）存储了表的元数据。对于InnoDB表，SDI信息内嵌在`.ibd`表空间文件中。对于其他引擎的表，可能会生成单独的`.sdi`文件。虽然SDI信息是备份的一部分（通过备份`.ibd`文件间接包含），但单独说备份“*.sdi files”不完全准确，也不是InnoDB物理备份的核心文件组（因为它是内嵌的）。\n\n**考点总结:**\n此题考察使用`mysqlbackup`进行InnoDB物理备份时，哪些核心文件组会被包含。主要是数据文件（`.ibd`、系统表空间）和redo日志文件。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解物理备份的本质——复制构成数据库实例的物理文件。思考哪些文件对于InnoDB的数据存储、事务处理和恢复是必不可少的。\n\n**学习建议:**\n学习MySQL Enterprise Backup (`mysqlbackup`) 的工作原理和不同类型的备份（完全、增量、差异、压缩、加密）。了解在备份和恢复过程中涉及到的主要文件类型和目录结构。熟悉InnoDB的存储结构，特别是数据文件、日志文件和数据字典的存放位置。"
    },
    {
        "question": "### 试题 115:\n\nChoose two. Which two are characteristics of snapshot-based backups?",
        "selections": {
            "A": "The frozen file system can be cloned to another virtual machine immediately into active service.",
            "B": "There is no need for InnoDB tables to perform its own recovery when restoring from the snapshot backup.",
            "C": "Snapshot-based backups greatly reduce time during which the database and applications are unavailable.",
            "D": "A separate physical copy must be made before releasing the snapshot backup.",
            "E": "Snapshot backups can be used only in virtual machines."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n文件系统快照备份是一种物理备份技术。\nC) 基于快照的备份大大减少了数据库和应用程序不可用的时间。创建快照本身通常非常快（秒级或毫秒级），在此期间数据库可能需要短暂锁定（如使用`FLUSH TABLES WITH READ LOCK`）以确保文件系统一致性，但这个锁定时间远短于传统冷备份或某些热备份的准备时间 (C 正确)。\nD) 创建快照后，通常需要将快照中的数据复制到独立的备份存储介质上，然后才能释放快照（删除快照）。这是因为快照通常依赖于原始卷，并且会随着原始卷数据的更改而增长。为了获得一个独立的、可长期保存的备份副本，需要进行一次物理复制 (D 正确)。\n\n错误选项分析：\nA) 将一个“冻结”的文件系统快照克隆到另一个虚拟机并立即投入“活动服务”可能并不总是直接可行。恢复后，MySQL服务器（特别是InnoDB）需要进行启动和崩溃恢复过程，以确保数据一致性并应用redo日志。直接将快照文件用于新实例可能需要额外的配置和恢复步骤。\nB) 从文件系统快照恢复后，InnoDB表仍然需要执行其自身的崩溃恢复过程。快照保证了文件系统层面的一致性（在快照创建点），但InnoDB需要通过应用redo日志来完成任何在快照点时尚未完全写入数据文件的事务，并回滚未提交的事务，以达到事务层面的一致性。\nE) 文件系统快照技术不仅限于虚拟机。许多物理存储系统（如SAN、NAS）、文件系统（如LVM、ZFS、Btrfs）和操作系统都支持快照功能，可以在物理服务器上使用。\n\n**考点总结:**\n此题考察对文件系统快照备份特性的理解，特别是其创建速度、对应用影响、后续处理以及恢复过程。核心优点是备份窗口小，但恢复时仍需数据库引擎进行恢复。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解快照的“时间点副本”特性和“写时复制”原理。将其与传统备份方法对比，分析其在备份耗时、恢复步骤和适用环境上的差异。\n\n**学习建议:**\n学习使用文件系统快照（如LVM快照）进行MySQL备份的方法。了解如何确保快照的一致性（例如，通过`FLUSH TABLES WITH READ LOCK`或依赖InnoDB的崩溃恢复能力）。熟悉从快照恢复MySQL的步骤，包括恢复文件、启动服务器并让InnoDB执行恢复。了解不同快照技术的实现差异和优缺点。"
    },
    {
        "question": "### 试题 116:\n\nChoose three. Examine these statements, which execute successfully:\n```sql\nTRUNCATE test;\nBEGIN;\nINSERT INTO test (id, name) VALUES (1, 'Hello');\nROLLBACK;\nSELECT id FROM test;\n```\nWhich three storage engines would return a nonempty recordset for the `test` table when executing the statements?",
        "selections": {
            "A": "MEMORY",
            "B": "BLACKHOLE",
            "C": "ARCHIVE",
            "D": "NDB",
            "E": "MyISAM",
            "F": "InnoDB"
        },
        "answers": [
            "A",
            "C",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nSQL语句序列：\n1.  `TRUNCATE test;`: 清空`test`表。`TRUNCATE`通常是一个DDL操作，在某些引擎上可能无法回滚，或者其行为可能不受后续事务控制。\n2.  `BEGIN;`: 开始一个事务。\n3.  `INSERT INTO test (id, name) VALUES (1, 'Hello');`: 在事务中插入一行数据。\n4.  `ROLLBACK;`: 回滚当前事务。\n5.  `SELECT id FROM test;`: 查询`test`表。\n\n关键在于`TRUNCATE`和`ROLLBACK`对不同存储引擎的影响。\n-   事务型存储引擎（如InnoDB, NDB）：`ROLLBACK`会撤销事务中的`INSERT`操作。如果`TRUNCATE`也被视为事务的一部分并能回滚，则表为空。如果`TRUNCATE`是DDL且隐式提交（或在事务外执行），则事务中的`INSERT`被回滚，表也为空。\n-   非事务型存储引擎（如MyISAM, MEMORY, ARCHIVE）：`BEGIN`和`ROLLBACK`对它们无效。`INSERT`操作会立即生效。`TRUNCATE`会清空表。\n\n让我们分析每个选项：\nA) MEMORY：是非事务性的。`TRUNCATE`清空表。`BEGIN`和`ROLLBACK`无效。`INSERT`会插入数据。因此，`SELECT`会返回刚插入的行 (A 正确)。\nE) MyISAM：是非事务性的。行为同MEMORY引擎。`SELECT`会返回插入的行 (E 正确)。\nC) ARCHIVE：也是非事务性的，且只支持`INSERT`和`SELECT`。`TRUNCATE`会清空表（如果支持）。`INSERT`会插入数据。`ROLLBACK`无效。`SELECT`会返回插入的行 (C 正确)。\n\n错误选项分析：\nF) InnoDB：是事务性的。`TRUNCATE TABLE`在InnoDB中通常是一个DDL操作，它会隐式提交任何活动事务（取决于版本和配置，但通常如此）。即使假设`TRUNCATE`在事务开始前执行，那么事务中的`INSERT`会被`ROLLBACK`撤销。因此，`SELECT`会返回空结果集。\nB) BLACKHOLE：这个引擎不存储任何数据。`INSERT`操作会被接受但数据会丢失。`SELECT`总是返回空结果集。\nD) NDB (MySQL Cluster)：是事务性的。行为类似于InnoDB。`TRUNCATE`后，事务中的`INSERT`被`ROLLBACK`，表为空。\n\n**考点总结:**\n此题考察不同MySQL存储引擎对事务（`BEGIN`, `ROLLBACK`）和`TRUNCATE`操作的支持和行为差异。核心在于区分事务型引擎和非事务型引擎。\n\n**OCR答案提示中P129, P137可能指向了相关文档页码，需要核实。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n牢记哪些存储引擎是事务安全的，哪些不是。理解`BEGIN`, `COMMIT`, `ROLLBACK`对不同引擎的影响。注意`TRUNCATE`操作的特殊性（通常是DDL，可能无法回滚或有隐式提交）。\n\n**学习建议:**\n详细学习MySQL中主要存储引擎的特性，特别是对事务的支持。进行实验来观察不同引擎在执行包含事务控制语句和DDL语句的SQL序列时的行为。了解`TRUNCATE TABLE`与`DELETE FROM TABLE`的区别及其对事务的影响。"
    },
    {
        "question": "### 试题 117:\n\nChoose two. Which two statements are true about the `mysql_config_editor` program?",
        "selections": {
            "A": "It provides an interface to change my.cnf files.",
            "B": "It can move datadir to a new location.",
            "C": "It will use client options by default unless you provide --login-path.",
            "D": "It can be used to create and edit SSL certificates and log locations.",
            "E": "It manages the configuration of user privileges for accessing the server.",
            "F": "It manages the configuration of the MySQL Firewall feature.",
            "G": "It manages the configuration of client programs."
        },
        "answers": [
            "C",
            "G"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题79内容几乎完全相同，只是选项顺序和其中一个正确选项的表述略有不同。\n`mysql_config_editor`用于创建和管理加密的登录路径选项文件 (`~/.mylogin.cnf`)，供客户端程序使用。\nG) 它管理客户端程序的配置（通过创建登录路径） (G 正确，与试题79的B选项内容一致)。\nC) 如果`.mylogin.cnf`中存在默认的登录路径（如名为`[client]`的组），并且客户端程序在启动时没有指定`--login-path`，那么客户端可能会尝试使用这个默认登录路径下的选项。或者说，`mysql_config_editor`创建的登录路径只有在被客户端明确通过`--login-path`引用时才会被使用，否则客户端会按其默认顺序查找其他选项 (C 正确，与试题79的E选项内容和解释相似)。\n\n错误选项分析同试题79。\n**OCR答案提示“这个工具不光管理密码，还管理：主机名 端口号 文件名 用户名”是正确的，这些都可以在登录路径中定义。**\n\n**考点总结:**\n再次强调`mysql_config_editor`的核心功能是安全地存储和管理MySQL客户端连接参数（登录路径）。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，加强记忆。记住`mysql_config_editor`与客户端连接参数和`.mylogin.cnf`文件的关系。\n\n**学习建议:**\n参考试题79的学习建议。重点是理解`mysql_config_editor`如何简化和保护客户端连接配置。"
    },
    {
        "question": "### 试题 118:\n\nChoose two. Which two statements are true about the binary log encryption feature?",
        "selections": {
            "A": "It requires a keyring plugin.",
            "B": "When enabled it encrypts existing binary logs.",
            "C": "It can be set at run time.",
            "D": "It can be activated per session.",
            "E": "It encrypts any connecting slaves connection thread."
        },
        "answers": [
            "A",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL二进制日志加密（Binary Log Encryption）功能用于保护存储在磁盘上的二进制日志文件和中继日志文件的内容。\nA) 它需要一个密钥环插件（keyring plugin）来管理加密密钥。主加密密钥（master key for binary log encryption）存储在密钥环中 (A 正确)。\nC) `binlog_encryption`系统变量可以动态设置（在运行时通过`SET GLOBAL binlog_encryption = ON/OFF;`），从而启用或禁用新产生的二进制日志和中继日志的加密。但是，一旦启用，通常不能轻易在运行时完全禁用而不产生影响 (C 正确，指可以动态开启)。\n\n错误选项分析：\nB) 当启用二进制日志加密时，它只对新创建的二进制日志文件和中继日志文件进行加密。已经存在的、未加密的旧日志文件不会被自动加密。\nD) 二进制日志加密是一个全局服务器设置，不是会话级别的。它影响所有写入二进制日志的操作。\nE) 二进制日志加密保护的是磁盘上的日志文件内容。它不直接加密从库的连接线程。从库与主库之间的网络通信加密是由SSL/TLS连接负责的。\n\n**考点总结:**\n此题考察MySQL二进制日志加密的关键特性：依赖密钥环插件进行密钥管理，只加密新日志，并且是一个全局运行时可配置的特性。\n\n**OCR答案提示中关于“DynamicExisting binary log files and relay log files still present on the server are not encrypted”是正确的，强调了不加密现有日志。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n将二进制日志加密与InnoDB静态数据加密（TDE）进行类比，它们都依赖密钥环。理解加密通常作用于“新产生”的数据或文件。\n\n**学习建议:**\n学习MySQL的二进制日志加密功能，包括其配置步骤（安装和配置密钥环插件、设置`binlog_encryption=ON`）、工作原理（使用主密钥和文件密钥）、对性能的影响以及相关的管理操作（如密钥轮转）。了解它如何增强数据安全性，特别是在日志文件可能被未授权访问的场景下。"
    },
    {
        "question": "### 试题 119:\n\nChoose two. Examine this MySQL client command to connect to a remote database: `mysql -h remote.example.org -u root -p --protocol=TCP --ssl-mode=VALUE`\nWhich two `--ssl-mode` values will ensure that an X.509-compliant certificate will be used to establish the SSL/TLS connection to MySQL?",
        "selections": {
            "A": "DISABLED",
            "B": "REQUIRED",
            "C": "VERIFY_IDENTITY",
            "D": "PREFERRED",
            "E": "VERIFY_CA"
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`--ssl-mode`客户端选项控制SSL/TLS连接的行为和验证级别。\nC) `VERIFY_IDENTITY`：在此模式下，客户端不仅会验证服务器证书是否由受信任的CA签发（通过`--ssl-ca`指定的CA证书），还会验证服务器证书中的主机名（CN或SAN）是否与客户端连接时指定的主机名匹配。这提供了最强的身份验证，确保连接到的是正确的服务器，并且使用了有效的X.509证书 (C 正确)。\nE) `VERIFY_CA`：在此模式下，客户端会验证服务器提供的证书是否由客户端信任的CA（通过`--ssl-ca`指定）签发。这确保了服务器证书的真实性，并且是X.509证书体系的一部分 (E 正确)。\n\n错误选项分析：\nA) `DISABLED`：完全禁用SSL/TLS连接，使用未加密的连接。\nB) `REQUIRED`：强制使用SSL/TLS连接，但不进行服务器证书验证。连接会被加密，但客户端不验证服务器身份，容易受到中间人攻击。\nD) `PREFERRED`：客户端会尝试建立SSL/TLS连接。如果服务器支持SSL且协商成功，则使用加密连接（不进行验证）。如果无法建立SSL连接，则会退回到未加密连接。\n\n**考点总结:**\n此题考察MySQL客户端`--ssl-mode`选项不同值的含义，特别是哪些值能确保使用经过验证的X.509证书进行安全连接。`VERIFY_CA`和`VERIFY_IDENTITY`提供了不同级别的服务器身份验证。\n\n**OCR答案提示指向了P39，可能是相关文档页码。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解不同`--ssl-mode`值提供的安全级别。`DISABLED` < `PREFERRED` < `REQUIRED` < `VERIFY_CA` < `VERIFY_IDENTITY`（大致的安全强度递增）。“确保使用X.509兼容证书”意味着至少需要验证CA，而验证身份则更强。\n\n**学习建议:**\n学习如何为MySQL配置SSL/TLS加密连接，包括在服务器端生成和配置证书，以及在客户端配置连接参数（`--ssl-mode`, `--ssl-ca`, `--ssl-cert`, `--ssl-key`等）。掌握不同`--ssl-mode`值的确切行为和安全含义。了解证书颁发机构（CA）、服务器证书、客户端证书以及证书链验证的基本概念。"
    },
    {
        "question": "### 试题 120:\n\nChoose two. Examine this query and its output: \n```sql\nmysql> select user, statement, total, total_latency, max_latency, lock_latency, rows_sent, rows_examined, rows_affected, full_scans from sys.user_summary_by_statement_type where statement in ('select', 'insert', 'Quit');\n```\n\n| user | statement | total    | total_latency | max_latency | lock_latency | rows_sent   | rows_examined | rows_affected | full_scans |\n|------|-----------|----------|---------------|-------------|--------------|-------------|---------------|---------------|------------|\n| app  | select    | 919866   | 2.41 h        | 330.01 ms   | 1.52 m       | 542614816   | 542614816     | 0             | 919958     |\n| app  | insert    | 923070   | 1.66 h        | 287.41 ms   | 1.65 m       | 0           | 0             | 923026        | 0          |\n| app  | Quit      | 679892   | 9.54 s        | 170.97 ms   | 0 ps         | 0           | 0             | 0             | 0          |\n| bob  | select    | 344964   | 53.61 m       | 328.42 ms   | 34.51 s      | 203509545   | 203509542     | 0             | 344847     |\n| bob  | insert    | 346159   | 37.94 m       | 235.77 ms   | 36.94 s      | 0           | 0             | 346175        | 0          |\n| bob  | Quit      | 254971   | 3.65 s        | 69.91 ms    | 0 ps         | 0           | 0             | 0             | 0          |\n| root | select    | 230621   | 36.88 m       | 170.63 ms   | 21.47 s      | 135639074   | 135644067     | 0             | 230595     |\n| root | insert    | 231585   | 25.86 m       | 364.22 ms   | 31.45 s      | 0           | 0             | 4150423       | 0          |\n| root | Quit      | 130141   | 2.24 s        | 130.14 ms   | 0 ps         | 0           | 0             | 0             | 0          |\n\nWhich two statements are true?",
        "selections": {
            "A": "User bob had a significantly higher ratio of SELECT + INSERT statements to QUIT than both app and root users.",
            "B": "User bob had the largest total time waiting for locks.",
            "C": "The app user had the highest total number of rows read from storage engines.",
            "D": "The root user had the largest number of modified rows for a SELECT statement.",
            "E": "The root user had the largest single wait time."
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n分析`sys.user_summary_by_statement_type`的输出数据：\nC) `app`用户读取的总行数（`rows_examined` for `select`）是 542,614,816。`bob`用户是 203,509,542。`root`用户是 135,644,067。因此，`app`用户读取的总行数最高 (C 正确)。\nE) `root`用户的单次最大等待时间 (`max_latency`) 分别是：select 170.63ms, insert 364.22ms。 `app`用户：select 330.01ms, insert 287.41ms。 `bob`用户：select 328.42ms, insert 235.77ms。 比较所有用户的`max_latency`，`root`用户的`insert`操作的`max_latency` (364.22ms) 是所有显示的操作中最高的单次等待时间 (E 正确)。 (注意：`total_latency`是总延迟，`max_latency`是单次最大延迟，`lock_latency`是总锁等待时间)。\n\n错误选项分析：\nA) 计算 SELECT+INSERT 与 QUIT 的比率：\n   - app: (919866+923070) / 679892 ≈ 1842936 / 679892 ≈ 2.71\n   - bob: (344964+346159) / 254971 ≈ 691123 / 254971 ≈ 2.71\n   - root: (230621+231585) / 130141 ≈ 462206 / 130141 ≈ 3.55\n   `root`用户的比率最高，不是`bob`。\nB) 总锁等待时间 (`lock_latency`)：\n   - app: select 1.52m (≈91.2s), insert 1.65m (≈99s)。总计约 190.2s。\n   - bob: select 34.51s, insert 36.94s。总计约 71.45s。\n   - root: select 21.47s, insert 31.45s。总计约 52.92s。\n   `app`用户的总锁等待时间最长。\nD) `SELECT`语句不修改行（`rows_affected`应该为0或接近0，除非是`SELECT ... FOR UPDATE`等）。`rows_affected`主要看`INSERT`语句。`root`用户的`INSERT`影响了4,150,423行，是所有用户中最高的。但题目说“for a SELECT statement”，这是矛盾的。\n\n**考点总结:**\n此题考察对`sys.user_summary_by_statement_type`视图输出的解读能力，需要理解各个统计列的含义并能进行简单的计算和比较。\n\n**OCR答案提示“D modifid 有问题。root 账号 select insert quit 操作 B不对,锁等待最多的是 app 用户,他是分钟。这个答案应该是 ce”基本正确。D确实有问题，B的判断也正确。最终答案CE符合分析。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细阅读列名，确保理解其确切含义（例如，区分`total_latency`和`max_latency`，`rows_sent`和`rows_examined`和`rows_affected`）。进行计算时要小心单位（如h, m, s, ms, ps）。\n\n**学习建议:**\n学习使用MySQL `sys` schema中的各种视图来监控和诊断性能问题。熟悉`user_summary_by_statement_type`等常用视图的列定义和它们提供的信息。练习从这些视图中提取关键性能指标并进行分析。"
    },
    {
        "question": "### 试题 121:\n\nExamine this SQL statement: `mysql> GRANT r_read@localhost TO mark WITH ADMIN OPTION;`\nWhich two are true? (Choose two.)",
        "selections": {
            "A": "Mark can grant the privileges assigned to the r_read@localhost role to another user.",
            "B": "ADMIN OPTION causes the role to be activated by default.",
            "C": "Mark can grant the r_read@localhost role to another user.",
            "D": "Mark can revoke the r_read@localhost role from another role.",
            "E": "ADMIN OPTION allows Mark to drop the role.",
            "F": "Mark must connect from localhost to activate the r_read@localhost role."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题12内容几乎完全相同，只是选项顺序可能不同。\n`GRANT role TO user WITH ADMIN OPTION` 授予用户`mark`角色`r_read@localhost`，并赋予`mark`管理此角色的权限。\nC) Mark可以将`r_read@localhost`角色授予其他用户 (C 正确)。\nD) Mark可以从其他用户（或其他角色，如果角色可以被授予给角色）那里撤销`r_read@localhost`角色 (D 正确)。\n\n错误选项分析同试题12。\n\n**考点总结:**\n再次强调`WITH ADMIN OPTION`子句在角色授予时的作用：允许被授权者将该角色传递给他人或从他人处收回，但不直接传递角色内部权限的授予权。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，加强记忆。清晰区分`WITH ADMIN OPTION` (用于角色管理权) 和 `WITH GRANT OPTION` (用于权限授予权)。\n\n**学习建议:**\n参考试题12的学习建议。熟练掌握MySQL角色管理的SQL命令和权限机制。"
    },
    {
        "question": "### 试题 122:\n\nChoose two. Which two statements are true about MySQL Installer?",
        "selections": {
            "A": "It provides only GUI-driven, interactive installations.",
            "B": "It installs most Oracle MySQL products.",
            "C": "Manual download of separate product packages is required before installing them through MySQL Installer.",
            "D": "It provides a uniform installation wizard across multiple platforms.",
            "E": "It performs product upgrades."
        },
        "answers": [
            "B",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL Installer是Windows平台上的一个图形化安装和配置工具。\nB) 它可以安装Oracle提供的大多数MySQL相关产品，包括MySQL Server、MySQL Workbench、Connector/ODBC、Connector/NET、Connector/Python、MySQL Shell、MySQL Router等 (B 正确)。\nC) MySQL Installer本身是一个安装器和下载管理器。它会列出可用的MySQL产品及其版本。用户选择要安装的产品后，Installer会负责从Oracle服务器下载这些产品的安装包，然后再进行安装。所以，用户通常不需要预先手动下载单独的产品包 (C 选项表述为“需要手动下载”是错误的。但如果理解为Installer会去下载，而不是用户预先下载，则C的字面意思不符。让我们重新审视。MySQL Installer通常包含一个初始的较小的安装程序，它会连接到互联网以下载选定组件的最新版本。所以，用户下载的是Installer本身，然后Installer再去下载具体产品。如果理解为“通过Installer安装前，Installer需要下载”，那可以。但如果理解为“用户需要先手动下载所有产品包，再用Installer安装”，那不对。OCR标记C为正确，可能是指Installer会去下载最新的包，而不是使用Installer自带的旧包。)\n\n让我们重新审视C，并结合通常理解：MySQL Installer的一个主要功能就是简化下载和安装过程。用户运行Installer，选择产品，Installer负责下载和安装。因此，用户“手动下载独立产品包”不是通过Installer安装前的“必需”步骤。所以C的字面描述更像是错误的。\n\n让我们检查其他选项：\nE) MySQL Installer也支持产品升级。当新版本可用时，它可以帮助用户升级已安装的MySQL产品 (E 正确，OCR标记为错误，但根据功能应为正确)。\n\n如果必须选两个，并且假设C的OCR标记是准确的（尽管其字面意思有争议），那么我们需要再找一个。B是明确正确的。\n\n让我们再看一遍所有选项和通常认知：\nB) 正确。Installer是MySQL产品套件的安装中心。\nE) 正确。Installer支持升级。\n\n如果C的OCR标记正确，而E的OCR标记错误，那么B和C是答案。但C的字面意思“需要手动下载独立包”通常被认为是Installer试图避免的。如果C的含义是“Installer在安装前会（自动）下载独立包”，那可以理解。\n\n**重新评估，并基于MySQL Installer的常见用法：**\nMySQL Installer会在线检查并下载最新的可用组件。用户不需要在运行Installer之前手动下载每个组件的安装包。所以C选项“Manual download of separate product packages is required before installing them through MySQL Installer”字面意思是错误的。\n\n**考虑到可能是题目理解或OCR错误，我们优先选择明确正确的。**\nB是明确正确的。\nE（执行产品升级）也是Installer的一个重要功能，通常被认为是正确的。\n\n如果答案是B和C（如OCR标记），则C的理解必须是Installer自身会去下载，而不是用户在运行Installer前就需要准备好所有包。\n\n**考点总结:**\n此题考察对MySQL Installer (Windows版) 功能的了解。它是一个集成的安装、配置和升级工具，能管理多个MySQL产品。\n\n**基于对MySQL Installer功能的普遍认知，E (执行产品升级) 应该是正确的。C的表述具有歧义。如果必须严格按OCR的标记选B和C，则需要对C有特定解读。**\n**假设此题的正确答案确实如某些题库所示为B和C，则C的解释为：MySQL Installer在执行安装前，会根据用户的选择去Oracle的服务器上下载相应的产品安装包。这个“下载”过程可以被认为是“安装前需要下载包”，尽管是Installer自动完成的。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n了解MySQL Installer的主要功能：安装、配置、管理和升级MySQL系列产品（在Windows上）。注意其在线特性（下载最新版本）。\n\n**学习建议:**\n如果使用Windows环境，建议实际操作MySQL Installer。了解其界面、安装选项、可管理的产品列表以及升级流程。阅读官方文档中关于MySQL Installer的说明。"
    },
    {
        "question": "### 试题 123:\n\nChoose three. Which three actions are effective in capacity planning?",
        "selections": {
            "A": "adding circular replication nodes for increased DML capability",
            "B": "buying more RAM",
            "C": "buying more disk",
            "D": "buying more CPU",
            "E": "basing expected growth on an average of the last 3 years",
            "F": "upgrading to the latest application version",
            "G": "monitoring OS resources for patterns",
            "H": "consulting the application team about any future projects and use"
        },
        "answers": [
            "E",
            "G",
            "H"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n容量规划（Capacity Planning）是预测未来资源需求并制定计划以满足这些需求的过程。有效的容量规划活动包括：\nE) 基于过去3年的平均增长来预测未来的预期增长。历史数据是预测未来趋势的重要依据 (E 正确)。\nG) 监控操作系统资源的使用模式。通过监控CPU、内存、磁盘I/O、网络等资源的使用情况，可以识别瓶颈、了解当前消耗，并预测何时可能达到容量上限 (G 正确)。\nH) 与应用程序团队商讨任何未来的项目和使用情况。了解业务发展计划、新功能上线、用户增长预期等，对于准确预测未来的资源需求至关重要 (H 正确)。\n\n错误选项分析：\nA) “添加循环复制节点以增加DML能力”：循环复制（如环形复制）通常用于特定的高可用或数据分发场景，不一定是提高DML能力的通用方法，且管理复杂，可能引入冲突。增加DML能力更多考虑主库性能、分片、读写分离等。\nB), C), D) “购买更多RAM/磁盘/CPU”：这些是解决容量不足的“行动”，而不是容量规划的“活动”本身。容量规划是“计划”阶段，其结果可能是需要购买更多硬件，但购买本身不是规划活动。\nF) “升级到最新的应用程序版本”：应用升级可能带来性能改进或资源消耗变化，是容量规划中需要考虑的一个因素，但升级本身不是容量规划活动。\n\n**考点总结:**\n此题考察容量规划的基本方法和活动。核心在于数据收集（历史数据、监控数据）、需求分析（业务预测、项目计划）和趋势预测。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分“规划活动”和“执行解决方​​案”。容量规划是关于“预测”和“计划”的。选择那些涉及数据收集、分析和沟通的选项。\n\n**学习建议:**\n学习数据库容量规划的基本流程和方法。了解如何收集和分析历史性能数据和资源使用数据。掌握如何与业务团队和应用团队沟通以获取未来需求信息。熟悉常见的容量预测模型和工具。了解不同类型的扩展策略（垂直扩展、水平扩展）及其对容量的影响。"
    },
    {
        "question": "### 试题 124:\n\nChoose the best answer. Four nodes are configured to use circular replication. Examine these configuration parameters for each node:\n```\nslave_parallel_type=DATABASE ;\nslave_parallel_workers=4\nslave_preserve_commit_order=0\n```\nWhich statement is true?",
        "selections": {
            "A": "Each slave thread is responsible for updating a specific database.",
            "B": "Cross-database constraints can cause database inconsistency.",
            "C": "Setting slave_parallel_type=DATABASE won't work for circular replication; it should be set to LOGICAL_CLOCK.",
            "D": "Increasing slave_parallel_workers will improve high availability.",
            "E": "Setting slave_preserve_commit_order to ON will improve data consistency.",
            "F": "Setting transaction_allow_batching to ON will improve data consistency."
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n配置参数：\n- `slave_parallel_type=DATABASE`: 从库并行复制按数据库级别分发事务给工作线程。\n- `slave_parallel_workers=4`: 有4个并行复制工作线程。\n- `slave_preserve_commit_order=0` (OFF): 不保证从库上事务的提交顺序与主库（或binlog中的顺序）完全一致。在并行应用时，不同数据库的事务可能乱序提交。\n\nB) 跨数据库约束可能导致数据库不一致。当`slave_parallel_type=DATABASE`且`slave_preserve_commit_order=0`时，如果存在跨多个数据库的约束（如外键，或应用逻辑依赖于跨库事务的特定顺序），并且这些数据库的事务被分配到不同的并行工作线程并行应用，可能会因为事务提交顺序与主库不一致而违反约束或导致数据不一致 (B 正确)。\n\n错误选项分析：\nA) 当`slave_parallel_type=DATABASE`时，SQL协调线程会将涉及不同数据库的事务分发给不同的工作线程。每个工作线程可能处理多个数据库的事务，而不是“一个工作线程负责一个特定数据库”。\nC) `slave_parallel_type=DATABASE`可以用于循环复制，但如B所述，在存在跨库约束且不保留提交顺序时有风险。`LOGICAL_CLOCK`是另一种并行复制类型，它基于主库事务的逻辑时间戳来并行化，通常能更好地保持事务依赖关系，特别是当`slave_preserve_commit_order=1`时。\nD) 增加并行复制工作线程数主要是为了提高从库应用binlog的吞吐量，减少复制延迟。它不直接“提高高可用性”。高可用性通常通过故障转移机制（如MHA, InnoDB Cluster, Orchestrator）实现。\nE) 将`slave_preserve_commit_order`设置为`ON`（即1）会强制从库上的事务提交顺序与主库（或binlog中的顺序）一致，这确实能提高数据一致性，尤其是在并行复制时。但题目给的配置是`slave_preserve_commit_order=0`。如果说“将它设置为ON会改善”，则正确，但选项是描述当前配置下的情况。\nF) `transaction_allow_batching`参数与事务批处理相关，主要影响binlog事件在网络传输和从库I/O线程处理时的行为，不直接影响SQL线程应用数据的一致性。数据一致性更多由`slave_parallel_type`和`slave_preserve_commit_order`控制。\n\n**考点总结:**\n此题考察MySQL并行复制的配置参数及其对数据一致性的影响，特别是在循环复制和存在跨数据库约束的场景下。`slave_parallel_type`, `slave_parallel_workers`, `slave_preserve_commit_order`是关键参数。\n\n**OCR答案提示中链接到5.7文档，但概念在8.0中仍然适用。`slave_preserve_commit_order=ON` (即1) 在多线程复制时，保证从库回放事务的顺序与主库提交顺序一致，这对于维护跨事务或跨库的一致性非常重要。当它为ON时，通常与`slave_parallel_type=LOGICAL_CLOCK`配合使用。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解并行复制不同策略（`DATABASE` vs `LOGICAL_CLOCK`）的特点和适用场景。关注`slave_preserve_commit_order`对事务提交顺序和数据一致性的影响。在循环复制中，数据一致性是特别需要关注的问题。\n\n**学习建议:**\n学习MySQL并行复制（Multi-Threaded Slave, MTS）的配置和调优。掌握`slave_parallel_type`, `slave_parallel_workers`, `slave_preserve_commit_order`, `binlog_group_commit_sync_delay`, `binlog_group_commit_sync_no_delay_count`等相关参数。了解并行复制在不同场景下的性能表现和潜在问题（如锁争用、一致性风险）。熟悉如何监控并行复制的状态。"
    },
    {
        "question": "### 试题 125:\n\nExamine this partial output for InnoDB Cluster status:\n```json\n{\n  \"topology\": {\n    \"host1:3377\": {\n      \"address\": \"host1:3377\",\n      \"mode\": \"R/W\",\n      \"status\": \"ONLINE\",\n      \"version\": \"8.0.18\"\n    },\n    \"host2:3377\": {\n      \"address\": \"host2:3377\",\n      \"mode\": \"R/O\",\n      \"status\": \"MISSING\"\n    },\n    \"host3:3377\": {\n      \"address\": \"host3:3377\",\n      \"mode\": \"R/O\",\n      \"status\": \"ONLINE\",\n      \"version\": \"8.0.18\"\n    }\n  }\n}\n```\nWhich statement explains the state of the instance deployed on host2?",
        "selections": {
            "A": "It can rejoin the cluster by using the command cluster.addInstance ('<user>@host3:3377').",
            "B": "It has been expelled from the cluster because of a transaction error.",
            "C": "It can be recovered from a donor instance on host3 by cloning using the command cluster.rejoinInstance ('<user>@host3:3377').",
            "D": "It has been removed from the cluster by using the command STOP GROUP_REPLICATION.",
            "E": "It can rejoin the cluster by using the command dba.rebootClusterFromCompleteOutage()."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n输出显示host2的状态为`MISSING`。这意味着集群无法联系到host2，或者host2已离开集群。host1是主（R/W），host3是备（R/O），两者都`ONLINE`。\nC) 它可以从host3（一个在线的donor实例）通过克隆恢复，并使用`cluster.rejoinInstance('<user>@host2_address:port_of_host2_to_rejoin>')`命令重新加入集群。当一个实例的状态是`MISSING`或因为故障离开集群但其元数据仍在时，`rejoinInstance`是尝试让它重新同步并加入集群的合适命令。如果数据差异过大或实例状态不佳，`rejoinInstance`可能会触发克隆操作从一个健康的成员恢复数据 (C 正确)。注意命令中的目标应该是host2自身，donor是集群自动选择或可指定的。\n\n错误选项分析：\nA) `cluster.addInstance()`通常用于向集群添加一个全新的、之前不属于集群的实例，或者在实例被彻底`removeInstance()`后重新添加。对于一个`MISSING`状态的现有成员，`rejoinInstance`是更合适的命令。\nB) “因为事务错误而被驱逐”是一种可能的原因，但`MISSING`状态本身只表示当前不可达或已离开，不直接说明原因。而且，即使是事务错误导致被隔离，恢复方法仍然是`rejoinInstance`或更复杂的修复。\nD) `STOP GROUP_REPLICATION`命令是在特定实例上停止组复制插件，这会导致该实例离开集群。如果这是host2`MISSING`的原因，那么恢复它仍然是通过启动组复制并尝试重新加入。\nE) `dba.rebootClusterFromCompleteOutage()`用于整个集群都宕机（失去法定数量）的极端情况下的恢复，不适用于单个成员`MISSING`的情况。\n\n**考点总结:**\n此题考察对InnoDB集群成员状态（特别是`MISSING`）的理解以及如何使离线或故障成员重新加入集群。`cluster.rejoinInstance()`是关键命令，它可能涉及数据同步（增量或克隆）。\n\n**OCR答案提示中的解释部分正确地指出了`rejoinInstance()`的适用性，并区分了`removeInstance()`后使用`addInstance()`的情况。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解InnoDB集群中不同成员状态（`ONLINE`, `OFFLINE`, `RECOVERING`, `MISSING`, `ERROR`等）的含义。熟悉AdminAPI中用于管理集群成员加入、离开和恢复的命令。\n\n**学习建议:**\n学习MySQL Shell AdminAPI的InnoDB集群管理功能。掌握`cluster.status()`, `cluster.addInstance()`, `cluster.removeInstance()`, `cluster.rejoinInstance()`, `cluster.rebootClusterFromCompleteOutage()`等命令的使用场景和参数。了解集群成员故障后的自动和手动恢复流程。熟悉克隆和增量恢复在`rejoinInstance`中的作用。"
    },
    {
        "question": "### 试题 126:\n\nChoose the best answer. Examine this command: `shell> mysqldump --no-create-info --all-databases --result-file=dump.sql`\nWhich statement is true?",
        "selections": {
            "A": "It will not write CREATE TABLESPACE statements.",
            "B": "It will not write CREATE LOGFILE GROUP statements.",
            "C": "It will not write CREATE DATABASE statements.",
            "D": "It will not write CREATE TABLE statements."
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqldump --no-create-info --all-databases --result-file=dump.sql`命令的作用：\n- `--no-create-info` (或 `-t`): 这个选项告诉`mysqldump`不要在输出中包含创建每个被转储表的`CREATE TABLE`语句。它只导出数据（`INSERT`语句）。\n- `--all-databases` (或 `-A`): 转储所有数据库。\n- `--result-file=dump.sql`: 将输出写入`dump.sql`文件。\n\nD) 它不会写入`CREATE TABLE`语句。这是`--no-create-info`选项的直接作用 (D 正确)。\n\n错误选项分析：\nA) `CREATE TABLESPACE`语句用于创建InnoDB通用表空间或NDB表空间。`mysqldump`主要关注数据库、表、视图、存储过程等的定义和数据。表空间的创建通常是独立管理，`mysqldump`不直接处理其`CREATE`语句，除非这些信息被嵌入到其他DDL中。\nB) `CREATE LOGFILE GROUP`语句用于创建NDB集群的日志文件组。这与常规`mysqldump`备份MySQL服务器实例（非特指NDB集群）的操作通常无关。\nC) `--all-databases`选项通常会包含`CREATE DATABASE IF NOT EXISTS db_name; USE db_name;`之类的语句来确保数据库在恢复时被创建并选中。`--no-create-info`主要影响的是`CREATE TABLE`，不一定影响`CREATE DATABASE`。\n\n**考点总结:**\n此题考察`mysqldump`中`--no-create-info`选项的精确含义，即它抑制了`CREATE TABLE`语句的输出，主要用于只备份数据或在已有表结构的情况下导入数据。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n准确理解`mysqldump`的常用选项，特别是控制输出内容（结构、数据、特定对象）的选项。`--no-create-info` (`-t`) 和 `--no-data` (`-d`) 是两个需要区分的关键选项。\n\n**学习建议:**\n熟练掌握`mysqldump`工具的使用。进行实验，使用不同的选项组合（如`--no-create-info`, `--no-data`, `--databases`, `--all-databases`, `--tables`, `--ignore-table`, `--routines`, `--events`, `--triggers`等）来观察产生的dump文件内容，加深对选项作用的理解。"
    },
    {
        "question": "### 试题 127:\n\nMySQL programs look for option files in standard locations. Which method will show the option files and the order in which they are read?",
        "selections": {
            "A": "mysql> SHOW GLOBAL VARIABLES;",
            "B": "shell> mysql --print-defaults",
            "C": "shell> mysqladmin --debug",
            "D": "shell> mysqld --help --verbose"
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL客户端程序和服务器程序在启动时会按特定顺序查找和读取多个选项文件（option files, 如`my.cnf`或`my.ini`）来获取配置参数。\nD) `shell> mysqld --help --verbose` (或者其他MySQL程序，如`mysql --help --verbose`): 当MySQL程序以`--help --verbose`选项运行时，它会在输出的帮助信息中列出它将查找的选项文件的标准路径以及它们的读取顺序 (D 正确)。\n\n错误选项分析：\nA) `mysql> SHOW GLOBAL VARIABLES;`：显示当前服务器正在运行的全局系统变量的值，不显示选项文件的读取顺序或位置。\nB) `shell> mysql --print-defaults`：这个命令会打印出`mysql`程序从选项文件中解析出来的所有默认选项及其值，但它不直接显示选项文件本身的列表和读取顺序，而是显示最终生效的默认配置。\nC) `shell> mysqladmin --debug`：`--debug`选项通常用于输出详细的调试信息，可能包含一些关于配置加载的痕迹，但不如`--help --verbose`那样清晰和专门地列出选项文件和顺序。\n\n**考点总结:**\n此题考察如何查看MySQL程序查找选项文件的路径和顺序。`--help --verbose`是一个通用的方法，适用于大多数MySQL命令行程序。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住`--help --verbose`这个组合通常能提供关于程序行为（包括配置加载）的详细信息。\n\n**学习建议:**\n学习MySQL选项文件（`my.cnf`或`my.ini`）的结构、语法和加载顺序（例如，全局配置文件、用户家目录下的配置文件、特定数据目录下的配置文件等）。了解不同MySQL程序（`mysqld`, `mysql`, `mysqldump`, `mysqladmin`等）如何使用选项文件。掌握`--help --verbose`和`--print-defaults`等命令来辅助理解和调试配置。"
    },
    {
        "question": "### 试题 128:\n\nChoose the best answer. Examine this command, which executes successfully: `$ mysqlbackup --user=dba --password --port=3306 --with-timestamp --only-known-file-types --backup-dir=/export/backups backup`\nWhich statement is true?",
        "selections": {
            "A": "Only tables stored in their own tablespaces are backed up.",
            "B": "Only InnoDB data and log files are backed up.",
            "C": "Only non-encrypted files are backed up.",
            "D": "Only files for MySQL or its built-in storage engines are backed up.",
            "E": "The backup includes only data files and their metadata."
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlbackup` (MySQL Enterprise Backup) 是一个物理备份工具。`--only-known-file-types`选项限制了备份操作只处理MySQL已知的文件类型。\nD) 只备份MySQL或其内置存储引擎的文件。当使用`--only-known-file-types`时，`mysqlbackup`会专注于备份那些它识别为MySQL数据文件、日志文件、配置文件等属于MySQL实例本身的文件类型。它会跳过数据目录中可能存在的其他未知类型的文件（例如，用户放置的无关文件） (D 正确)。\n\n错误选项分析：\nA) `mysqlbackup`会备份所有MySQL数据，无论表是存储在独立表空间还是系统表空间中（如果系统表空间被包含在备份范围内）。\nB) `mysqlbackup`不仅备份InnoDB数据和日志文件，还会备份其他必要的文件，如`mysql`数据库的表（可能是MyISAM或InnoDB）、数据字典文件、二进制日志（如果指定）、中继日志（如果是从库备份）等，以及MyISAM表文件（如果存在且被包含）。\nC) `mysqlbackup`支持备份加密的InnoDB表空间（如果使用了InnoDB TDE）。它不限于只备份未加密文件。加密备份是其功能之一。\nE) 物理备份包含数据文件、日志文件以及确保实例可恢复所需的元数据（例如，通过备份数据字典文件或SDI信息）。说“只包含数据文件和它们的元数据”可能不够全面，因为它还需要redo日志等来进行一致性恢复。\n\n**考点总结:**\n此题考察`mysqlbackup`工具中`--only-known-file-types`选项的作用，即限制备份范围到MySQL已知的文件类型，以避免备份无关文件并可能提高备份效率或减少备份大小。\n\n**OCR解释“mysqlbackup only backs up those types of files that are data files for MySQL or its built-in storage engines, which, besides the ibdata* files, have the following extensions:”是正确的，并指出了通常包含的文件类型。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解`--only-known-file-types`选项的目的——排除未知或无关文件。将其与备份工具对不同存储引擎和MySQL组件的支持联系起来。\n\n**学习建议:**\n学习MySQL Enterprise Backup (`mysqlbackup`) 的高级选项，包括用于优化备份过程、控制备份内容和处理特殊情况的选项。阅读官方文档中关于`--only-known-file-types`和其他相关选项的详细说明。了解哪些文件类型是MySQL正常运行和恢复所必需的。"
    },
    {
        "question": "### 试题 129:\n\nWhat does the slave I/O thread do?",
        "selections": {
            "A": "monitors and schedules I/O calls to the subsystem for the relay logs",
            "B": "connects to the master and requests it to send updates recorded in its binary logs",
            "C": "acquires a lock on the binary log for reading each event to be sent to the slave",
            "D": "reads the relay log and executes the events contained in them"
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n在MySQL异步复制中，从服务器上有两个主要的线程：I/O线程和SQL线程。\nB) I/O线程（Slave I/O Thread 或 Replica I/O Thread）负责连接到主服务器（Master 或 Source），并请求主服务器将其二进制日志（binary logs）中的事件发送过来。I/O线程接收到这些事件后，将它们写入从服务器本地的中继日志（relay logs） (B 正确)。\n\n错误选项分析：\nA) 中继日志的I/O调度和监控更偏向于操作系统层面或SQL线程读取中继日志时的行为，不是I/O线程的主要职责。\nC) I/O线程是从主库读取binlog，主库上的binlog dump线程负责发送。I/O线程本身不在主库上获取锁。\nD) 读取中继日志并执行其中的事件是SQL线程（Slave SQL Thread 或 Replica SQL Thread）的工作，而不是I/O线程。\n\n**考点总结:**\n此题考察对MySQL复制中从库I/O线程核心职责的理解。它的主要任务是从主库获取binlog事件并写入本地中继日志。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n清晰地区分从库上的I/O线程和SQL线程的职责。I/O线程负责“取货”（从主库拉取binlog），SQL线程负责“加工”（应用relay log中的事件）。\n\n**学习建议:**\n学习MySQL异步复制的完整架构和工作流程。详细了解主库上的binlog dump线程、从库上的I/O线程和SQL线程（以及在并行复制中的协调线程和工作线程）各自的角色和交互方式。熟悉相关的状态变量和监控命令（如`SHOW SLAVE STATUS`或`SHOW REPLICA STATUS`）。"
    },
    {
        "question": "### 试题 130:\n\nChoose the best answer. Which statement is true about the `my.ini` file on a Windows platform while MySQL server is running?",
        "selections": {
            "A": "MySQL server does not use the my.ini option file for server configuration options.",
            "B": "The option file is read by the MySQL server service only at start up.",
            "C": "Editing the file will immediately change the running server configuration.",
            "D": "Using SET PERSIST will update the my.ini file."
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`my.ini`（在Windows上）或`my.cnf`（在类Unix系统上）是MySQL的选项配置文件。\nB) 选项文件（如`my.ini`）主要是在MySQL服务器服务启动时被读取和解析的。服务器根据文件中的配置来设置其初始的系统变量和行为。在服务器运行期间，除非通过特定机制（如`SET PERSIST`写入`mysqld-auto.cnf`，然后服务器下次启动时读取），否则对`my.ini`的修改不会影响当前正在运行的实例 (B 正确)。\n\n错误选项分析：\nA) MySQL服务器确实使用`my.ini`（或`my.cnf`）作为其主要的配置文件来源之一。\nC) 编辑`my.ini`文件不会立即改变正在运行的服务器的配置。要使更改生效，通常需要重启MySQL服务，或者对于某些动态变量，可以使用`SET GLOBAL`命令在运行时修改（但这不直接与编辑`my.ini`文件相关）。\nD) `SET PERSIST`命令会将系统变量的更改持久化到数据目录下的`mysqld-auto.cnf`文件中（JSON格式），而不是直接更新`my.ini`文件。`mysqld-auto.cnf`在启动时会覆盖`my.ini`中的同名设置。\n\n**考点总结:**\n此题考察MySQL选项配置文件（特别是Windows上的`my.ini`）的读取时机和作用。核心在于它是启动时配置，运行时修改需要其他机制。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分静态配置（通过选项文件，通常需重启生效）和动态配置（通过`SET GLOBAL`等命令，部分变量可运行时生效）。理解`SET PERSIST`和`mysqld-auto.cnf`在现代MySQL配置管理中的作用。\n\n**学习建议:**\n学习MySQL的配置管理，包括选项文件的查找顺序、语法、不同section的含义。掌握如何修改配置参数（通过编辑选项文件并重启，或通过`SET GLOBAL`/`SET PERSIST`命令）。了解哪些系统变量是动态的（可以在运行时修改），哪些是静态的（需要重启生效）。"
    },
    {
        "question": "### 试题 131:\n\nExamine the full path name of the backup image from MySQL Enterprise Backup with the --compress option: `/backup/full/mybackup/myimage.img`\n`mysqlbackup.cnf` contains this data: `mysqlbackup backup-dir=/backup/full/myrestore backup-image=/backup/full/mybackup/myimage.img uncompress`\nYou must perform a database restore to a new machine.\nWhich command can provision the new database in datadir as `/data/MEB`?",
        "selections": {
            "A": "mysqlbackup --defaults-file=mysqlbackup.cnf --datadir=/data/MEB restore-and-apply-log",
            "B": "mysqlbackup --defaults-file=mysqlbackup.cnf --datadir=/data/MEB image-to-dir-and-apply-log",
            "C": "mysqlbackup --defaults-file=mysqlbackup.cnf --datadir=/data/MEB apply-log-and-copy-back",
            "D": "mysqlbackup --defaults-file=mysqlbackup.cnf --datadir=/data/MEB copy-back-and-apply-log",
            "E": "mysqlbackup --defaults-file=mysqlbackup.cnf --datadir=/data/MEB image-to-dir"
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n题目描述的是使用MySQL Enterprise Backup (`mysqlbackup`) 从一个压缩的备份镜像 (`myimage.img`) 恢复数据库到新机器的数据目录`/data/MEB`。\n`mysqlbackup.cnf` 文件中指定了 `backup-image`（源备份镜像）和 `backup-dir`（临时解压和准备目录，这里是`/backup/full/myrestore`），并且有`uncompress`指令（意味着备份镜像是压缩的，恢复时需要解压）。\n\n恢复过程通常涉及：\n1.  准备备份镜像（解压、应用日志等），这通常在`backup-dir`中进行。\n2.  将准备好的数据复制回目标数据目录。\n\nD) `mysqlbackup --defaults-file=mysqlbackup.cnf --datadir=/data/MEB copy-back-and-apply-log`：\n    -   `--defaults-file=mysqlbackup.cnf`：使用指定的配置文件，其中包含了`backup-image`和`backup-dir`以及`uncompress`等信息。\n    -   `--datadir=/data/MEB`：指定最终恢复到的目标数据目录。\n    -   `copy-back-and-apply-log`：这个操作（或类似的如`copy-back`后跟`apply-log`，或者某些工具的一体化命令）通常意味着从准备好的备份目录（`backup-dir`）将数据文件复制到目标数据目录（`datadir`），并且确保应用了必要的日志使数据达到一致状态。对于从备份镜像恢复，`copy-back`是关键步骤，它会将解压并准备好的数据复制到最终位置。`apply-log`确保事务一致性。这个组合是最接近完整恢复并配置到新数据目录的操作 (D 正确)。\n\n错误选项分析：\nA) `restore-and-apply-log`：`restore`通常指从备份介质（如磁带）恢复数据到`backup-dir`，而不是从已有的`backup-image`。如果`backup-image`是本地文件，`restore`可能不是第一步。\nB) `image-to-dir-and-apply-log`：`image-to-dir`会将备份镜像解压并提取到`backup-dir`。然后`apply-log`。但这之后还需要`copy-back`到最终的`datadir`。这个选项不完整。\nC) `apply-log-and-copy-back`：顺序反了。通常是先`copy-back`到临时工作目录（如果需要，或者直接从备份镜像解压到工作目录），然后`apply-log`，最后再`copy-back`到最终数据目录。或者，`image-to-dir` -> `apply-log` -> `copy-back`。\nE) `image-to-dir`：这只是将备份镜像解压并提取到`backup-dir`，没有应用日志，也没有复制到最终的`datadir`。\n\n**考点总结:**\n此题考察使用MySQL Enterprise Backup从压缩备份镜像进行恢复的步骤和命令。关键在于理解备份镜像的处理（解压、提取）、日志应用以及将数据复制到目标数据目录的流程。`copy-back`操作是将准备好的数据部署到最终位置的关键。\n\n**注意:** `mysqlbackup`的命令和操作名可能因版本或具体场景而略有不同，但基本流程是相似的。`copy-back-and-apply-log`或分步的`image-to-dir`, `apply-log`, `copy-back`是常见的组合。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解物理备份恢复的几个阶段：1. 获取备份数据（可能涉及解压、从介质恢复）。2. 准备备份数据（应用事务日志使其一致）。3. 将数据部署到目标位置。选择能完整覆盖这些关键步骤的命令或组合。\n\n**学习建议:**\n学习MySQL Enterprise Backup (`mysqlbackup`) 的完整备份和恢复流程，特别是从不同类型的备份（如压缩镜像、目录备份、增量备份）进行恢复。掌握相关的命令和选项，如`backup-image-to-dir`, `apply-log`, `copy-back`, `restore`等。熟悉使用配置文件（如`mysqlbackup.cnf`或命令行参数）来指定备份源、目标目录和操作选项。进行实际的备份恢复演练。"
    },
    {
        "question": "### 试题 132:\n\nChoose the best answer. MySQL Enterprise Monitor Query Analyzer is configured to monitor an instance. Which statement is true?",
        "selections": {
            "A": "The Query Response Time index (QRTi) is fixed to 100ms and cannot be customized.",
            "B": "Enabling the events_statements_history_long consumer allows tracking the longest running query.",
            "C": "An agent must be installed locally on the instance to use the Query Analyzer.",
            "D": "The Query Analyzer can monitor an unlimited number of normalized statements.",
            "E": "The slow query log must be enabled on the monitored server to collect information for the Query Analyzer."
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL Enterprise Monitor (MEM) Query Analyzer 的特性：\nD) Query Analyzer 可以监控（理论上）无限数量的规范化语句（normalized statements）。它通过Performance Schema的语句摘要表（如`events_statements_summary_by_digest`）来收集信息，这些表会聚合相似的查询（通过规范化，即去除字面量），并为每个查询摘要（digest）存储统计信息。摘要表的容量是可配置的，但Query Analyzer的设计目标是处理大量不同的查询模式 (D 正确)。\n\n错误选项分析：\nA) QRTi (Query Response Time index) 是一个衡量查询性能的指标，但其阈值或配置并非固定且不可定制。Query Analyzer 提供了灵活的过滤和排序功能，允许用户根据不同的延迟标准来分析查询。\nB) `events_statements_history_long`是Performance Schema中的一个表，用于存储最近执行的、耗时较长的语句的完整文本和统计信息。启用这个消费者（consumer）确实有助于跟踪长时间运行的查询，并且Query Analyzer可以利用这些数据。但是，说“允许跟踪最长运行查询”这个说法本身，Query Analyzer可以通过多种数据源（包括语句摘要表）来实现，不唯一依赖这个特定表。而且，Query Analyzer的核心功能是基于摘要聚合，而不是仅仅跟踪单个最长查询。\nC) MySQL Enterprise Monitor 通常需要MEM Agent安装在被监控的MySQL主机上，以便全面收集操作系统级别和MySQL内部的性能数据，包括供Query Analyzer使用的数据。虽然存在无代理监控模式，但其功能受限，特别是对于详细的OS指标和某些P_S数据收集。因此，为了充分使用Query Analyzer，通常需要Agent (C选项的表述是“必须”，这在有无代理模式可选的情况下可能不完全绝对，但对于完整功能是推荐的)。然而，与D相比，D描述的是Query Analyzer的一个核心能力。\nE) Query Analyzer主要的数据来源是Performance Schema的语句摘要表。虽然它也可以配置为使用慢查询日志作为数据源，但这通常是辅助的或用于旧版本。在现代MySQL中，Performance Schema是首选的数据源，不“必须”启用慢查询日志。\n\n**考点总结:**\n此题考察对MySQL Enterprise Monitor Query Analyzer数据收集和处理能力的理解。核心在于它依赖Performance Schema进行语句聚合和统计，并且能够处理大量的查询模式。\n\n**答案精确性考量:**\n- D选项的“无限数量”是理论上的，实际受限于Performance Schema摘要表的容量和MEM的处理能力，但其设计确实是为了应对大量查询。\n- C选项的“必须安装Agent”：对于Query Analyzer的完整功能（特别是与OS指标关联、某些P_S配置的自动调整等），Agent是推荐的。但如果只依赖MySQL本身通过SQL接口暴露的P_S数据，理论上无代理也能获取部分查询信息。然而，企业级监控通常期望完整功能。如果D是绝对正确的，而C有条件性，则D更优。\n\n考虑到D描述了Query Analyzer的一个核心设计目标和能力，它是较好的答案。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解Query Analyzer的数据来源（主要是Performance Schema）和其核心分析方法（基于规范化语句的聚合统计）。思考其设计目标和能力范围。\n\n**学习建议:**\n学习MySQL Enterprise Monitor Query Analyzer的工作原理。了解它如何与Performance Schema（特别是`events_statements_summary_by_digest`等表）以及慢查询日志交互。熟悉Query Analyzer界面中提供的各种视图、图表、过滤和分析功能。了解其在识别和诊断性能瓶颈查询方面的价值。"
    },
    {
        "question": "### 试题 133:\n\nChoose the best answer. Users report errors when trying to connect from `192.0.2.5` and is connecting using the `mysql_native_password` authentication plugin. Examine these commands and output:\n\n```sql\nmysql> SHOW GLOBAL STATUS LIKE 'conn%';\n+-----------------------------------+--------+\n| Variable_name                     | Value  |\n+-----------------------------------+--------+\n| Aborted_connects                  | 593    |\n| Connection_errors_accept          | 0      |\n| Connection_errors_internal        | 0      |\n| Connection_errors_max_connections | 0      |\n| Connection_errors_peer_address    | 0      |\n| Connection_errors_select          | 0      |\n| Connection_errors_tcpwrap         | 0      |\n| Connections                       | 1825   |\n| Max_used_connections              | 100    |\n| Locked_connects                   | 0      |\n| Mysqlx_connections_accepted       | 0      |\n... (部分输出省略)\n| Threads_connected                 | 4      |\n+-----------------------------------+--------+\n23 rows in set (0.00 sec)\n```\n\n```sql\nmysql> SELECT * FROM performance_schema.host_cache WHERE IP='192.0.2.5'\\G\n*************************** 1. row ***************************\n                              IP: 192.0.2.5\n                            HOST: client05.example.com\n                  HOST_VALIDATED: YES\n            SUM_CONNECT_ERRORS: 0\n     COUNT_HOST_BLOCKED_ERRORS: 0\nCOUNT_NAMEINFO_TRANSIENT_ERRORS: 0\nCOUNT_NAMEINFO_PERMANENT_ERRORS: 0\n             COUNT_FORMAT_ERRORS: 0\n COUNT_ADDRINFO_TRANSIENT_ERRORS: 0\n COUNT_ADDRINFO_PERMANENT_ERRORS: 0\n             COUNT_FCRDNS_ERRORS: 0\n            COUNT_HOST_ACL_ERRORS: 0\n   COUNT_NO_AUTH_PLUGIN_ERRORS: 0\n      COUNT_AUTH_PLUGIN_ERRORS: 367\n          COUNT_HANDSHAKE_ERRORS: 0\n         COUNT_PROXY_USER_ERRORS: 0\n    COUNT_PROXY_USER_ACL_ERRORS: 0\n  COUNT_AUTHENTICATION_ERRORS: 0\n1 row in set (0.00 sec)\n```\nWhich statement identifies the cause of the errors?",
        "selections": {
            "A": "max_connections is too small.",
            "B": "Network connectivity issues occurring between client and the MySQL instance.",
            "C": "Connections are attempted without a valid user account or password.",
            "D": "User accounts are defined using the mysql_native_password plugin for password authentication.",
            "E": "thread_cache is too small.",
            "F": "skip_name_resolve is enabled."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n关键的诊断信息来自`performance_schema.host_cache`的输出：`COUNT_AUTH_PLUGIN_ERRORS: 367`。\n- `COUNT_AUTH_PLUGIN_ERRORS`: 指示由认证插件报告的错误数量。当这个值很高时，通常意味着客户端和服务器在认证握手过程中存在问题，例如密码不匹配、认证插件不兼容、或者客户端未能正确响应服务器的认证挑战。\n- `Aborted_connects: 593`: 表示有大量连接尝试被中止。\n\n根据OCR中的答案提示 “COUNT_AUTH_PLUGIN_ERRORS:367 身份验证插件报告的错误数 Unknown or unexpected plugin errors are counted in the COUNT_AUTH_PLUGIN_ERRORS column. Aborted_connects: #客户端没有权限但是尝试访问 MySQL 数据库#客户端输入的密码有误。#连接包不包含正确信息#超过连接时间限制, 主要是这个系统变量 connect_timeout 控制”。\n\n结合题目说用户正在使用`mysql_native_password`插件，并且`COUNT_AUTH_PLUGIN_ERRORS`很高，这强烈暗示了认证失败。\n\nB) 网络连接问题发生在客户端和MySQL实例之间。虽然`COUNT_AUTH_PLUGIN_ERRORS`主要指向认证问题，但如果网络不稳定，可能导致认证握手包丢失或损坏，从而间接触发认证插件错误。此外，“连接包不包含正确信息”或“超过连接时间限制”也可能与网络有关 (B 可能是一个间接原因或综合原因，但如果认证信息本身正确，网络问题也可能导致认证失败)。\nC) 连接尝试没有使用有效的用户账户或密码。这是`COUNT_AUTH_PLUGIN_ERRORS`很高时最直接的解释之一，即客户端提供的凭据不正确 (C 是一个非常可能的原因)。\n\n**重新评估选项和OCR提示：**\nOCR答案提示中直接将`COUNT_AUTH_PLUGIN_ERRORS`与“客户端输入的密码有误”关联起来，这指向C。然而，OCR给出的最终答案是B。\n如果选B，则认为这些认证插件错误是由于网络问题导致的认证过程失败。\n如果选C，则认为问题在于凭据本身。\n\n考虑到`host_cache`中`HOST_VALIDATED: YES`且`SUM_CONNECT_ERRORS: 0`，这表明主机名解析和基本连接建立可能没有问题。那么，焦点就应该在认证阶段。\n`COUNT_AUTH_PLUGIN_ERRORS`通常与认证协议、密码哈希或凭证本身的问题有关。如果仅仅是网络连接问题导致无法完成认证，错误计数可能会分散在其他与连接建立相关的错误计数器上（如`COUNT_HANDSHAKE_ERRORS`或`Connection_errors_internal`等，但这些都为0）。\n\n因此，C选项“连接尝试没有使用有效的用户账户或密码”似乎是`COUNT_AUTH_PLUGIN_ERRORS`异常高的更直接原因。\n\n然而，如果题目预设了B为正确答案，那么必须假设这些认证错误是由不稳定的网络连接间接引发的，例如认证数据包在传输中损坏或丢失，导致服务器端的认证插件无法正确处理。\n\n**考点总结:**\n此题考察根据MySQL的状态变量和`performance_schema.host_cache`输出来诊断连接和认证问题。需要理解不同错误计数器的含义，特别是与连接、认证、主机解析相关的计数。\n\n**基于题目提供的输出，C选项（凭据无效）是`COUNT_AUTH_PLUGIN_ERRORS`高的最直接解释。如果B是答案，则场景设定比较间接。**\n**由于我们必须从题目提供的选项中选择“最佳答案”，并且OCR的最终答案（尽管其分析指向C）是B，这可能表明题目设计者认为这些认证错误是更广泛的网络连接问题的体现。例如，如果网络导致客户端和服务器之间的认证握手无法可靠完成。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细分析所有提供的状态和性能数据。理解每个统计指标的含义。当有多个看似相关的原因时，尝试找到最直接或最能解释核心错误计数器的那个。\n\n**学习建议:**\n学习MySQL的连接和认证过程。熟悉`SHOW GLOBAL STATUS LIKE 'Connection_errors%';`的输出以及`performance_schema.host_cache`表中各个列的含义。了解常见的连接错误原因（如网络问题、防火墙、主机解析、用户权限、密码错误、认证插件不匹配、连接数限制等）以及如何通过监控数据来诊断它们。"
    },
    {
        "question": "### 试题 134:\n\nYou want to check the values of the `sort_buffer_size` session variables of all existing connections.\nWhich performance_schema table can you query?",
        "selections": {
            "A": "global_variables",
            "B": "session_variables",
            "C": "variables_by_thread",
            "D": "user_variables_by_thread"
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n要查看所有现有连接（线程）的会话级别系统变量（如`sort_buffer_size`）的当前值，可以使用Performance Schema中的相关表。\nC) `performance_schema.variables_by_thread`：这个表显示了每个活动线程（连接）的会话系统变量的当前值。可以通过查询此表并按`VARIABLE_NAME = 'sort_buffer_size'`进行过滤来获取所有连接的`sort_buffer_size`值 (C 正确)。\n\n错误选项分析：\nA) `performance_schema.global_variables`：显示全局系统变量的当前值，而不是每个会话的值。\nB) `performance_schema.session_variables`：显示当前会话（即执行查询的那个会话）的系统变量值，而不是所有现有连接的值。\nD) `user_variables_by_thread`：这个表（如果存在）通常用于显示用户定义的会话变量（如`@my_var`），而不是系统会话变量。\n\n**考点总结:**\n此题考察如何通过Performance Schema查询所有活动连接的特定会话系统变量的值。`variables_by_thread`是关键表。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分全局变量、会话变量和用户定义变量。了解Performance Schema中用于监控这些变量的表名（通常包含`global_variables`, `session_variables`, `variables_by_thread`等关键词）。\n\n**学习建议:**\n学习使用MySQL Performance Schema来监控服务器状态和性能。熟悉与系统变量相关的表，如`global_status`, `session_status`, `global_variables`, `session_variables`, `variables_by_thread`。练习通过查询这些表来获取所需的配置和状态信息。"
    },
    {
        "question": "### 试题 135:\n\nChoose the best answer. Which feature is provided by multi-source replication?",
        "selections": {
            "A": "providing a common source for the same data to be replicated to other servers",
            "B": "allowing multiple servers to back up to one server",
            "C": "managing conflicts between two sets of the same data",
            "D": "providing multi-source replication where all servers act as the master"
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n多源复制（Multi-Source Replication）允许一个MySQL从服务器（副本）从多个主服务器（源）复制数据。\nB) 允许多个服务器备份到一个服务器：这是一个多源复制的典型用例。可以将多个生产服务器（作为主库）的数据变更复制到一个集中的服务器（作为从库）上，这个集中的服务器可以用于数据聚合、备份、分析或报表等目的 (B 正确)。\n\n错误选项分析：\nA) “为相同数据提供通用源以复制到其他服务器”：这更像是传统的主从复制或主主复制的描述，多源复制的特点是“多个源到一个目标”。\nC) 管理两组相同数据之间的冲突：多源复制本身不提供冲突管理机制。如果来自不同源的事务修改了从库上的相同数据，可能会发生冲突，需要DBA或应用层面来处理。\nD) “提供所有服务器都充当主服务器的多源复制”：这描述的是多主复制（如主主环形复制或组复制的多主模式），而不是多源复制（多个源到一个副本）。\n\n**考点总结:**\n此题考察多源复制的核心功能和主要应用场景。关键在于它实现了“多对一”的数据复制模式。\n\n**OCR解释中提到了几个用例，包括“Backing up multiple servers to a single server”，与B选项一致。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解“多源”的含义——多个数据来源。思考这种复制模式能解决什么问题，最常见的就是数据聚合和集中备份/分析。\n\n**学习建议:**\n学习MySQL多源复制的配置和管理。了解其主要应用场景，如数据汇总、将分片数据合并到中央服务器、从多个独立应用服务器备份数据到一台备份服务器等。注意多源复制中可能出现的复制冲突问题以及如何避免或处理它们。"
    },
    {
        "question": "### 试题 136:\n\nChoose the best answer. It is a non-empty InnoDB table. Examine these statements, which are executed in one session:\n```sql\nBEGIN;\nSELECT * FROM t FOR UPDATE;\n```\nWhich is true?",
        "selections": {
            "A": "mysqlcheck --analyze --all-databases will execute normally on all tables and return a report.",
            "B": "If ANALYZE TABLE t; is invoked from the same session, it hangs until the transaction is committed or rolled back.",
            "C": "IF OPTIMIZE TABLE t; is invoked from another session, it executes normally and returns the status.",
            "D": "If OPTIMIZE TABLE t; is invoked, it will create a table lock on t and force a transaction rollback."
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n会话1执行了`BEGIN; SELECT * FROM t FOR UPDATE;`。这会在表`t`中匹配到的行上加上排他锁（X锁），并且这些锁会持续到事务提交或回滚。\nD) 如果（在另一个会话中）调用`OPTIMIZE TABLE t;`，该命令通常需要对表`t`获取排他元数据锁（MDL-X）或执行表重建，这会与会话1持有的行锁或可能的表级意向锁冲突。`OPTIMIZE TABLE`会等待会话1释放锁。如果等待超时，它会失败。如果它能获取到锁并执行，它可能会重建表。但更重要的是，某些DDL操作（如`OPTIMIZE TABLE`在某些情况下）可能会导致正在进行的事务（如会话1的事务）被隐式提交或产生其他交互。然而，选项D说“强制事务回滚”是不准确的。更可能的情况是`OPTIMIZE TABLE`操作会阻塞，或者如果它能执行，它是在会话1的事务之外进行的。如果`OPTIMIZE TABLE`对InnoDB表执行的是类似`ALTER TABLE ... ENGINE=InnoDB`的重建操作，它会等待现有事务完成。**但是，OCR将D标记为正确，可能基于某种特定版本的行为或对“强制回滚”的广义理解。**\n\n让我们重新审视DDL和锁的交互：\n- `SELECT ... FOR UPDATE`在InnoDB表上获取行级X锁。\n- `OPTIMIZE TABLE`对于InnoDB表，通常等同于`ALTER TABLE ... ENGINE=InnoDB`（重建表）或者`ANALYZE TABLE` + `ALTER TABLE ... FORCE`（如果表碎片化）。这些操作通常需要获取表级的元数据锁（MDL）。\n\n如果会话1持有行锁，另一个会话尝试对该表执行需要MDL-X锁的DDL（如`OPTIMIZE TABLE`重建表），则DDL操作会等待。它不会“强制回滚”会话1的事务。\n\n**鉴于OCR将D标记为正确，我们尝试寻找其可能的解释：**\n也许在某些旧版本或特定配置下，`OPTIMIZE TABLE` 对一个有活动事务和锁的表的操作可能会导致更激烈的行为。或者，这里的“强制事务回滚”可能是一种不精确的说法，意指`OPTIMIZE TABLE`操作无法在事务进行时顺利完成，并可能导致事务最终因某种原因（如超时、或优化操作引起的某种状态变化）而失败并回滚。\n\nC) 如果`OPTIMIZE TABLE t;`从另一个会话调用，它会尝试获取必要的锁。由于会话1持有行锁，`OPTIMIZE TABLE`（如果需要表级排他锁）会阻塞，直到会话1的事务结束。它不会“正常执行并返回状态”而无视会话1的锁。\nB) 如果在同一会话中，在`SELECT ... FOR UPDATE`之后（事务未提交/回滚），调用`ANALYZE TABLE t;`。`ANALYZE TABLE`通常获取读锁或共享元数据锁，它应该可以执行，因为它不与行级X锁直接冲突，且在同一事务内。说它会“挂起”是不准确的，除非`ANALYZE`本身也需要某种与`FOR UPDATE`不兼容的锁。\nA) `mysqlcheck --analyze --all-databases`会在后台对所有表执行`ANALYZE TABLE`。对于表`t`，如果会话1的事务仍在进行，`ANALYZE TABLE t`可能会短暂等待或（如果获取的是读锁）正常执行。\n\n**结论：基于标准的InnoDB锁和DDL行为，D选项的“强制事务回滚”部分是可疑的。然而，如果这是考题的预设答案，那必须接受其特定解释。在没有更精确信息的情况下，此题的答案和选项的合理性存疑。**\n\n**考点总结:**\n此题考察在存在活动事务和行锁的情况下，执行DDL操作（如`OPTIMIZE TABLE`, `ANALYZE TABLE`）或表维护工具（如`mysqlcheck`）时的锁交互和行为。关键在于理解不同操作所需的锁类型（行锁、表锁、元数据锁）及其兼容性。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解InnoDB的锁机制（行锁、表锁、意向锁、元数据锁）。了解常见SQL语句（DML, DDL）和维护操作会获取哪些类型的锁。分析锁冲突的可能性和后果（阻塞、死锁、错误）。\n\n**学习建议:**\n学习InnoDB的并发控制和锁管理。进行实验来观察不同操作之间的锁兼容性和交互。熟悉`SHOW ENGINE INNODB STATUS`和Performance Schema中与锁相关的表，用于诊断锁问题。了解元数据锁（MDL）及其对DDL操作和并发DML的影响。"
    },
    {
        "question": "### 试题 137:\n\nChoose the best answer. You have upgraded the MySQL binaries from 5.7.28 to 8.0.18 by using an in-place upgrade. Examine the message sequence generated during the first start of MySQL 8.0.18:\n```\n... [System] ... /usr/sbin/mysqld (mysqld 8.0.18-commercial) starting as process 2754\n... [System] ... Starting upgrade of data directory.\n... [ERROR] ... Table upgrade required. Please do \"REPAIR TABLE `columns_priv`\" or dump/reload to fix it!\n... [ERROR] ... Table upgrade required. Please do \"REPAIR TABLE `event`\" or dump/reload to fix it!\n... [ERROR] ... Table upgrade required. Please do \"REPAIR TABLE `proc`\" or dump/reload to fix it!\n... [ERROR] ... Table upgrade required. Please do \"REPAIR TABLE `proxies_priv`\" or dump/reload to fix it!\n... [ERROR] ... Table upgrade required. Please do \"REPAIR TABLE `tables_priv`\" or dump/reload to fix it!\n... [ERROR] ... Failed to open mysql.event Table.\n... [ERROR] ... Failed to open mysql.proc Table.\n... [ERROR] ... Failed to Populate DD tables.\n... [ERROR] ... Aborting\n... [System] ... /usr/sbin/mysqld: Shutdown complete (mysqld 8.0.18-commercial) MySQL Enterprise Server Commercial.\n```\nWhich step or set of steps will resolve the errors?",
        "selections": {
            "A": "Start mysqld again using the --upgrade=FORCE option.",
            "B": "Go to the <datadir>/mysql directory and execute: myisamchk --update-state columns_priv event proc proxies_priv tables_priv.",
            "C": "Execute: mysqlcheck --repair mysql columns_priv event proc proxies_priv tables_priv.",
            "D": "Remove the redo logs. Replace the MySQL binaries with the 5.7.28 binaries. Prepare the tables for upgrade. Upgrade to 8.0.18 again.",
            "E": "Execute: mysqlcheck --check-upgrade mysql columns_priv event proc proxies_priv tables_priv."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n错误日志表明，在从MySQL 5.7升级到8.0后首次启动时，多个`mysql`系统数据库中的表（这些表在5.7中通常是MyISAM格式）被检测到需要升级或修复。服务器尝试进行数据目录升级，但因为无法打开某些关键系统表（如`mysql.event`, `mysql.proc`）或填充新的数据字典表而失败并中止。\nC) `mysqlcheck --repair mysql columns_priv event proc proxies_priv tables_priv.`：`mysqlcheck`工具的`--repair`选项（等同于对每个表执行`REPAIR TABLE`）用于修复表。错误日志明确提示对这些表执行`REPAIR TABLE`。由于这些是`mysql`数据库中的系统表，且在5.7中很可能是MyISAM格式，使用`mysqlcheck --repair`（或直接在mysql客户端中对每个表执行`REPAIR TABLE`）是尝试修复它们的正确方法。修复这些表后，再次启动8.0服务器进行升级过程可能会成功 (C 正确)。\n\n错误选项分析：\nA) `--upgrade=FORCE`选项通常用于在服务器正常启动后，强制执行`mysql_upgrade`的检查和修复逻辑（在8.0中，升级过程已集成到服务器启动中）。但在当前服务器都无法成功启动并完成数据字典初始化的情况下，这个选项可能无效或不适用。\nB) `myisamchk`是一个用于检查和修复MyISAM表的命令行工具，它需要在服务器未运行时对表文件直接操作。虽然这些系统表可能是MyISAM，但通常推荐使用`mysqlcheck`或SQL的`REPAIR TABLE`（当服务器能部分启动或在安全模式下启动时），因为它们通过服务器接口操作，更安全。直接用`myisamchk --update-state`可能不足以解决升级过程中的复杂问题，错误日志也建议`REPAIR TABLE`。\nD) 移除redo log并回退二进制版本再重新升级是一个非常复杂且可能导致数据丢失的步骤，不应是首选。问题在于系统表的状态，而不是redo log或二进制版本。\nE) `mysqlcheck --check-upgrade`（或`CHECK TABLE ... FOR UPGRADE`）用于检查表是否与当前MySQL版本兼容或是否需要升级，它本身不执行修复。错误日志已明确指出需要修复。\n\n**考点总结:**\n此题考察MySQL从旧版本（如5.7）升级到8.0时，处理系统表（特别是MyISAM格式的）兼容性和修复问题的常见方法。`mysql_upgrade`过程（在8.0中集成到服务器启动）会检查并尝试升级系统表。如果遇到问题，错误日志通常会给出修复建议。`mysqlcheck --repair`或`REPAIR TABLE`是修复MyISAM表的常用工具/命令。\n\n**OCR答案提示“B 这些表都是MyISAM的表，但myisamchk --update-state并没有指定修复，要指定--force进行修复。E mysqlcheck --check-upgrade也没有指定修复”是正确的。这进一步支持了C选项，即使用`mysqlcheck --repair`是更直接的修复方法。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细阅读错误日志中的提示信息，它们通常会直接或间接指出问题所在和可能的解决方案（如本例中的`REPAIR TABLE`建议）。理解不同维护工具（`mysqlcheck`, `myisamchk`）和SQL命令（`REPAIR TABLE`, `CHECK TABLE`）的适用场景。\n\n**学习建议:**\n学习MySQL的版本升级流程，特别是从5.7到8.0的升级，因为它涉及数据字典的重大变更。了解`mysql_upgrade`（或8.0服务器启动时的自动升级过程）如何处理系统表和用户表。熟悉MyISAM表的常见维护和修复操作。掌握如何诊断和解决升级过程中可能出现的错误。"
    },
    {
        "question": "### 试题 138:\n\nChoose the best answer. Which statement is true about MySQL Enterprise Transparent Data Encryption (TDE)?",
        "selections": {
            "A": "MySQL TDE uses an appropriate keyring plugin to store the keys in a centralized location.",
            "B": "TDE can encrypt InnoDB and MyISAM tables only when the tables are stored in the SYSTEM tablespace.",
            "C": "Lost tablespace encryption keys can be regenerated only if the master database key is known or present in the Key Vault specification.",
            "D": "Both MyISAM and InnoDB tables can be encrypted by setting the keyring_engine = All variable in the MySQL configuration file."
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL Enterprise Transparent Data Encryption (TDE) 主要用于InnoDB表的静态数据加密。\nA) MySQL TDE使用密钥环插件（keyring plugin）来管理加密密钥。密钥环插件负责安全地存储主加密密钥（master encryption key），而表空间密钥（tablespace keys）由主密钥加密后存储在表空间头部。密钥环提供了一个集中的位置来管理主密钥 (A 正确)。\n\n错误选项分析：\nB) InnoDB TDE主要用于加密存储在独立表空间（file-per-table）或通用表空间中的InnoDB表。系统表空间本身也可以被加密（在MySQL 8.0.16+），但这与用户表是否在其中无关。MyISAM表不支持原生的TDE静态加密（MyISAM有其自身的密码加密功能，但与InnoDB TDE不同）。\nC) 如果表空间加密密钥丢失，并且其对应的主加密密钥也从密钥环中丢失（或密钥环本身不可访问），那么加密的数据将无法解密，数据会永久丢失。通常没有“重新生成”表空间密钥的方法来解密现有数据，除非有主密钥的备份。主密钥是关键。\nD) MyISAM表不支持通过与InnoDB TDE相同的方式进行静态加密。启用TDE不依赖于设置`keyring_engine = All`这样的变量。启用TDE需要配置密钥环插件，并为表或表空间启用加密属性。\n\n**考点总结:**\n此题考察对MySQL Enterprise TDE（特别是InnoDB TDE）核心机制的理解，即依赖密钥环插件进行密钥管理，以实现对静态数据的透明加密。\n\n**OCR答案提示指向P75，可能是相关文档页码。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住TDE的核心是“透明”加密静态数据，并且它依赖于“密钥环”来管理密钥。将其与网络加密（SSL/TLS）区分开。\n\n**学习建议:**\n学习MySQL的透明数据加密（TDE）功能，特别是InnoDB的实现。了解其两层密钥架构（主密钥和表空间密钥）、支持的密钥环插件类型（如`keyring_file`, `keyring_encrypted_file`, `keyring_okv`, `keyring_aws`等）、配置步骤（安装插件、设置主密钥、为表或表空间启用加密）。熟悉密钥管理操作，如密钥轮转。了解TDE对性能和备份恢复的影响。"
    },
    {
        "question": "### 试题 139:\n\nYou are using the InnoDB engine and the `innodb_file_per_table` option is set. You delete a significant number of rows of a large table named `FACTORY.INVENTORY`.\nWhich command will reorganize the physical storage of table data and associated index data for the `INVENTORY` table, in order to reduce storage space and improve I/O efficiency?",
        "selections": {
            "A": "CHECK TABLE FACTORY.INVENTORY",
            "B": "ANALYZE TABLE FACTORY.INVENTORY",
            "C": "OPTIMIZE TABLE FACTORY.INVENTORY",
            "D": "mysqlcheck -u root -p FACTORY.INVENTORY",
            "E": "mysqldump -u root -p FACTORY.INVENTORY"
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n当从InnoDB表中（特别是使用`innodb_file_per_table`时，每个表有自己的`.ibd`文件）删除大量行后，表文件占用的物理磁盘空间通常不会自动收缩。为了回收这些未使用的空间并整理碎片，需要执行表重组操作。\nC) `OPTIMIZE TABLE FACTORY.INVENTORY;`：对于InnoDB表，`OPTIMIZE TABLE`通常会执行类似`ALTER TABLE ... ENGINE=InnoDB`（即重建表）或`ALTER TABLE ... FORCE`的操作。这个过程会创建一个新的表副本，将有效数据复制过去，然后删除旧表。这能有效地回收空闲空间、消除碎片，并可能重新组织索引，从而减小存储空间占用和提高I/O效率 (C 正确)。\n\n错误选项分析：\nA) `CHECK TABLE FACTORY.INVENTORY;`：用于检查表的完整性和是否存在损坏，不进行空间重组。\nB) `ANALYZE TABLE FACTORY.INVENTORY;`：用于更新表的键分布统计信息，以帮助查询优化器。它不改变表的物理存储。\nD) `mysqlcheck -u root -p FACTORY.INVENTORY`：`mysqlcheck`是一个客户端工具。如果不指定操作（如`--optimize`, `--analyze`, `--repair`, `--check`），它默认执行`--check`操作。所以这与A类似，不进行空间重组。\nE) `mysqldump -u root -p FACTORY.INVENTORY`：`mysqldump`用于创建表的逻辑备份（导出SQL语句）。它本身不修改原始表的物理存储。要通过`mysqldump`达到空间优化的效果，需要先dump数据，然后drop原表，再重新导入数据（这样会创建一个新的、紧凑的表）。\n\n**考点总结:**\n此题考察在InnoDB表中删除大量数据后如何回收磁盘空间和整理碎片。`OPTIMIZE TABLE`是执行此操作的标准SQL命令。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解InnoDB表（特别是file-per-table模式）删除数据后空间不自动回收的特性。记住`OPTIMIZE TABLE`是进行表重组和空间优化的主要命令。\n\n**学习建议:**\n学习InnoDB表的空间管理。了解`innodb_file_per_table`参数的作用。掌握`OPTIMIZE TABLE`命令对InnoDB表的具体行为（通常是表重建）。了解在线DDL（Online DDL）特性，它允许在某些`ALTER TABLE`操作（包括部分`OPTIMIZE TABLE`的等效操作）期间，表仍然可读写。考虑在生产环境执行`OPTIMIZE TABLE`的时机和对性能的影响（因为它可能是一个耗时且I/O密集的操作）。"
    },
    {
        "question": "### 试题 140:\n\nChoose the best answer. You must configure the MySQL command-line client to provide the highest level of trust and security when connecting to a remote MySQL Server.\nWhich value of `--ssl-mode` will do this?",
        "selections": {
            "A": "VERIFY_CA",
            "B": "PREFERRED",
            "C": "VERIFY_IDENTITY",
            "D": "REQUIRED"
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题119内容几乎完全相同，只是选项顺序可能不同。\n要提供最高级别的信任和安全，客户端不仅需要确保连接是加密的，还需要验证服务器的身份是否真实可信。\nC) `VERIFY_IDENTITY`：此模式强制使用SSL/TLS加密，验证服务器证书是否由受信任的CA签发，并且验证服务器证书中的主机名（CN或SAN）是否与客户端尝试连接的主机名匹配。这是最严格的验证级别，能有效防止中间人攻击 (C 正确)。\n\n错误选项分析同试题119。\n\n**考点总结:**\n再次强调MySQL客户端`--ssl-mode`选项中，`VERIFY_IDENTITY`提供了最高级别的安全性和身份验证。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，加强记忆。将不同`--ssl-mode`值按其提供的安全保证级别排序。\n\n**学习建议:**\n参考试题119的学习建议。重点是理解证书验证（CA验证、主机名验证）在建立安全连接中的作用。"
    },
    {
        "question": "### 试题 141:\n\nChoose the best answer. You want to dump all databases with names that start with `db\/`.\nWhich command will achieve this?",
        "selections": {
            "A": "mysqlpump > all_db_backup.sql",
            "B": "mysqlpump --include-databases=db% --result-file=all_db_backup.sql",
            "C": "mysqlpump --include-databases=db --result-file=all_db_backup.sql",
            "D": "mysqlpump --include-tables=db.% --result-file=all_db_backup.sql"
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlpump`工具提供了灵活的选项来指定要备份的数据库或表，并支持通配符。\n题目要求备份所有以`db`开头的数据库（`db`中的`\\`是转义符，表示字面上的`，但更常见的场景是想匹配如`db_sales`, `db_archive`等，此时应使用`db%`或`db_`）。假设题目意图是匹配以`db`开头的数据库名。\nB) `mysqlpump --include-databases=db% --result-file=all_db_backup.sql`：`--include-databases`选项用于指定要包含的数据库列表，可以使用逗号分隔。MySQL的通配符`%`可以用于匹配数据库名或表名中的任意字符序列。因此，`db%`会匹配所有以`db`开头的数据库名 (B 正确，假设`\\`是笔误或特定含义，而`db%`是更通用的匹配开头的方式)。\n\n如果题目严格要求匹配以`db\\`（字面上的反斜杠）开头的数据库，则需要确保反斜杠被正确处理。在shell中，反斜杠可能有特殊含义，可能需要进一步转义。但`mysqlpump`的模式匹配通常使用SQL的`LIKE`模式通配符 (`%`, `_`)。\n\n错误选项分析：\nA) `mysqlpump > all_db_backup.sql`：没有指定任何数据库或表，`mysqlpump`会按其默认行为备份（通常是所有用户数据库，排除某些系统库）。\nC) `mysqlpump --include-databases=db --result-file=all_db_backup.sql`：这只会备份名为`db`的单个数据库，而不是以`db`开头的所有数据库。\nD) `mysqlpump --include-tables=db.% --result-file=all_db_backup.sql`：`--include-tables`用于指定要包含的表，而不是数据库。`db.%`会匹配`db`数据库下的所有表。\n\n**考点总结:**\n此题考察`mysqlpump`工具使用通配符（特别是`%`）来选择性备份数据库的能力。关键在于使用正确的选项（`--include-databases`）和通配符语法。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n熟悉`mysqlpump`（和`mysqldump`）中用于指定备份对象（数据库、表）的选项。了解SQL `LIKE`模式通配符`%`（匹配任意序列字符）和`_`（匹配单个字符）的用法。\n\n**学习建议:**\n学习`mysqlpump`的高级过滤选项，如`--include-databases`, `--exclude-databases`, `--include-tables`, `--exclude-tables`, `--include-routines`, `--exclude-routines`等。进行实验，使用不同的通配符模式来备份特定的数据库或表对象，验证其行为。"
    },
    {
        "question": "### 试题 142:\n\nChoose two. You have an installation of MySQL 8 on Oracle Linux. Consider the outputs:\n```sql\nmysql> SHOW GLOBAL VARIABLES WHERE Variable_name = 'tmpdir' OR Variable_name = 'tmp_table_size';\n+------------------+----------+\n| Variable_name    | Value    |\n+------------------+----------+\n| tmp_table_size   | 16777216 |\n| tmpdir           | /tmp     |\n+------------------+----------+\n2 rows in set (0.01 sec)\n```\n```bash\nshell> cd /var/lib/mysql\nshell> ls -l | grep temp\ndrwxr-x---. 2 mysql mysql 4096 Dec 11 14:05 #innodb_temp\n```\nWhich statement is true about disk temporary tables for this installation? (OCR中此句被截断，根据上下文补全。)\nWhich two statements are true about disk temporary tables for this installation?",
        "selections": {
            "A": "Only internal temporary tables from the optimizer will be created in tmpdir.",
            "B": "Temporary tables are created in tmpdir only after they reach tmp_table_size.",
            "C": "Temporary tables are created in tmpdir only if configured to use MyISAM.",
            "D": "Temporary tables will use the InnoDB temporary tablespace located in datadir.",
            "E": "Temporary tables will use the InnoDB temporary tablespace located in /tmp."
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n输出信息：\n- `tmp_table_size = 16777216` (16MB): 内存中创建的内部临时表（使用MEMORY引擎）的最大大小。\n- `tmpdir = /tmp`: 当内存临时表超过`tmp_table_size`，或当临时表包含BLOB/TEXT列等不能在MEMORY引擎中高效存储时，MySQL会将临时表转换为磁盘临时表。这些磁盘临时表（通常使用MyISAM或InnoDB引擎，取决于配置和版本）会创建在`tmpdir`指定的目录中。\n- `ls -l`输出显示在MySQL数据目录 (`/var/lib/mysql`) 下有一个`#innodb_temp`目录。这通常是InnoDB用于存储其内部临时表数据或共享临时表空间的目录。\n\nB) 临时表在达到`tmp_table_size`后才会在`tmpdir`中创建。更准确地说，如果一个内存临时表（MEMORY引擎）的大小超出了`tmp_table_size`的限制，它会被转换为磁盘临时表，这些磁盘临时表的文件会存放在`tmpdir`指定的目录中 (B 正确，描述了内存表转磁盘表的一个条件)。\nD) （InnoDB）临时表会使用位于数据目录（datadir）中的InnoDB临时表空间。从`ls -l`输出看到`/var/lib/mysql/#innodb_temp`，这表明InnoDB的临时表空间文件（如`ibtmp1`或会话临时表空间文件）通常默认创建在数据目录下。即使某些磁盘临时表的文件可能根据`tmpdir`创建，InnoDB自身的临时表数据管理有其特定的表空间 (D 正确，指InnoDB引擎的临时表数据，其表空间通常在datadir)。\n\n错误选项分析：\nA) 不仅仅是优化器内部使用的临时表，用户显式创建的`TEMPORARY TABLE`如果符合条件（如过大或含特定列类型）也会在`tmpdir`中创建磁盘文件。\nC) 磁盘临时表不一定只在配置为使用MyISAM时才在`tmpdir`中创建。MySQL可以配置磁盘临时表的默认存储引擎（如`internal_tmp_disk_storage_engine`参数，默认为InnoDB）。\nE) InnoDB的临时表空间通常位于数据目录（datadir）下（如`#innodb_temp`子目录），而不是直接在`/tmp`（除非`datadir`本身就是`/tmp`，或者有特殊配置将InnoDB临时表空间指向`/tmp`，但这不常见）。`tmpdir=/tmp`是指当MySQL需要创建通用的、非特定于InnoDB表空间的磁盘临时文件时使用的目录。\n\n**考点总结:**\n此题考察MySQL临时表的创建和存储机制，特别是内存临时表与磁盘临时表的转换、`tmp_table_size`和`tmpdir`参数的作用，以及InnoDB临时表空间的存放位置。\n\n**OCR答案提示“Use of memory-mapped temporary files by the TempTable storage engine as an overflow mechanism for internal temporary tables is governed by these rules:Temporary files are created in the directory defined by the tmpdir variable.”** 这段话描述了MySQL 8.0.16引入的TempTable存储引擎的行为，它用于内部临时表。当内存不足时，它会将数据溢出到`tmpdir`中创建的内存映射文件。这与B选项的逻辑一致。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分内存临时表和磁盘临时表。理解`tmp_table_size`是内存限制，`tmpdir`是磁盘文件位置。注意InnoDB有其自身的临时表空间管理。\n\n**学习建议:**\n学习MySQL临时表的类型（用户创建的`TEMPORARY TABLE`、优化器内部使用的临时表）、创建条件和存储方式（内存MEMORY引擎、磁盘MyISAM或InnoDB引擎、MySQL 8.0.16+的TempTable引擎）。掌握相关的配置参数，如`tmp_table_size`, `max_heap_table_size`, `tmpdir`, `internal_tmp_disk_storage_engine`, `temptable_max_ram`, `temptable_use_mmap`等。了解InnoDB临时表空间的配置和监控。"
    },
    {
        "question": "### 试题 143:\n\nChoose the best answer. What is the correct syntax for using transparent data encryption with an existing InnoDB table?",
        "selections": {
            "A": "ALTER TABLE t1 SET TDE = 'ON';",
            "B": "ALTER TABLE t1 ADD ENCRYPTED_TABLESPACE = 'Y';",
            "C": "ALTER TABLE t1 ENCRYPTION='Y';",
            "D": "ALTER TABLE t1 WITH ENCRYPTION USING MASTER KEY;"
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n为现有的InnoDB表启用透明数据加密（TDE），或者更改其加密状态，使用`ALTER TABLE`语句。\nC) `ALTER TABLE t1 ENCRYPTION='Y';`：这是启用或修改表加密状态的正确语法。`ENCRYPTION='Y'`表示启用加密，`ENCRYPTION='N'`表示禁用加密（如果表已加密，这会解密表）。表名`t1`应替换为实际表名 (C 正确，假设`11`是`t1`的笔误)。\n\n错误选项分析：\nA) `SET TDE = 'ON'`不是`ALTER TABLE`的有效子句。\nB) `ADD ENCRYPTED_TABLESPACE = 'Y'`不是标准的SQL语法来启用表加密。\nD) `WITH ENCRYPTION USING MASTER KEY`不是标准的SQL语法。虽然TDE使用主密钥和表空间密钥，但启用加密是通过`ENCRYPTION='Y'`子句，密钥管理由后台的密钥环插件处理。\n\n**考点总结:**\n此题考察为InnoDB表启用或修改透明数据加密（TDE）的SQL语法。核心是`ALTER TABLE ... ENCRYPTION='Y';`命令。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住启用/禁用InnoDB表加密的标准`ALTER TABLE`语法。将其与创建加密表（`CREATE TABLE ... ENCRYPTION='Y';`）的语法联系起来。\n\n**学习建议:**\n学习MySQL的透明数据加密（TDE）功能，特别是InnoDB表的加密。掌握如何创建加密表和修改现有表的加密状态。了解启用TDE的前提条件（如已配置密钥环插件）。熟悉与加密相关的表选项和系统变量。"
    },
    {
        "question": "### 试题 144:\n\nChoose the best answer. You have configured GTID-based asynchronous replication with one master and one slave. A user accidentally updated some data on the slave. To fix this, you stopped replication and successfully reverted the accidental changes. Examine the current GTID information:\n\n```\nMaster uuid:           aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa\nMaster gtids_executed: aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-10300\nMaster gtids_purged:   aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-3820\n\nSlave uuid:            bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb\nSlave gtids_executed:  aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-10167,\n                       bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb:1-9\nSlave gtids_purged:    aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-2312\n```\nYou must fix GTID sets on the slave to avoid replicating unwanted transactions in case of failover. Which set of actions would allow the slave to continue replicating without erroneous transactions?",
        "selections": {
            "A": "RESET MASTER; SET GLOBAL gtid_purged='aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-2312'; SET GLOBAL gtid_executed='aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-10167';",
            "B": "RESET MASTER; SET GLOBAL gtid_purged='aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-10167';",
            "C": "RESET SLAVE; SET GLOBAL gtid_purged='aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-3820'; SET GLOBAL gtid_executed='aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-10300';",
            "D": "SET GLOBAL gtid_purged='aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-2312,bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb:1-9'; SET GLOBAL gtid_executed='aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-10167';",
            "E": "RESET SLAVE; SET GLOBAL gtid_purged='aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-10167';"
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n场景：从库上误操作并已回退。现在需要调整从库的GTID状态，使其能从主库正确的位置继续复制，并且跳过那些在从库上已发生并回退的事务（即`bbbb...:1-9`这些事务），同时确保主库上已发生的、从库尚未应用的事务会被复制。\n当前状态：\n- 主库已执行到 `aaaa...:1-10300`。\n- 从库已执行了主库的 `aaaa...:1-10167` 以及自身的 `bbbb...:1-9`（这些是误操作，已回退）。\n- 从库的 `gtid_purged`（对于主库的UUID）是 `aaaa...:1-2312`。\n\n目标：让从库从 `aaaa...:10168` 开始复制主库的事务，并且忽略掉本地已回退的 `bbbb...:1-9`。\n\nD) `SET GLOBAL gtid_purged='aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-2312,bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb:1-9'; SET GLOBAL gtid_executed='aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-10167';`\n   - 第一部分，`SET GLOBAL gtid_purged`：将从库上已回退的本地事务 `bbbb...:1-9` 添加到 `gtid_purged` 中。这告诉从库，这些事务已经被“清除”或“跳过”，将来即使主库（或其他源）发送这些GTID，从库也不会再应用它们。同时保留了原有的主库GTID的purged部分 `aaaa...:1-2312`。\n   - 第二部分，`SET GLOBAL gtid_executed`：保持从库已执行的主库GTID集合为 `aaaa...:1-10167`。这意味着从库知道它已经应用了主库到 `10167` 的所有事务。\n   当从库重新连接主库并使用`MASTER_AUTO_POSITION=1`时，它会发送其`gtid_executed`集合给主库。主库会找到从库缺失的GTID（即`aaaa...:10168-10300`）并发送给从库。由于`bbbb...:1-9`已在`gtid_purged`中，即使将来这些GTID以某种方式出现，从库也会跳过它们。\n   这个操作组合是正确的，它确保从库从正确的位置继续，并标记本地误操作为已处理/跳过 (D 正确)。\n\n错误选项分析：\nA) `RESET MASTER`会清除主库的二进制日志和GTID信息（如果它也作为主库），这不是从库操作。如果是在从库上执行，其效果可能与`RESET SLAVE ALL`类似。修改`gtid_purged`和`gtid_executed`的方式也不完全正确，因为它没有处理本地产生的`bbbb...`GTID。\nB) 同A，`RESET MASTER`不适用。只设置`gtid_purged`为`aaaa...:1-10167`意味着所有主库到10167的事务都被认为是已清除/跳过，这与`gtid_executed`应该是`aaaa...:1-10167`矛盾。\nC) `RESET SLAVE`会重置复制状态，但之后设置的`gtid_purged`和`gtid_executed`模仿了主库的状态，这不正确。从库应该基于自己已执行和已清除的状态来配置。\nE) `RESET SLAVE`后，将`gtid_purged`设为`aaaa...:1-10167`意味着从库将跳过主库到10167的所有事务，这是错误的，因为从库已经执行了这些。\n\n**考点总结:**\n此题考察在GTID复制环境下，当从库发生误操作并回退后，如何手动调整从库的`gtid_purged`和`gtid_executed`集合以确保复制能从正确的位置继续，并避免重新应用不希望的事务。关键在于理解这两个GTID集合的作用，以及如何通过它们来控制复制行为。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解GTID复制中`gtid_executed`（已执行的GTID集合）和`gtid_purged`（已清除/跳过的GTID集合）的核心作用。当需要跳过某些事务或从特定点开始复制时，需要正确地操纵这两个集合。通常，已在从库执行并希望保留的事务应在`gtid_executed`中，而已在从库发生但不希望再次应用的（如已回退的本地修改）应加入到`gtid_purged`中。\n\n**学习建议:**\n学习MySQL GTID复制的原理和管理。掌握`gtid_mode`, `enforce_gtid_consistency`, `gtid_executed`, `gtid_purged`等关键参数和系统变量。学习如何在不同场景下（如故障转移、跳过事务、重新同步从库）手动操作GTID集合。熟悉`RESET MASTER`和`RESET SLAVE`命令对GTID状态的影响。使用`mysqlbinlog`配合GTID进行分析和恢复也是重要技能。"
    },
    {
        "question": "### 试题 145:\n\nYour `my.cnf` file contains these settings:\n```ini\n[mysqld]\nlog_output=FILE slow_query_log\nlong_query_time=2.01\nlog_queries_not_using_indexes\n```\nYou want to log queries that looked at a minimum of 5000 records and either took longer than 5 seconds to run or did not use indexes.\nWhich contains all the settings that you need to add to or modify the slow log configuration?",
        "selections": {
            "A": "log_throttle_queries_not_using_indexes=5",
            "B": "long_query_time=5 log_throttle_queries_not_using_indexes=5",
            "C": "long_query_time=5",
            "D": "long_query_time=5 log_throttle_queries_not_using_indexes=5 min_examined_row_limit=5000",
            "E": "long_query_time=5 min_examined_row_limit=5000",
            "F": "min_examined_row_limit=5000",
            "G": "log_throttle_queries_not_using_indexes=5 min_examined_row_limit=5000"
        },
        "answers": [
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n当前慢查询日志配置：\n- `log_output=FILE slow_query_log`：慢查询日志输出到文件（如果`slow_query_log=ON`的话）。\n- `long_query_time=2.01`：执行时间超过2.01秒的查询被认为是慢查询。\n- `log_queries_not_using_indexes`：记录没有使用索引的查询（即使它们执行时间不长）。\n\n目标配置：记录满足以下任一条件的查询：\n1.  检查了至少5000行记录 **并且** 执行时间超过5秒。\n2.  检查了至少5000行记录 **并且** 没有使用索引。\n\n需要修改或添加的参数：\n- 将`long_query_time`修改为5秒。\n- 添加`min_examined_row_limit=5000`，以记录那些检查了至少5000行的查询。\n\nE) `long_query_time=5 min_examined_row_limit=5000`：\n   - `long_query_time=5`: 将慢查询的阈值设为5秒。\n   - `min_examined_row_limit=5000`: 记录那些检查行数达到5000的查询。\n   结合原有的`log_queries_not_using_indexes`，现在的逻辑会是：\n   -   如果一个查询执行时间 > 5秒，它会被记录。\n   -   如果一个查询没有使用索引，它会被记录。\n   -   如果一个查询检查的行数 >= 5000，它也会被记录（因为`log_slow_admin_statements`和`log_slow_slave_statements`等其他条件可能触发）。\n   题目要求是 “（检查了至少5000行 **并且** 执行时间超过5秒） **或者** （检查了至少5000行 **并且** 没有使用索引）”。\n   `log_queries_not_using_indexes`会记录所有未使用索引的查询，无论其检查行数。 `min_examined_row_limit`会使检查行数达到阈值的查询也被考虑为“慢”并可能被记录。\n\n   如果同时设置 `long_query_time=5`, `min_examined_row_limit=5000`, 和 `log_queries_not_using_indexes`：\n   -   查询A：检查4000行，耗时6秒 -> 记录 (因为 > long_query_time)\n   -   查询B：检查6000行，耗时3秒，使用索引 -> 记录 (因为 > min_examined_row_limit 且满足慢查询的其他条件，如 `log_slow_filter`)\n   -   查询C：检查6000行，耗时3秒，未使用索引 -> 记录 (因为未使用索引，也因为 > min_examined_row_limit)\n   -   查询D：检查4000行，耗时3秒，未使用索引 -> 记录 (因为未使用索引)\n\n   题目要求的逻辑是 “`(rows >= 5000 AND time > 5)` OR `(rows >= 5000 AND no_index)`”。\n   MySQL的慢查询日志是“或”逻辑：如果满足`long_query_time`，或满足`log_queries_not_using_indexes`（且`log_slow_filter`允许），或满足`min_examined_row_limit`（且`log_slow_filter`允许），就会被记录。\n\n   E选项 `long_query_time=5 min_examined_row_limit=5000` 结合原有的 `log_queries_not_using_indexes`，会记录：\n   1.  耗时 > 5秒的。\n   2.  未使用索引的。\n   3.  检查行数 >= 5000的（如果`log_slow_filter`等条件允许）。\n\n   要精确实现题目的 “AND” 逻辑，单靠这些参数组合可能无法完美实现。但是，E选项的组合是最接近能捕获大部分目标查询的配置。它确保了耗时超过5秒的被记录，检查行数多的被记录，未使用索引的被记录。\n\n   如果一个查询检查了6000行且耗时6秒，它会被记录。\n   如果一个查询检查了6000行且未使用索引（耗时3秒），它也会被记录。\n   这基本满足了题目的两个分支条件。 (E 正确)\n\n错误选项分析：\nA), G) `log_throttle_queries_not_using_indexes`用于限制未使用索引的查询被记录到慢查询日志的频率，与筛选条件无关。\nB), D) 同上，包含`log_throttle_queries_not_using_indexes`。\nC) 只修改`long_query_time`，没有考虑检查行数的要求。\nF) 只添加`min_examined_row_limit`，没有修改执行时间阈值。\n\n**考点总结:**\n此题考察MySQL慢查询日志的配置参数，特别是如何组合使用`long_query_time`, `log_queries_not_using_indexes`, `min_examined_row_limit`来捕获特定类型的慢查询。\n\n**关键理解：MySQL慢查询日志的条件是“或”的关系，只要满足其中一个条件（且未被过滤器排除），查询就会被记录。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解每个慢查询日志参数的作用。分析题目要求的逻辑条件（AND, OR）。选择最能覆盖这些条件的参数组合。\n\n**学习建议:**\n学习MySQL慢查询日志的配置和使用。掌握`slow_query_log`, `long_query_time`, `log_queries_not_using_indexes`, `min_examined_row_limit`, `log_output`, `log_slow_admin_statements`, `log_slow_slave_statements`, `log_slow_filter`, `log_throttle_queries_not_using_indexes`等参数。了解如何分析慢查询日志（如使用`mysqldumpslow`工具）来找出性能瓶颈。"
    },
    {
        "question": "### 试题 146:\n\nChoose the best answer. What does the binlog dump thread do?",
        "selections": {
            "A": "It monitors and schedules the rotation/deletion of the binary logs.",
            "B": "It connects to the master and asks it to send updates recorded in its binary logs.",
            "C": "It acquires a lock on the binary log for reading each event to be sent to the slave.",
            "D": "It reads the relay log and executes the events contained in them."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n二进制日志转储线程（binlog dump thread）是在主服务器（Master 或 Source）上为每个连接的从服务器（Slave 或 Replica）创建的线程。\nC) 它在读取要发送给从服务器的每个事件时，会获取二进制日志文件上的锁（通常是互斥锁或特定类型的读锁），以确保读取操作的原子性和一致性。一旦事件被读取完毕（准备发送），锁会尽快释放 (C 正确，描述了其操作的一个方面)。\n\n更完整的描述是：当从库的I/O线程连接到主库并请求binlog事件时，主库会为这个连接创建一个binlog dump线程。这个线程负责从主库的二进制日志文件中读取事件，并将这些事件发送给从库的I/O线程。\n\n错误选项分析：\nA) 二进制日志的轮转和删除通常由服务器的内部机制（如达到`max_binlog_size`、执行`FLUSH LOGS`、根据`expire_logs_days`自动清理）或DBA手动操作（`PURGE BINARY LOGS`）来管理，不是binlog dump线程的职责。\nB) 这是从库的I/O线程的工作，它连接到主库并请求binlog更新。\nD) 读取中继日志（relay log）并执行其中的事件是从库的SQL线程的工作。\n\n**考点总结:**\n此题考察对MySQL复制中主库binlog dump线程核心职责的理解。它的主要任务是响应从库的请求，从主库的二进制日志读取事件并将其发送给从库。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n清晰地区分复制拓扑中各个组件（主库binlog dump线程、从库I/O线程、从库SQL线程）的职责和交互关系。binlog dump线程是在主库上，为从库服务的。\n\n**学习建议:**\n学习MySQL异步复制的架构和工作流程。详细了解主库上的binlog dump线程如何产生、如何工作以及它与从库I/O线程的通信机制。熟悉相关的状态变量和监控方法，以诊断复制链路中的问题。"
    },
    {
        "question": "### 试题 147:\n\nChoose the best answer. You want to check the values of the `sort_buffer_size` session variables of all existing connections. Which performance_schema table can you query?",
        "selections": {
            "A": "user_variables_by_thread",
            "B": "global_variables",
            "C": "variables_by_thread",
            "D": "session_variables"
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题134内容几乎完全相同。\n要查看所有现有连接（线程）的会话级别系统变量（如`sort_buffer_size`）的当前值，可以使用Performance Schema中的`variables_by_thread`表。\nC) `performance_schema.variables_by_thread`：显示每个活动线程的会话系统变量的当前值 (C 正确)。\n\n错误选项分析同试题134。\n\n**考点总结:**\n再次强调通过Performance Schema的`variables_by_thread`表查询所有活动连接的特定会话系统变量的值。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复的考点应加强记忆。记住表名通常能从字面意思推断其功能（如`variables_by_thread`）。\n\n**学习建议:**\n参考试题134的学习建议。熟练使用Performance Schema是MySQL性能诊断和监控的重要技能。"
    },
    {
        "question": "### 试题 149:\n\nChoose the best answer. You wish to protect your MySQL database against SQL injection attacks.\nWhich method would fail to do this?",
        "selections": {
            "A": "using stored procedures for any database access",
            "B": "avoiding concatenation of SQL statements and user-supplied values in an application",
            "C": "using PREPARED STATEMENTS",
            "D": "installing and configuring the Connection Control plugin"
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n防范SQL注入攻击的方法：\nA) 对所有数据库访问使用存储过程：如果存储过程内部正确地处理了参数（例如，不动态构造SQL），并且应用程序只通过调用存储过程来与数据库交互，这可以有效地将SQL逻辑与用户输入分离，从而防范SQL注入 (这是一个有效的方法)。\nB) 在应用程序中避免将用户提供的值直接拼接到SQL语句中：这是SQL注入发生的主要原因。应该使用参数化查询或预编译语句 (这是一个有效的方法)。\nC) 使用预编译语句（PREPARED STATEMENTS）：预编译语句将SQL逻辑和数据分开发送给数据库服务器。SQL结构先被解析和编译，然后用户提供的数据作为参数绑定到预编译的语句上，数据不会被解释为SQL代码，从而从根本上防止SQL注入 (这是一个非常有效的方法)。\n\n题目问“哪种方法会失败”（Which method would fail to do this?），即哪种方法不能有效防范SQL注入。\nD) 安装和配置连接控制插件（Connection Control plugin）：连接控制插件用于在连接尝试失败次数过多时延迟服务器的响应，以减缓暴力破解密码的攻击。它与防范SQL注入攻击没有直接关系 (D 是与SQL注入防护无关的方法，因此它会“失败”于防护SQL注入)。\n\n**考点总结:**\n此题考察防范SQL注入攻击的有效方法和无效方法。核心在于避免动态构造SQL语句，使用参数化查询/预编译语句，以及通过存储过程封装SQL逻辑。连接控制插件是针对另一种类型的攻击（暴力破解）。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解SQL注入的根本原因——将用户输入的数据当作SQL代码执行。选择那些能从机制上分离代码和数据的方法作为有效防护。区分不同安全插件或机制的用途。\n\n**学习建议:**\n学习SQL注入攻击的原理、各种类型和危害。掌握防范SQL注入的最佳实践，主要是：\n1.  **参数化查询/预编译语句 (Prepared Statements)**：这是最根本和最推荐的方法。\n2.  **输入验证 (Input Validation)**：对所有用户输入进行严格的类型、格式、长度和内容验证。\n3.  **最小权限原则 (Least Privilege)**：数据库连接账户只应拥有其完成工作所必需的最小权限。\n4.  **转义特殊字符 (Escaping Special Characters)**：作为一种补充手段，对用户输入中可能引起SQL歧义的特殊字符进行转义（但不应仅依赖此方法）。\n5.  **使用存储过程 (Stored Procedures)**：如果存储过程编写得当（不动态构造SQL），可以作为一层额外的防护。\n6.  **Web应用防火墙 (WAF)**：可以在应用层面拦截一些已知的SQL注入攻击模式。\n了解MySQL提供的连接控制插件、密码验证插件、审计插件、防火墙插件等不同安全相关组件的功能和适用场景。"
    },
    {
        "question": "### 试题 150:\n\nChoose the best answer. How can `mysql_multi` be configured to allow MySQL instances to use the same port number?",
        "selections": {
            "A": "The instances listen on different IP addresses.",
            "B": "The instances use different user accounts unique to each instance.",
            "C": "The instances use different socket names.",
            "D": "The instances have appropriate net masks set."
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysql_multi`（更常见的可能是指运行多个`mysqld`进程，或通过`mysqld_multi`脚本管理）允许在同一台物理主机上运行多个MySQL服务器实例。如果这些实例要使用相同的TCP端口号（例如，默认的3306），它们必须绑定到该主机上不同的IP地址。\nA) 实例监听在不同的IP地址上：如果一台主机配置了多个IP地址（例如，有多块网卡，或者一块网卡绑定了多个IP别名），那么每个MySQL实例可以配置为只监听其中一个唯一的IP地址，并使用相同的端口号。这样，客户端可以通过 `IP_address:port` 来区分不同的实例 (A 正确)。\n\n错误选项分析：\nB) 使用不同的用户账户与端口共享无关。\nC) 套接字名称（socket names）用于本地Unix域套接字连接，与TCP端口无关。不同实例确实需要使用不同的套接字文件，但这不能解决它们共享同一TCP端口的问题。\nD) 网络掩码（net masks）用于定义IP地址的网络部分和主机部分，与同一主机上多个实例共享端口无关。\n\n**考点总结:**\n此题考察在单个主机上运行多个MySQL实例时，如果它们需要使用相同的TCP端口号，如何通过绑定到不同IP地址来实现。这是网络配置层面的解决方案。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解网络套接字绑定的基本原则：一个唯一的 `IP:Port` 组合只能被一个进程监听。如果要重用端口，则IP必须不同（在同一台机器上）。\n\n**学习建议:**\n学习如何在单个主机上运行多个MySQL实例。掌握为每个实例配置独立的选项文件，并指定不同的`port`（如果IP相同）或不同的`bind-address`（如果端口相同且主机有多个IP）。了解`mysqld_multi`脚本（如果仍在使用）或使用systemd等现代服务管理工具来管理多实例的方法。"
    },
    {
        "question": "### 试题 151:\n\nChoose the best answer. You plan to upgrade your MySQL 5.7 instance to version 8. You have installed the 8 build of MySQL Shell. Examine this command executed from the operating system shell prompt: `mysqlsh --uri root@localhost:3306 -- util check-for-server-upgrade`\nWhich statement is true?",
        "selections": {
            "A": "It documents any problems with your 5.7 tables to make them ready to upgrade to 8.",
            "B": "It fails because the operation name must be in camelCase.",
            "C": "It fixes any problems with your 5.7 tables to make them ready to upgrade to 8.",
            "D": "It is mandatory to clear the history of prior results before executing this process a second time or later.",
            "E": "It fails because checkForServerUpgrade must be executed only within an active shell session as a method of the util object.",
            "F": "It is mandatory to run this command so that MySQL 8.0 software's auto-upgrade process has the details it needs to operate properly."
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL Shell 提供的 `util.checkForServerUpgrade()` (或其命令行等效调用) 工具用于在升级 MySQL 服务器之前检查现有实例是否存在与新版本不兼容的问题或潜在的升级障碍。\nA) 它会检查你的5.7版本中的表、配置等，并记录（报告）任何可能阻碍升级到8.0的问题，或者在新版本中行为会发生变化的方面，帮助你为升级做好准备 (A 正确)。\n\n错误选项分析：\nB) MySQL Shell 的 JavaScript 和 Python 模式对函数名的大小写有不同约定，但作为命令行工具调用时，通常使用规范的名称。`check-for-server-upgrade`是其命令行形式的效用函数名称之一，不是因为大小写问题而失败。\nC) 这个工具主要是检查和报告问题，它本身不“修复”这些问题。修复通常需要DBA根据报告手动进行。\nD) 该工具没有强制要求在再次执行前清除历史结果的机制。\nE) 命令的执行方式 `mysqlsh --uri ... -- util check-for-server-upgrade` 是从操作系统shell调用MySQL Shell执行一个工具函数，这是支持的用法。并非必须在交互式MySQL Shell会话中作为对象方法调用。\nF) 运行这个检查工具是强烈推荐的最佳实践，但并非“强制性”的。MySQL 8.0服务器在启动时会自动进行数据字典升级等过程，但预先检查可以避免升级过程中遇到意外问题。\n\n**考点总结:**\n此题考察MySQL Shell提供的升级前检查工具`util.checkForServerUpgrade()`的功能和作用。核心在于它是一个诊断和报告工具，帮助识别升级风险，而不是自动修复工具。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解升级前检查工具的目的——“检查”和“报告”，而不是“修复”。将其视为升级准备工作的一部分。\n\n**学习建议:**\n学习MySQL的升级流程，特别是从主要版本（如5.7）升级到新主要版本（如8.0）的步骤和注意事项。熟悉MySQL Shell提供的升级实用程序，如`util.checkForServerUpgrade()`。了解升级过程中可能遇到的常见问题和不兼容性，以及如何解决它们。务必在升级生产环境前，在测试环境中进行充分的测试。"
    },
    {
        "question": "### 试题 152:\n\nChoose the best answer. Your MySQL instance is capturing a huge amount of financial transactions every day in the `finance` database. Company policy is to create a backup every day. The main tables being updated are prefixed with `transactions-`. These tables are archived into tables that are prefixed with `archives-` each month. `mysqlbackup --optimistic-busy-tables='^finance\\\\.transactions-.*' backup`\nWhich optimization process best describes what happens with the redo logs?",
        "selections": {
            "A": "The redo logs are backed up first, then the transaction and archive tables.",
            "B": "The redo logs are backed up only if there are changes showing for the transactions tables.",
            "C": "The redo logs are not backed up at all.",
            "D": "The transaction tables are backed up first, then the archive tables and redo logs.",
            "E": "The archive tables are backed up first, then the transaction tables and redo logs."
        },
        "answers": [
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlbackup`（MySQL Enterprise Backup）使用了`--optimistic-busy-tables`选项，其后的正则表达式`'^finance\\\\.transactions-.*'`指定了哪些表被认为是“繁忙的”（即在备份期间可能被修改）。\n乐观备份（Optimistic Backup）的工作流程通常是：\n1.  **第一阶段（乐观阶段）**: 首先备份那些被认为是“不活动的”或“变化较少”的表。对于这些表，备份期间通常不加锁或加锁时间很短。在这个阶段，由于假设这些表不会有太多变化，redo日志、undo日志和系统表空间可能不会在此时立即备份（或只备份其初始状态）。\n2.  **第二阶段**: 然后备份那些被标记为“繁忙的”表（由`--optimistic-busy-tables`指定，或者通过`--optimistic-time`排除不活动的表后剩下的表）。在备份这些繁忙表时，`mysqlbackup`会采取措施确保数据的一致性，例如，可能会锁定这些表（或使用InnoDB的热备份机制），并且在这个阶段会密切关注redo日志的变化。\n3.  **最后阶段**: 在所有表数据备份完毕后，会备份redo日志文件，以确保备份中包含了在整个备份过程中（特别是繁忙表备份期间）发生的所有事务更改。这样在恢复时，可以通过应用redo日志来使数据达到一致状态。\n\nE) 归档表（`archives-`前缀的表）很可能被视为“不活动的”或变化较少的（因为它们是月度归档，而`transactions-`表是每日更新的繁忙表）。因此，在乐观备份的第一阶段，这些归档表会先被备份。然后，在第二阶段，繁忙的`transactions-`表会被备份。最后，redo日志会被备份以覆盖整个备份过程中的变化 (E 正确，符合乐观备份先备份不活跃表，再备份活跃表，最后备份日志的逻辑)。\n\n错误选项分析：\nA) Redo日志通常是在数据文件备份的后期或最后阶段备份的，以捕获整个备份期间的所有更改。\nB) Redo日志总是需要备份的，以确保事务的持久性和恢复时的一致性，无论`transactions-`表是否有变化（因为其他表也可能变化，或者需要redo日志来保证整个实例的一致性）。\nC) Redo日志是物理备份的关键组成部分，必须备份。\nD) 顺序不符合乐观备份的逻辑。不活跃的表（如归档表）通常先备份。\n\n**考点总结:**\n此题考察MySQL Enterprise Backup的乐观备份（Optimistic Backup）特性，特别是`--optimistic-busy-tables`选项如何影响备份顺序和对redo日志的处理。核心思想是先备份变化少的表以减少锁定时间，然后备份变化多的表并确保捕获所有相关的redo日志。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解乐观备份的基本原理——区分“繁忙”表和“不繁忙”表，并采用不同的备份策略和顺序。记住redo日志在物理备份中的关键作用（保证事务一致性和崩溃恢复）。\n\n**学习建议:**\n学习MySQL Enterprise Backup (`mysqlbackup`) 的高级特性，如乐观备份（`--optimistic-busy-tables`, `--optimistic-time`）、增量备份、压缩备份、加密备份、传输表空间备份等。了解这些特性如何帮助优化备份性能、减少对生产环境的影响以及满足不同的备份恢复需求。阅读官方文档中关于乐观备份的详细说明和工作流程。"
    },
    {
        "question": "### 试题 153:\n\nChoose the best answer. You must replay the binary logs on your MySQL server.\nWhich command do you use?",
        "selections": {
            "A": "cat binlog.000003 binlog.000004 binlog.000005 | mysql -h 127.0.0.1",
            "B": "mysqlpump -h 127.0.0.1 binlog.000003 binlog.000004 binlog.000005",
            "C": "mysql -h 127.0.0.1 --local-infile binlog.000003 binlog.000004 binlog.000005",
            "D": "mysqlbinlog binlog.000003 binlog.000004 binlog.000005 | mysql -h 127.0.0.1",
            "E": "mysqlbinlog -h 127.0.0.1 binlog.000003 binlog.000004 binlog.000005"
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n要在MySQL服务器上“重放”（replay）二进制日志文件中的事件，通常使用`mysqlbinlog`工具将二进制日志内容转换为可执行的SQL语句，然后通过`mysql`客户端将其导入到目标服务器。\nD) `mysqlbinlog binlog.000003 binlog.000004 binlog.000005 | mysql -h 127.0.0.1`：\n   - `mysqlbinlog binlog.000003 binlog.000004 binlog.000005`：这个部分读取指定的多个二进制日志文件，并将它们的内容（事件）转换为SQL语句输出到标准输出。\n   - `|`：管道符，将前一个命令的标准输出作为后一个命令的标准输入。\n   - `mysql -h 127.0.0.1`：`mysql`客户端连接到本地主机（`127.0.0.1`）上的MySQL服务器，并执行从标准输入接收到的SQL语句。\n   这个组合命令是重放二进制日志的标准方法 (D 正确)。\n\n错误选项分析：\nA) `cat ... | mysql ...`：`cat`命令直接输出二进制日志文件的原始内容，这些原始二进制内容不能直接被`mysql`客户端作为SQL执行。\nB) `mysqlpump`是一个逻辑备份工具，不用于重放二进制日志。\nC) `mysql --local-infile ...`：`--local-infile`用于`LOAD DATA LOCAL INFILE`语句，与直接执行二进制日志内容无关。\nE) `mysqlbinlog -h 127.0.0.1 ...`：`mysqlbinlog`的`-h`（或`--host`）选项用于连接到远程MySQL服务器以读取其二进制日志（远程binlog读取功能），而不是用于指定将转换后的SQL应用到哪个服务器。将SQL应用到服务器是通过管道给`mysql`客户端。\n\n**考点总结:**\n此题考察重放MySQL二进制日志的标准命令组合。核心是使用`mysqlbinlog`将二进制日志转换为SQL，然后使用`mysql`客户端执行这些SQL。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住`mysqlbinlog`是处理二进制日志文件的主要工具。理解管道符`|`在命令行中的作用（连接命令的输入输出）。\n\n**学习建议:**\n学习`mysqlbinlog`工具的各种选项，包括如何按时间、位置或GTID范围过滤事件，如何解码不同格式的binlog（如`--base64-output=DECODE-ROWS`），以及如何将其输出用于时间点恢复或数据分析。进行实际的binlog重放操作以加深理解。"
    },
    {
        "question": "### 试题 154:\n\nChoose the best answer. Examine this statement, which executes successfully:\n```sql\nCREATE TABLE world.city (\n  ID int NOT NULL AUTO_INCREMENT,\n  Name char(35) NOT NULL DEFAULT '',\n  CountryCode char(3) NOT NULL DEFAULT '',\n  District char(20) NOT NULL DEFAULT '',\n  Population int NOT NULL DEFAULT '0',\n  PRIMARY KEY (ID),\n  KEY CountryCode (CountryCode)\n) ENGINE=InnoDB;\n```\nYou want to improve the performance of this query: `SELECT Name FROM world.city WHERE Population BETWEEN 1000000 AND 2000000;`\nWhich change enables the query to succeed while accessing fewer rows?",
        "selections": {
            "A": "ALTER TABLE world.city ADD INDEX (Name);",
            "B": "ALTER TABLE world.city ADD SPATIAL INDEX (Name);",
            "C": "ALTER TABLE world.city ADD FULLTEXT INDEX (Name);",
            "D": "ALTER TABLE world.city ADD FULLTEXT INDEX (Population);",
            "E": "ALTER TABLE world.city ADD SPATIAL INDEX (Population);",
            "F": "ALTER TABLE world.city ADD INDEX (Population);"
        },
        "answers": [
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n查询条件是`WHERE Population BETWEEN 1000000 AND 2000000;`，这是一个范围查询。为了优化这个范围查询并减少访问的行数，最有效的方法是在`Population`列上创建一个常规的B-Tree索引。\nF) `ALTER TABLE world.city ADD INDEX (Population);`：在`Population`列上创建一个标准的B-Tree索引。这将允许MySQL优化器使用该索引来快速定位满足`BETWEEN`条件的行，从而避免全表扫描，显著减少访问的行数 (F 正确)。\n\n错误选项分析：\nA) 在`Name`列上创建索引对优化基于`Population`列的查询没有帮助。\nB), E) `SPATIAL INDEX`（空间索引）用于地理空间数据类型（如`POINT`, `GEOMETRY`等），不适用于普通的整数类型如`Population`。\nC), D) `FULLTEXT INDEX`（全文索引）用于对文本内容进行全文搜索（如使用`MATCH ... AGAINST`语法），不适用于对整数范围的查询。\n\n**考点总结:**\n此题考察如何为特定查询选择合适的索引类型以提高性能。对于范围查询（如`BETWEEN`, `>`, `<`, `>=`, `<=`)，在查询条件涉及的列上创建B-Tree索引是最常见和最有效的优化手段。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n分析查询的`WHERE`子句，找出用于筛选条件的列。根据列的数据类型和查询条件的操作符（如`=`, `BETWEEN`, `LIKE`等）选择合适的索引类型。\n\n**学习建议:**\n学习MySQL支持的各种索引类型（B-Tree, Hash, Full-text, Spatial, R-Tree等）及其各自的适用场景和限制。掌握如何创建和管理索引（`CREATE INDEX`, `ALTER TABLE ADD INDEX`, `DROP INDEX`）。学习使用`EXPLAIN`命令分析查询执行计划，判断索引是否被有效利用。了解索引的设计原则，如选择性、覆盖索引、复合索引的最佳列顺序等。"
    },
    {
        "question": "### 试题 155:\n\nChoose the best answer. Examine this parameter setting: `audit_log=FORCE_LOG_PERMANENT`\nWhat effect does this have on auditing?",
        "selections": {
            "A": "It prevents the audit plugin from being removed from the running server.",
            "B": "It prevents the audit log from being removed or rotated.",
            "C": "It causes the audit log to be created if it does not exist.",
            "D": "It will force the load of the audit plugin even in case of errors at server start."
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`audit_log`是一个系统变量，用于控制MySQL Enterprise Audit插件的加载和行为。当`audit_log`设置为`FORCE`或`FORCE_PLUS_PERMANENT`时，它具有特殊含义：\n- `FORCE`: 强制加载审计插件。如果插件加载失败，服务器启动会失败。\n- `FORCE_PLUS_PERMANENT`: 强制加载审计插件，并且一旦加载，该插件在服务器运行时不能被卸载（即不能通过`UNINSTALL PLUGIN audit_log;`移除）。如果插件加载失败，服务器启动也会失败。\n\n(注意：题目中的`FORCE_LOG_PERMANENT`似乎是`FORCE_PLUS_PERMANENT`的笔误或简写。假设它等同于`FORCE_PLUS_PERMANENT`的行为。)\nA) 它阻止审计插件在服务器运行时被移除。这是`FORCE_PLUS_PERMANENT`的主要效果之一 (A 正确)。\n\n错误选项分析：\nB) 这个设置主要控制插件的加载和持久性，不直接阻止审计日志文件本身的删除或轮转。日志文件的管理（如轮转、大小限制）由其他审计插件参数（如`audit_log_rotate_on_size`, `audit_log_file`等）控制。\nC) 审计日志文件的创建是在插件加载并开始记录时发生的，或者由相关配置指定。这个设置本身不“导致”文件创建，而是确保插件运行。\nD) `FORCE`或`FORCE_PLUS_PERMANENT`确实会强制加载插件，并且如果加载失败会导致服务器启动失败。但“即使在服务器启动时发生错误也强制加载”这个表述不准确，应该是如果插件本身加载就有错误，服务器就无法启动。\n\n**考点总结:**\n此题考察MySQL Enterprise Audit插件相关的`audit_log`系统变量（特别是`FORCE`和`FORCE_PLUS_PERMANENT`值）的作用。核心在于它们强制插件加载并在运行时不可卸载（对于`FORCE_PLUS_PERMANENT`）。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解不同安全相关参数（如`audit_log`）中特殊值（如`FORCE`, `PERMANENT`）的含义，它们通常表示更强的安全策略或不可更改性。\n\n**学习建议:**\n学习MySQL Enterprise Audit插件的安装、配置和使用。掌握`audit_log`系统变量的不同可选值（`OFF`, `ON`, `FORCE`, `FORCE_PLUS_PERMANENT`）及其行为。了解如何配置审计日志的格式、目标（文件、syslog）、过滤规则以及日志文件的管理（轮转、保留等）。"
    },
    {
        "question": "### 试题 157:\n\nChoose the best answer. An attempt to recover an InnoDB Cluster fails.\nExamine this set of messages and responses:\n```\nhost3:3377 ssIJS > dba.rebootClusterFromCompleteOutage ()\nReconfiguring the default cluster from complete outage...\nThe instance 'host1:3377' was part of the cluster configuration.\nWould you like to rejoin it to the cluster? y/N:y\nThe instance 'host2:3377' was part of the cluster configuration.\nWould you like to rejoin it to the cluster? y/N:y\n\nDba.rebootClusterFromCompleteOutage:The active session instance isn't the most updated in\ncomparison with the ONLINE instances of the Cluster's metadata.\nPlease use the most up to date instance:' host1:3377'. (RuntimeError)\n```\nWhich statement is true?",
        "selections": {
            "A": "The cluster is running and there is at least one ONLINE instance.",
            "B": "The instance deployed on host3 must be synchronized from a donor deployed on host1 by using the command cluster.addInstance('host1:3377').",
            "C": "It is possible to determine the most up-to-date instance by comparing different global transaction identifier (GTID) sets with GTID_SUBSET (set1, set2).",
            "D": "The active session instance is invalid and must be re-created by using the command shell.connect ('host3:3377').",
            "E": "The instance deployed on host3 must be rebuilt with a backup from the primary instance."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n错误消息“The active session instance isn't the most updated in comparison with the ONLINE instances of the Cluster's metadata. Please use the most up to date instance: 'host1:3377'.”表明当前连接的MySQL Shell会话所在的实例（host3）其GTID集合不是集群中其他在线实例GTID集合的超集，即它不是最新的，或者说它丢失了一些其他成员已应用的事务。因此，不能从这个“落后”的实例来引导整个集群的恢复。\nC) 可以通过比较不同实例的GTID集合（例如，通过查询`gtid_executed`系统变量）来确定哪个实例拥有最新的数据（即其GTID集合是其他所有实例GTID集合的超集，或者包含了最多的事务）。MySQL提供了GTID相关的函数，如`GTID_SUBSET(subset, set)`和`GTID_SUBTRACT(set1, set2)`，可以用来比较和操作GTID集合。通过这些比较，可以找出“最更新的”实例 (C 正确)。\n\n错误选项分析：\nA) 错误消息明确指出当前会话实例（host3）不是最新的，并且提示使用host1。这暗示host1可能是在线的并且拥有更新的数据。集群可能部分在线，或者至少元数据中记录了在线实例的状态。\nB) `cluster.addInstance()`用于添加新成员。如果host3数据落后，它需要的是同步（rejoin并可能触发克隆），而不是让host1作为新成员加入。\nD) 活动会话实例（host3）本身不是“无效的”，只是其数据状态不适合作为恢复集群的基准。重新连接到host3并不能解决其数据落后的问题。\nE) 不一定需要从主实例进行备份恢复。如果host3只是数据稍有落后，通过`cluster.rejoinInstance()`可能可以使其从其他健康的、更新的成员（如host1）同步数据（可能通过增量恢复或克隆）。\n\n**考点总结:**\n此题考察InnoDB集群在从完全宕机状态恢复（`rebootClusterFromCompleteOutage`）时，对实例数据状态（特别是GTID一致性）的要求。引导恢复的实例必须拥有集群中最新的或最完整的GTID集合。如果当前连接的实例不满足此条件，操作会失败并提示连接到更合适的实例。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细阅读错误消息，它通常会给出失败的原因和可能的解决方案（如本例中提示使用host1）。理解GTID在集群一致性和恢复中的核心作用。\n\n**学习建议:**\n学习MySQL InnoDB Cluster的故障恢复机制，特别是`dba.rebootClusterFromCompleteOutage()`命令的使用场景和前提条件。掌握GTID的概念以及如何比较和操作GTID集合（如使用`gtid_executed`, `GTID_SUBSET`, `GTID_SUBTRACT`）。熟悉集群成员在不同故障场景下的状态转换和恢复步骤。"
    },
    {
        "question": "### 试题 158:\n\nExamine the command, which execute successfully: `shell> mysqld --initialize-insecure`\nWhich statement is true?",
        "selections": {
            "A": "The root password is created in the error log in plain text.",
            "B": "The installation creates a temporary test environment with data in the /tmp directory.",
            "C": "The installation is created without enforcing or generating SSL certificates.",
            "D": "The root password is not created allowing easy access from the same host."
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqld --initialize-insecure`命令用于初始化MySQL数据目录，但与`mysqld --initialize`不同的是，它会创建一个没有密码的`'root'@'localhost'`用户账户。\nD) root用户密码未被创建，允许从同一主机轻松访问。这是`--initialize-insecure`的主要特点，它创建了一个无密码的root账户，仅限本地连接。这通常用于测试或自动化部署场景，之后应立即为root用户设置密码 (D 正确)。\n\n错误选项分析：\nA) 由于是`--initialize-insecure`，root用户没有密码，所以错误日志中不会有密码信息。\nB) 初始化数据目录是在`datadir`指定的路径下进行的，与`/tmp`目录无关（除非`datadir`被设置为`/tmp`）。它创建的是生产环境所需的数据文件结构，而不是“临时测试环境”。\nC) SSL证书的生成和强制使用是独立于数据目录初始化的配置。`--initialize-insecure`不直接影响SSL的默认行为。服务器启动时可能会自动生成自签名SSL证书（如果未配置），但这与初始化命令本身无关。它也不“不强制”SSL，是否强制取决于后续的服务器配置和客户端连接选项。\n\n**考点总结:**\n此题考察`mysqld --initialize-insecure`命令的特定行为，即它会创建一个无密码的本地root用户。这与`mysqld --initialize`（会生成临时密码）形成对比。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分`--initialize`和`--initialize-insecure`这两个初始化选项的关键差异——密码的创建方式。\n\n**学习建议:**\n学习MySQL数据目录初始化的不同方法和选项。理解`--initialize`和`--initialize-insecure`各自的用途和安全含义。始终记住，如果使用了`--initialize-insecure`，在首次启动服务器后必须立即为root用户设置一个强密码，并考虑运行`mysql_secure_installation`脚本进行其他安全加固。"
    },
    {
        "question": "### 试题 159:\n\nChoose the best answer. You are upgrading a MySQL instance to the latest 8.0 version. Examine this output. You plan to add this parameter to the configuration: `innodb_directories = '/innodb_extras'`\nWhich statement is true?",
        "selections": {
            "A": "It allows scanning of other locations to discover more innodb tablespaces.",
            "B": "It defines all innodb tablespace options relative to a starting parent directory.",
            "C": "It adds more temporary workspace in addition to the innodb_tmpdir location.",
            "D": "It is not necessary because innodb_data_home_dir is already defined.",
            "E": "It moves all innodb tablespaces to the /innodb_extras directory to enable a new innodb_data_home_dir to be defined."
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`innodb_directories`是一个动态系统变量（从MySQL 5.7.11开始，并在8.0中增强），用于指定MySQL服务器在启动时或执行某些操作（如`ALTER TABLE ... IMPORT TABLESPACE`）时应该扫描的其他目录，以查找InnoDB表空间文件（`.ibd`文件）。\nA) 它允许扫描其他位置以发现更多的InnoDB表空间。当表空间文件（特别是使用可传输表空间功能移动过来的文件）不在标准的`datadir`或数据库子目录下时，通过`innodb_directories`指定这些文件的位置，可以让服务器发现并使用它们 (A 正确)。\n\n错误选项分析：\nB) 它不是定义表空间选项，而是定义搜索路径。\nC) 它与临时工作空间或`innodb_tmpdir`无关。\nD) `innodb_data_home_dir`用于定义InnoDB系统表空间文件（如`ibdata1`）的默认路径前缀。`innodb_directories`用于查找独立表空间文件，它们功能不同，且`innodb_directories`的引入有其特定用途，与`innodb_data_home_dir`是否已定义不直接冲突。\nE) 它不移动任何表空间文件，只是告诉服务器去额外的目录扫描已存在的表空间文件。\n\n**考点总结:**\n此题考察`innodb_directories`系统变量的作用。核心在于它扩展了服务器查找InnoDB表空间文件的范围，特别适用于可传输表空间等场景。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解`innodb_directories`是为了“发现”位于非标准路径的表空间文件，而不是“移动”或“配置”它们。将其与`datadir`和`innodb_data_home_dir`等路径配置参数区分开。\n\n**学习建议:**\n学习MySQL的可传输表空间（Transportable Tablespaces）功能，以及`innodb_directories`参数如何配合该功能使用。了解在哪些场景下需要配置`innodb_directories`（例如，从备份恢复单个表空间文件到不同于原始路径的位置，或者在不同服务器之间迁移表空间）。熟悉相关的SQL命令，如`FLUSH TABLES ... FOR EXPORT`, `ALTER TABLE ... DISCARD TABLESPACE`, `ALTER TABLE ... IMPORT TABLESPACE`。"
    },
    {
        "question": "### 试题 160:\n\nChoose the best answer. You plan to take daily full backups, which include the `ndbinfo` and `sys` (internal) databases. Which command will back up the databases in parallel?",
        "selections": {
            "A": "mysqldump --all-databases > full-backup-$(date +%Y%m%d).sql",
            "B": "mysqlpump --include-databases=% > full-backup-$(date +%Y%m%d).sql",
            "C": "mysqlpump --all-databases > full-backup-$(date +%Y%m%d).sql",
            "D": "mysqldump --single-transaction > full-backup-$(date +%Y%m%d).sql"
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n题目要求备份所有数据库（包括`ndbinfo`和`sys`）并支持并行备份。\n- `mysqldump`是单线程的逻辑备份工具，不支持并行备份数据库。\n- `mysqlpump`是MySQL 5.7引入的逻辑备份工具，支持并行备份，可以按数据库或表级别并行处理。\n\n`mysqlpump`默认不备份`performance_schema`, `ndbinfo`, 或 `sys` schema。要备份这些系统数据库，需要在命令行中显式指定它们，或者使用能包含它们的选项。\nB) `mysqlpump --include-databases=% > full-backup-$(date +%Y%m%d).sql`：\n   - `mysqlpump`支持并行备份。\n   - `--include-databases=%`: `%`作为通配符，会选择所有数据库进行转储，包括那些`mysqlpump`默认会排除的系统数据库（如`ndbinfo`, `sys`）。这符合题目要求。 (B 正确)\n\n错误选项分析：\nA) `mysqldump`不支持并行备份。\nC) `mysqlpump --all-databases > ...`：`--all-databases`选项在`mysqlpump`中会转储所有数据库，但有某些例外（如`performance_schema`, `ndbinfo`, `sys` schema默认被排除）。要包含这些，需要显式指定或使用通配符如`%`。\n   **OCR答案提示中指出“mysqlpump does not dump the performance_schema, ndbinfo, or sys schema by default. To dump any of these, name them explicitly on the command line. You can also name them with the --databases or --include-databases option. The --all-databases option dumps all databases (with certain exceptions noted in mysqlpump Restrictions). It is equivalent to specifying no object options at all (the default mysqlpump action is to dump everything). --include-databases=% is similar to --all-databases, but selects all databases for dumping, even those that are exceptions for --all-databases.”** 这段解释支持了B选项，即`--include-databases=%`可以包含所有数据库，包括系统库。\n   因此，如果`--all-databases`在`mysqlpump`中确实排除了`ndbinfo`和`sys`，则C是错误的。B是更可靠包含所有库的方法。\nD) `mysqldump`不支持并行备份。\n\n**考点总结:**\n此题考察使用`mysqlpump`进行并行备份以及如何包含系统数据库。`mysqlpump`是实现并行逻辑备份的关键工具，而`--include-databases=%`是包含所有数据库（包括默认排除的系统库）的一种方式。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住`mysqlpump`是支持并行逻辑备份的工具。了解其默认行为（例如对系统库的排除）以及如何通过选项（如`--include-databases`, `--exclude-databases`, 通配符）来定制备份范围。\n\n**学习建议:**\n学习`mysqlpump`工具的使用方法、主要选项（特别是与并行处理、数据库/表过滤相关的选项）和特性。对比其与`mysqldump`的异同。进行实验，使用不同选项备份不同范围的数据，并检查备份内容，以熟悉其行为。"
    },
    {
        "question": "### 试题 161:\n\nThe `languages` table uses MyISAM and the `countries` table uses the InnoDB storage engine. Both tables are empty. Examine these statements:\n```sql\nBEGIN;\nINSERT INTO languages(lang) VALUES ('Italian');\nINSERT INTO countries(country) VALUES ('Italy');\nROLLBACK;\n```\nWhat is the content of both tables after executing these statements?",
        "selections": {
            "A": "countries has one row, languages has none.",
            "B": "Both tables have one row.",
            "C": "Both tables are empty.",
            "D": "languages has one row, countries has none."
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n- `languages`表使用MyISAM引擎，MyISAM是非事务性的。\n- `countries`表使用InnoDB引擎，InnoDB是事务性的。\n\nSQL语句序列：\n1.  `BEGIN;`: 开始一个事务。这个指令对InnoDB表有效，对MyISAM表无效。\n2.  `INSERT INTO languages(lang) VALUES ('Italian');`: 由于`languages`是MyISAM表（非事务性），这个插入操作会立即生效，不受后续`ROLLBACK`影响。\n3.  `INSERT INTO countries(country) VALUES ('Italy');`: 由于`countries`是InnoDB表（事务性），这个插入操作是在当前事务中进行的。\n4.  `ROLLBACK;`: 回滚当前事务。这个操作会撤销在事务中对InnoDB表`countries`所做的更改（即`INSERT INTO countries`会被回滚）。它对MyISAM表`languages`的插入操作没有影响。\n\n因此，执行完毕后：\n- `languages`表（MyISAM）会包含一行数据 ('Italian')。\n- `countries`表（InnoDB）会为空，因为插入被回滚了。\n\nD) `languages`表有一行，`countries`表没有行 (D 正确)。\n\n错误选项分析：\nA) 反了。\nB) 只有`languages`表有一行。\nC) 只有`countries`表为空。\n\n**考点总结:**\n此题考察不同存储引擎（MyISAM vs InnoDB）对事务（`BEGIN`, `ROLLBACK`）的支持和行为差异。非事务性引擎的操作会立即生效且不受事务控制，而事务性引擎的操作会遵循事务的原子性和回滚机制。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n牢记哪些存储引擎是事务安全的，哪些不是。理解`BEGIN`, `COMMIT`, `ROLLBACK`对不同引擎的精确影响。在混合使用事务性和非事务性表的场景中要特别小心。\n\n**学习建议:**\n详细学习MySQL中主要存储引擎的特性，特别是对事务的支持情况。进行实验来观察在事务中对不同引擎的表进行操作并执行`COMMIT`或`ROLLBACK`时的实际结果。了解`autocommit`系统变量的作用。"
    },
    {
        "question": "### 试题 162:\n\nWhat does the slave I/O thread do?",
        "selections": {
            "A": "connects to the master and requests it to send updates recorded in its binary logs",
            "B": "monitors and schedules I/O calls to the subsystem for the relay logs",
            "C": "reads the relay log and executes the events contained in them",
            "D": "acquires a lock on the binary log for reading each event to be sent to the slave"
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题129内容几乎完全相同，只是选项顺序可能不同。\n从服务器上的I/O线程（Slave I/O Thread 或 Replica I/O Thread）的主要职责是：\nA) 连接到主服务器（Master 或 Source），并请求主服务器将其二进制日志（binary logs）中的事件发送过来。I/O线程接收到这些事件后，将它们写入从服务器本地的中继日志（relay logs） (A 正确)。\n\n错误选项分析同试题129。\n\n**考点总结:**\n再次强调MySQL复制中从库I/O线程的核心职责：从主库获取binlog事件并写入本地中继日志。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，加强记忆。清晰区分I/O线程（取货）和SQL线程（加工）的角色。\n\n**学习建议:**\n参考试题129的学习建议。对复制架构中各组件功能的理解是解决复制相关问题的基础。"
    },
    {
        "question": "### 试题 163:\n\nChoose the best answer. Examine these commands and results:\n```sql\nmysql> SHOW GRANTS FOR jane;\n+------------------------------------------+\n| Grants for jane@%                        |\n+------------------------------------------+\n| GRANT USAGE ON *.* TO `jane`@`%`         |\n| GRANT SELECT ON `SALES`.* TO `jane`@`%` |\n+------------------------------------------+\n2 rows in set (0.00 sec)\n```\n\nJane must create a temporary table named `TOTALSALES` in the `SALES` database. Which statement will provide Jane with the required privileges based on the principle of least privilege?",
        "selections": {
            "A": "GRANT CREATE TEMPORARY TABLES, INSERT, UPDATE, DELETE, SELECT ON sales.totalsales TO jane;",
            "B": "GRANT CREATE TEMPORARY TABLES ON sales.* TO jane;",
            "C": "GRANT CREATE TEMPORARY TABLES ON sales.totalsales TO jane;",
            "D": "GRANT ALL ON sales.* TO jane;"
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nJane需要在`SALES`数据库中创建临时表`TOTALSALES`。创建临时表需要`CREATE TEMPORARY TABLES`权限。根据最小权限原则，应该只授予完成此任务所必需的最小权限。\nB) `GRANT CREATE TEMPORARY TABLES ON sales.* TO jane;`：授予Jane在`SALES`数据库中创建临时表的权限。`sales.*`表示对`SALES`数据库中的所有对象（这里特指在该数据库内创建临时表的能力）。这是满足需求且遵循最小权限原则的正确语句 (B 正确)。\n\n错误选项分析：\nA) `GRANT CREATE TEMPORARY TABLES, INSERT, UPDATE, DELETE, SELECT ON sales.totalsales TO jane;`：\n   - `ON sales.totalsales`：权限作用于特定的（未来可能创建的）表`sales.totalsales`。但`CREATE TEMPORARY TABLES`权限通常是在数据库级别授予的，允许在该数据库中创建任意名称的临时表。\n   - 授予了额外的`INSERT, UPDATE, DELETE, SELECT`权限，这些权限可能不是创建临时表所必需的，或者如果临时表创建后还需要操作，也应分开考虑。题目只问创建临时表所需的权限。\nC) `GRANT CREATE TEMPORARY TABLES ON sales.totalsales TO jane;`：同A，将`CREATE TEMPORARY TABLES`权限限制在特定表名上是不标准的。这个权限是关于“在某个数据库中创建临时表”的能力。\nD) `GRANT ALL ON sales.* TO jane;`：授予了`SALES`数据库上的所有权限，这违反了最小权限原则。\n\n**考点总结:**\n此题考察`CREATE TEMPORARY TABLES`权限的授予范围和最小权限原则的应用。`CREATE TEMPORARY TABLES`权限允许用户在拥有该权限的数据库中创建临时表。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解`CREATE TEMPORARY TABLES`权限的含义和作用域。遵循最小权限原则，只授予完成特定任务所必需的权限，避免授予过宽泛的权限。\n\n**学习建议:**\n学习MySQL的权限系统，特别是与创建对象（表、临时表、视图、存储过程等）相关的权限。掌握`GRANT`语句的语法，特别是`ON`子句如何指定权限的作用域（全局`*.*`、数据库`db_name.*`、表`db_name.table_name`、列等）。练习根据具体需求设计最小权限的授权方案。"
    },
    {
        "question": "### 试题 164:\n\nChoose the best answer. Where is the default data directory located after installing MySQL using RPM on Oracle Linux 7?",
        "selections": {
            "A": "/usr",
            "B": "/usr/mysql",
            "C": "/etc/my.cnf",
            "D": "/var/lib/mysql",
            "E": "/usr/bin"
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n在Oracle Linux 7（以及其他许多Linux发行版）上通过RPM包安装MySQL时，默认的数据目录（datadir）通常是：\nD) `/var/lib/mysql`：这是标准的MySQL数据目录位置，用于存放数据库文件、日志文件等 (D 正确)。\n\n错误选项分析：\nA) `/usr`：是Unix System Resources目录，包含许多系统程序和库，不是数据存储目录。\nB) `/usr/mysql`：可能是一些旧版本或特定编译安装的MySQL的安装路径（basedir），而不是默认的数据目录。\nC) `/etc/my.cnf`：这是MySQL的主要配置文件路径，不是数据目录。\nE) `/usr/bin`：存放可执行文件的目录，如`mysql`, `mysqld`等客户端和服务器程序，不是数据目录。\n\n**考点总结:**\n此题考察在Linux系统上通过RPM包安装MySQL时默认数据目录的路径。`/var/lib/mysql`是需要记住的标准位置。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住Linux系统上MySQL的几个关键默认路径：配置文件（`/etc/my.cnf`）、数据目录（`/var/lib/mysql`）、可执行文件（`/usr/bin`或`/usr/sbin`）。\n\n**学习建议:**\n学习MySQL在不同操作系统（Linux, Windows, macOS）上的标准安装路径和目录结构。了解如何通过查看配置文件（`my.cnf`中的`datadir`参数）或在MySQL中执行`SHOW VARIABLES LIKE 'datadir';`来确定实际的数据目录位置。熟悉Linux文件系统层次结构标准（FHS）。"
    },
    {
        "question": "### 试题 165:\n\nBinary log events for the 'mydb1' schema must be copied to a different schema name 'mydb2'. Which command will do this?",
        "selections": {
            "A": "mysqlbinlog --rewrite-db='mydb1->mydb2' | mysql",
            "B": "mysqlbinlog --database=mydb1 --database=mydb2 | mysql",
            "C": "mysqlbinlog --rewrite-db='mydb1' --rewrite-db='mydb2' | mysql",
            "D": "mysqlbinlog --read-from=remote-server --raw sed 's/mydb1/mydb2/g' | mysql"
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlbinlog`工具提供了`--rewrite-db`选项，用于在重放二进制日志时将事件中涉及的源数据库名重写为目标数据库名。\nA) `mysqlbinlog --rewrite-db='mydb1->mydb2' | mysql`：\n   - `--rewrite-db='mydb1->mydb2'`：这个选项告诉`mysqlbinlog`将所有原先针对`mydb1`数据库的事件（如`USE mydb1; CREATE TABLE t ...;`或涉及`mydb1.table_name`的操作）重写为针对`mydb2`数据库（如`USE mydb2; CREATE TABLE t ...;`或`mydb2.table_name`）。\n   - `| mysql`：将重写后的SQL语句通过管道传递给`mysql`客户端执行。\n   这个命令能够实现将`mydb1`的binlog事件应用到`mydb2`模式 (A 正确)。\n\n错误选项分析：\nB) `mysqlbinlog --database=mydb1 --database=mydb2 | mysql`：`--database`（或`-d`）选项用于从二进制日志中只提取指定数据库的事件。同时指定两个`--database`参数，其行为可能是只提取这两个数据库的事件，或者只取最后一个（取决于具体实现），但它不执行数据库名重写。\nC) `mysqlbinlog --rewrite-db='mydb1' --rewrite-db='mydb2' | mysql`：`--rewrite-db`选项的正确语法是`'source_db->target_db'`。分开指定两个`--rewrite-db`参数是不正确的用法。\nD) `mysqlbinlog --read-from=remote-server --raw | sed 's/mydb1/mydb2/g' | mysql`：\n   - `--read-from=remote-server --raw`：从远程服务器读取原始（未解码）的二进制日志事件。\n   - `sed 's/mydb1/mydb2/g'`：使用`sed`流编辑器尝试在原始二进制流中进行文本替换。直接在原始二进制日志流上执行文本替换是非常危险且不可靠的，因为数据库名可能出现在不同的上下文中，或者其编码方式可能使得简单文本替换产生错误。正确的方法是让`mysqlbinlog`先将事件解码为SQL，然后再进行有针对性的重写或过滤。\n\n**考点总结:**\n此题考察使用`mysqlbinlog`工具的`--rewrite-db`选项来实现将二进制日志事件从一个数据库模式应用到另一个数据库模式的功能。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住`mysqlbinlog`中用于数据库名重写的特定选项是`--rewrite-db`，并掌握其`'source->target'`的语法格式。\n\n**学习建议:**\n学习`mysqlbinlog`工具的高级用法，包括事件过滤（按数据库、表、时间、位置、GTID、事件类型等）、输出格式控制以及数据库/表名重写等。了解在哪些场景下可能需要这些功能（例如，从备份恢复到不同名称的数据库、搭建特定测试环境、数据迁移等）。"
    },
    {
        "question": "### 试题 166:\n\nExamine this snippet (片段) from the binary log file named `binlog.000036`:\n```\n# at 5000324\n#191120 14:15:51 server id 1  end_log_pos 500453 crc32 0x98159515 Query\tthread_id=9\texec_time=2\terror_code=0\n#       Xid = 1106\nSET TIMESTAMP=1574222116/*!*/;\nDROP TABLE `rental` /* generated by server*//*!*/;\n```\nThe `rental` table was accidentally dropped, and you must recover the table. You have restored the last backup, which corresponds to the start of the `binlog.000036` binary log.\nWhich command will complete the recovery?",
        "selections": {
            "A": "mysqlbinlog --stop-position=500324 binlog.000036 | mysql",
            "B": "mysqlbinlog --stop-datetime='2019-11-20 14:55:16' binlog.000036 | mysql",
            "C": "mysqlbinlog --stop-datetime='2019-11-20 14:55:18' binlog.000036 | mysql",
            "D": "mysqlbinlog --stop-position=500453 binlog.000036 | mysql"
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n目标是恢复被意外`DROP TABLE rental`语句删除的`rental`表。我们已经从备份恢复到了`binlog.000036`开始的某个时间点。现在需要应用`binlog.000036`中发生在`DROP TABLE`语句之前的事件，并跳过`DROP TABLE`语句本身及其后续事件。\n`DROP TABLE rental`语句的起始位置是`# at 5000324`。\n\nA) `mysqlbinlog --stop-position=500324 binlog.000036 | mysql`：这个命令会处理`binlog.000036`文件中，从文件开始到位置`500324`（不包括`500324`这个位置的事件本身）的所有事件。由于`DROP TABLE`语句从位置`5000324`开始，这个命令恰好在执行`DROP TABLE`之前停止。这样，所有在删除表之前的更改都会被应用，而删除操作本身会被跳过 (A 正确)。\n\n错误选项分析：\nB) `--stop-datetime='2019-11-20 14:55:16'`：这是`DROP TABLE`语句的时间戳（`#191120 14:15:51`，但选项写的是`14:55:16`，假设这是同一事件的另一种时间表示或近似时间）。如果以此时间为停止点，它可能会包含或排除`DROP TABLE`语句，取决于时间戳的精确匹配和`mysqlbinlog`的行为。使用位置通常更精确。\nC) `--stop-datetime='2019-11-20 14:55:18'`：这个时间点晚于`DROP TABLE`语句，所以会包含删除操作，无法恢复表。\nD) `--stop-position=500453`：这个位置是`DROP TABLE`语句的结束位置（`end_log_pos 500453`）。使用这个作为停止点会执行`DROP TABLE`语句，无法恢复表。\n\n**考点总结:**\n此题考察如何使用`mysqlbinlog`配合`--stop-position`（或`--stop-datetime`）选项进行精确的时间点恢复，特别是如何跳过一个已知的有害操作（如意外的`DROP TABLE`）。关键在于找到有害操作在binlog中的起始位置，并将恢复停止在该位置之前。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细分析binlog片段中的位置信息（`# at ...`）和时间戳信息。理解`--stop-position`和`--stop-datetime`选项是“不包括”指定的停止点。选择一个恰好在有害操作之前的停止点。\n\n**学习建议:**\n学习如何阅读和分析`mysqlbinlog`的输出（特别是文本格式和加了`--verbose`的输出）。掌握`--start-position`, `--stop-position`, `--start-datetime`, `--stop-datetime`等过滤选项的精确含义和用法。练习通过分析binlog来定位特定事件，并进行选择性恢复或跳过操作。了解GTID在简化此类操作中的优势。"
    },
    {
        "question": "### 试题 167:\n\nChoose the best answer. You recently upgraded your MySQL installation to MySQL 8.0. Examine this client error: `ERROR 2059 (HY000): Authentication plugin 'caching_sha2_password' cannot be loaded:/usr/local/mysql/lib/plugin/caching_sha2_password.so: cannot open shared object file: No such file or directory`\nWhich option will allow this client to connect to MySQL Server?",
        "selections": {
            "A": "ALTER USER user IDENTIFIED WITH caching_sha2_password BY 'password';",
            "B": "mysqld default_authentication_plugin=sha256_password",
            "C": "mysqld default_authentication_plugin=caching_sha2_password",
            "D": "ALTER USER user IDENTIFIED WITH mysql_native_password BY 'password';",
            "E": "ALTER USER user IDENTIFIED WITH sha256_password BY 'password';",
            "F": "mysqld default_authentication_plugin=mysql_native_password"
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n错误信息表明客户端在尝试使用`caching_sha2_password`认证插件进行认证时，无法加载该插件的共享库文件（`.so`文件），原因是找不到该文件或目录。\nMySQL 8.0默认的认证插件是`caching_sha2_password`。如果客户端较旧，或者客户端环境缺少相应的插件库，就可能发生此错误。\n要解决这个问题，可以让服务器端的用户账户改用一个客户端普遍支持的、不需要特殊插件库的认证方法，例如传统的`mysql_native_password`。\n\nD) `ALTER USER user IDENTIFIED WITH mysql_native_password BY 'password';`：在服务器端，将目标用户`user`的认证插件更改为`mysql_native_password`，并为其设置（或重置）密码。这样，当客户端尝试连接时，服务器会使用`mysql_native_password`插件进行认证，大多数客户端都内置支持此插件，从而避免了加载`caching_sha2_password.so`失败的问题 (D 正确)。\n\n错误选项分析：\nA) 将用户认证方式改为`caching_sha2_password`并不能解决客户端加载该插件失败的问题。\nB), C), F) `mysqld default_authentication_plugin=...`是在服务器配置文件中设置新创建用户的默认认证插件，对已存在用户的认证方式没有直接影响，也不能解决特定客户端加载特定插件库失败的问题。\nE) 将用户认证方式改为`sha256_password`。虽然`sha256_password`比`mysql_native_password`更安全，但客户端同样可能需要相应的支持。如果客户端连`caching_sha2_password`都加载不了，`sha256_password`也可能存在类似问题（取决于客户端库的完备性）。`mysql_native_password`是兼容性最好的选择。\n\n**考点总结:**\n此题考察MySQL 8.0中因客户端不支持或无法加载`caching_sha2_password`认证插件而导致连接失败的问题，以及如何通过在服务器端更改用户账户的认证插件（通常改为`mysql_native_password`）来解决此问题以保证客户端兼容性。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n当看到认证插件加载失败的错误时，要考虑客户端兼容性问题。将服务器端用户的认证方式更改为客户端广泛支持的插件（如`mysql_native_password`）是常见的解决方法。\n\n**学习建议:**\n学习MySQL 8.0的默认认证插件`caching_sha2_password`及其与旧版客户端的兼容性问题。了解不同认证插件（`mysql_native_password`, `sha256_password`, `caching_sha2_password`）的特点和安全级别。掌握如何在服务器端为用户更改认证插件（使用`ALTER USER ... IDENTIFIED WITH ...`）以及如何在客户端配置连接以支持特定认证插件（例如，通过`--default-auth`选项或在连接器中配置）。"
    },
    {
        "question": "### 试题 168:\n\nChoose the best answer. Examine this SQL statement: `UPDATE world.city SET Population = Population * 1.1 WHERE CountryCode IN (SELECT Code FROM world.country WHERE Continent = 'Asia')`\nWhich set of privileges will allow Tom to execute this SQL statement?",
        "selections": {
            "A": "GRANT UPDATE ON `world`.* TO `tom`@`%`; GRANT ALL PRIVILEGES ON `world`.`country` TO `tom`@`%`;",
            "B": "GRANT UPDATE ON `world`.`city` TO `tom`@`%`; GRANT SELECT ON `world`.* TO `tom`@`%`;",
            "C": "GRANT UPDATE ON `world`.`city` TO `tom`@`%`; GRANT SELECT ON `world`.`country` TO `tom`@`%`;",
            "D": "GRANT ALL PRIVILEGES ON `world`.`city` TO `tom`@`%`; GRANT SELECT (`Code`) ON `world`.`country` TO `tom`@`%`;"
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nSQL语句分析：\n- 主语句是`UPDATE world.city ...`：这需要对`world.city`表有`UPDATE`权限。由于`Population`列被读取（在`SET Population = Population * 1.1`的右侧）并被写入，所以对`Population`列的`SELECT`和`UPDATE`权限是必需的，或者直接对表有`UPDATE`权限。\n- 子查询是`SELECT Code FROM world.country WHERE Continent = 'Asia'`：这需要对`world.country`表的`Code`列和`Continent`列有`SELECT`权限，或者直接对`world.country`表有`SELECT`权限。\n\nC) `GRANT UPDATE ON world.city TO tom@'%'; GRANT SELECT ON world.country TO tom@'%';`：\n   - `GRANT UPDATE ON world.city TO tom@'%';`：授予用户`tom`对`world.city`表的`UPDATE`权限。这个权限通常包含了对表中所有列进行更新（和读取以更新）的能力。\n   - `GRANT SELECT ON world.country TO tom@'%';`：授予用户`tom`对`world.country`表的`SELECT`权限，允许其执行子查询。\n   这个权限组合满足了SQL语句的需求 (C 正确)。\n\n错误选项分析：\nA) `GRANT UPDATE ON world.* TO tom@'%';`：授予了对`world`数据库所有表的`UPDATE`权限，过于宽泛。`GRANT ALL PRIVILEGES ON world.country TO tom@'%';`也过于宽泛。\nB) `GRANT SELECT ON world.* TO tom@'%';`：授予了对`world`数据库所有表的`SELECT`权限，过于宽泛。\nD) `GRANT ALL PRIVILEGES ON world.city TO tom@'%';`：过于宽泛。`GRANT SELECT (Code) ON world.country TO tom@'%';`只授予了对`world.country`表`Code`列的`SELECT`权限，但子查询中`WHERE Continent = 'Asia'`还需要对`Continent`列的`SELECT`权限。所以这个`SELECT`权限不足。\n\n**考点总结:**\n此题考察根据SQL语句分析所需最小权限的能力。需要识别语句中涉及的表、列以及对它们的操作类型（SELECT, UPDATE, INSERT, DELETE等），然后授予相应的表级或列级权限。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n分解SQL语句，找出所有被访问的表和列，以及对它们进行的操作。遵循最小权限原则，只授予必需的权限。注意子查询也需要相应的权限。\n\n**学习建议:**\n学习MySQL的权限系统和`GRANT`语句的详细语法。练习分析不同类型的SQL语句（包括包含子查询、连接、函数、存储过程等的复杂语句）所需的权限。掌握表级权限和列级权限的区别和使用。始终以最小权限原则为指导来设计权限方案。"
    },
    {
        "question": "### 试题 169:\n\nChoose the best answer. Which command enables rule-based MySQL Auditing capabilities?",
        "selections": {
            "A": "shell> mysqld --initialize --log-raw=audit.log",
            "B": "mysql> INSTALL COMPONENT audit_log;",
            "C": "mysql> INSTALL PLUGIN audit_log;",
            "D": "shell> mysql < audit_log_filter_linux_install.sql"
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL Enterprise Audit支持基于规则的审计（audit filtering），允许DBA定义规则来指定哪些事件应该被审计，哪些应该被忽略。\n启用和配置基于规则的审计通常涉及：\n1.  安装审计插件（如果尚未安装）。\n2.  创建和加载审计过滤器定义。\n\nD) `shell> mysql < audit_log_filter_linux_install.sql`：这个命令从一个名为`audit_log_filter_linux_install.sql`（或类似名称）的SQL脚本文件中读取SQL语句，并通过`mysql`客户端执行它们。这个SQL脚本通常包含了创建审计过滤器所需的UDF（用户定义函数）和存储过程，以及可能的初始过滤器规则。这是启用和配置基于规则的审计（过滤器）的关键步骤 (D 正确)。\n\n错误选项分析：\nA) `mysqld --initialize --log-raw=audit.log`：`--initialize`用于初始化数据目录。`--log-raw`（如果存在这个选项）与审计日志的原始格式有关，或者可能与审计插件本身的某个配置有关，但它不直接“启用基于规则的审计能力”。\nB) `mysql> INSTALL COMPONENT audit_log;`：从MySQL 8.0开始，一些功能（包括部分审计功能）可能通过组件（Component）架构提供。如果审计功能是以组件形式提供的，这可能是安装该组件的命令。但“基于规则的审计能力”更多的是指过滤功能，通常需要额外的设置。\nC) `mysql> INSTALL PLUGIN audit_log;`：这是安装传统的审计插件（如`audit_log.so`或`audit_log.dll`）的命令。安装插件是使用审计功能的前提，但它本身不启用“基于规则”的过滤，还需要后续配置过滤器。\n\n**考点总结:**\n此题考察启用MySQL Enterprise Audit的基于规则的过滤功能的步骤。核心在于安装审计插件（如果需要）并加载过滤器定义（通常通过执行一个SQL脚本）。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分审计插件的“安装”和“配置基于规则的过滤”。基于规则的过滤是审计功能的一个高级特性，通常需要额外的设置步骤。\n\n**学习建议:**\n学习MySQL Enterprise Audit的完整功能，包括插件安装、基本审计配置（审计哪些事件、日志格式、日志目标）以及高级功能如审计过滤（基于用户、SQL命令、数据库、表等创建过滤规则）。熟悉相关的SQL脚本（如`audit_log_filter_install.sql`）和UDF/存储过程（如`audit_log_filter_set_filter`, `audit_log_filter_remove_filter`等）的使用。"
    },
    {
        "question": "### 试题 170:\n\nChoose the best answer. You are having performance issues with MySQL instances. Those servers are monitored with MySQL Enterprise Monitor. Using Query Analyzer, where do you begin to look for problem queries?",
        "selections": {
            "A": "Sort the `Exec` column and check for SQL queries with low Query Response Time index (QRTi) values.",
            "B": "Look for queries with low total latency times in the Latency section in the times series graph.",
            "C": "Sort the `Exec` column and check for SQL queries with high Query Response Time index (QRTi) values.",
            "D": "Look for queries with big prolonged spikes in row activity/access graph in the times series graph."
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL Enterprise Monitor (MEM) 的 Query Analyzer 提供多种方式来识别问题查询。\n- QRTi (Query Response Time index): 是一个衡量查询性能的指标，值越低通常表示查询性能越差（或者说，对整体响应时间的贡献越大）。Query Analyzer 通常会根据QRTi对查询进行排序或高亮显示。\nA) 按“执行次数”(\\Exec\\，这里可能指执行次数或总执行时间等能反映负载的列)排序，并检查QRTi值较低的SQL查询。QRTi值低意味着查询的性能表现不佳，是需要优先关注和优化的对象 (A 正确)。\n\n错误选项分析：\nB) “低总延迟时间”的查询通常不是性能瓶颈。我们关心的是高延迟或高总消耗的查询。\nC) QRTi值高通常表示查询性能相对较好，不是优先查找问题查询的指标。\nD) “行活动/访问图中的长时间大尖峰”确实可能指示问题查询（例如，导致大量I/O或CPU消耗的查询），这也是一种分析方法。但QRTi是一个更直接的综合性能指标，用于初步筛选。\n\n**考点总结:**\n此题考察使用MySQL Enterprise Monitor Query Analyzer识别问题查询的切入点。QRTi是一个关键的性能衡量指标，低QRTi值通常表示性能较差的查询。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解Query Analyzer中常用性能指标的含义，特别是QRTi。通常，我们会寻找那些执行次数多、总耗时长、平均耗时长或QRTi值低的查询作为优化目标。\n\n**学习建议:**\n学习MySQL Enterprise Monitor Query Analyzer的界面和主要功能。了解它如何收集查询数据，以及它提供的各种性能指标（如QRTi、执行次数、平均/最大/总延迟、检查/发送行数等）的含义。掌握如何使用Query Analyzer来识别和诊断性能瓶颈查询。"
    },
    {
        "question": "### 试题 171:\n\nChoose the best answer. Examine this command and output: \n```sql\nmysql> SHOW GLOBAL STATUS LIKE 'Firewall%';\n+------------------------------+-------+\n| Variable_name                | Value |\n+------------------------------+-------+\n| Firewall_access_denied       | 7     |\n| Firewall_access_granted      | 4     |\n| Firewall_access_suspicious   | 3     |\n| Firewall_cached_entries      | 11    |\n+------------------------------+-------+\n```\nWhich statement is true?",
        "selections": {
            "A": "Firewall_cached_entries is the number of statements found in the query cache for users in DETECTING mode.",
            "B": "Firewall_access_suspicious is the number of statements logged as suspicious for users in DETECTING mode.",
            "C": "Firewall_access_denied is the number of connection attempts from prohibited hosts that are denied.",
            "D": "Firewall_access_granted is the number of connections granted from whitelisted hosts."
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL Enterprise Firewall相关的状态变量含义：\n- `Firewall_access_denied`: 防火墙已拒绝的语句数量。\n- `Firewall_access_granted`: 防火墙已允许的语句数量。\n- `Firewall_access_suspicious`: 在`DETECTING`模式下，被识别为可疑但仍被允许执行的语句数量。\n- `Firewall_cached_entries`: 防火墙缓存中白名单摘要的数量。\n\nB) `Firewall_access_suspicious`是在`DETECTING`模式下，被记录为可疑（即不在当前白名单中，但因为是DETECTING模式而被允许执行）的语句数量 (B 正确)。\n\n错误选项分析：\nA) `Firewall_cached_entries`是防火墙白名单缓存中的条目数，与查询缓存（已废弃）或`DETECTING`模式下的语句发现无关。\nC) `Firewall_access_denied`是被防火墙阻止的SQL语句的数量，不直接是“来自禁止主机的连接尝试次数”。防火墙工作在SQL语句层面，而不是主机连接层面（那是连接控制插件或网络防火墙的事）。\nD) `Firewall_access_granted`是被防火墙允许执行的SQL语句的数量，不直接是“来自白名单主机的连接授予次数”。\n\n**考点总结:**\n此题考察对MySQL Enterprise Firewall相关状态变量含义的准确理解。核心在于区分它们是统计SQL语句（允许、拒绝、可疑）还是其他方面（如缓存条目）。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n准确记忆MySQL Enterprise Firewall的关键状态变量及其含义。理解防火墙的工作模式（OFF, DETECTING, PROTECTING, RECORDING）以及它们如何影响这些状态变量。\n\n**学习建议:**\n学习MySQL Enterprise Firewall的配置、管理和监控。熟悉相关的状态变量和Information Schema视图。进行实验，在不同模式下执行不同类型的SQL语句，观察状态变量的变化，以加深理解。"
    },
    {
        "question": "### 试题 172:\n\nChoose the best answer. Examine this output: \n```sql\nmysql> SELECT FORMAT_BYTES(@@global.innodb_buffer_pool_size) AS BufferPoolSize,\n       @@global.innodb_buffer_pool_instances AS NumInstances,\n       FORMAT_BYTES(@@global.innodb_buffer_pool_chunk_size) AS ChunkSize;\n+----------------+--------------+-----------+\n| BufferPoolSize | NumInstances | ChunkSize |\n+----------------+--------------+-----------+\n| 12.00 GiB      | 8            | 128.00 MiB|\n+----------------+--------------+-----------+\n\nmysql> SELECT * FROM sys.metrics WHERE Variable_name LIKE 'Threads%';\n+-------------------+----------------+---------------+---------+\n| Variable_name     | Variable_value | Type          | Enabled |\n+-------------------+----------------+---------------+---------+\n| threads_cached    | 4              | Global Status | YES     |\n| threads_connected | 32             | Global Status | YES     |\n| threads_created   | 112            | Global Status | YES     |\n| threads_running   | 16             | Global Status | YES     |\n+-------------------+----------------+---------------+---------+\n4 rows in set (0.06 sec)\n```\nWhich change should optimize the number of buffer pool instances for this workload?",
        "selections": {
            "A": "Decrease the number of buffer pool instances to 4.",
            "B": "Increase the number of buffer pool instances to 16.",
            "C": "Increase the number of buffer pool instances to 32.",
            "D": "Decrease the number of buffer pool instances to 1.",
            "E": "Increase the number of buffer pool instances to 12."
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nInnoDB缓冲池实例数（`innodb_buffer_pool_instances`）的优化目标是减少内部锁争用，提高并发性能。一个常见的经验法则是将其设置为接近或等于系统中并发执行查询的CPU核心数或活跃线程数。\n当前配置：\n- `innodb_buffer_pool_instances = 8`\n- `threads_running = 16` (正在运行的线程数，可以作为活跃并发的一个指标)\n\nB) 将缓冲池实例数增加到16。由于当前有16个正在运行的线程，将缓冲池实例数增加到16（或接近这个值）可以为每个（或每组）活跃线程提供更独立的缓冲池段，从而减少访问缓冲池内部数据结构时的锁争用，有助于提高并发性能 (B 正确)。\n\n其他选项分析：\nA) 减少到4：如果活跃线程是16，减少实例数可能会增加争用。\nC) 增加到32：可能超过了实际并发需求，过多的实例数可能会带来轻微的管理开销，且不一定能带来额外性能提升（除非`threads_running`经常远高于16）。\nD) 减少到1：会回到单个缓冲池的状态，在高并发下争用会很严重。\nE) 增加到12：比当前8有改进，但16可能更接近`threads_running`的值。\n\n**考点总结:**\n此题考察InnoDB缓冲池实例数的调优原则。通常建议将其设置为与系统CPU核心数或预期的并发活跃线程数相近的值，以平衡并发性能和管理开销。每个实例的大小必须至少为1GB（如果缓冲池总大小大于1GB）。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n关注与并发相关的指标（如`threads_running`, CPU核心数）来指导`innodb_buffer_pool_instances`的设置。理解增加实例数的目的是减少内部锁竞争。\n\n**学习建议:**\n学习InnoDB缓冲池的架构和调优。掌握`innodb_buffer_pool_size`, `innodb_buffer_pool_instances`, `innodb_buffer_pool_chunk_size`等参数的作用和配置方法。了解如何根据服务器硬件、工作负载特性和性能监控数据来优化缓冲池配置。注意缓冲池实例数和总大小之间的关系（总大小必须是实例数和chunk大小的倍数）。"
    },
    {
        "question": "### 试题 173:\n\nChoose the best answer. You encountered an insufficient privilege error in the middle of a long transaction. The database administrator is informed and immediately grants the required privilege: `GRANT UPDATE ON world.city TO 'user1';`\nHow can you proceed with your transaction with the least interruption?",
        "selections": {
            "A": "Close the connection, reconnect, and start the transaction again.",
            "B": "Re-execute the failed statement in your transaction.",
            "C": "Roll back the transaction and start the transaction again in the same session.",
            "D": "Change the default database and re-execute the failed statement in your transaction."
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n当在一个事务中执行某个语句因权限不足而失败后，如果DBA立即授予了所需权限，那么对于当前会话，新授予的表级或列级权限通常会在该会话执行下一个语句时生效。\nB) 在你的事务中重新执行失败的语句。由于权限已被授予，并且表级/列级权限通常在下个语句执行时对当前会话生效，重新执行该语句很可能会成功，并且事务可以继续进行，这是中断最小的方式 (B 正确)。\n\n错误选项分析：\nA) 关闭连接并重新连接会导致当前事务丢失，需要从头开始事务，中断较大。\nC) 回滚事务并重新开始事务，虽然在同一会话，但也意味着之前在事务中所做的操作都丢失了，中断较大。\nD) 更改默认数据库与权限问题无关，并且重新执行语句仍是在原事务上下文中。\n\n**考点总结:**\n此题考察MySQL权限生效的机制。当通过`GRANT`语句授予表级或列级权限后，这些新权限对于已存在的、执行该`GRANT`语句的会话以及其他已连接的会话，通常会在它们执行下一个需要这些权限的SQL语句时生效。不需要重新连接或重新启动事务（除非是全局权限或某些特殊权限的更改可能需要）。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解MySQL权限缓存和生效机制。通常，对表级、列级权限的`GRANT`操作对现有会话是“即时”（下一个语句）生效的。\n\n**学习建议:**\n学习MySQL的权限系统，包括权限的授予（`GRANT`）、撤销（`REVOKE`）以及权限的生效范围和时机。了解`FLUSH PRIVILEGES`命令的作用（主要用于当直接修改授权表而非使用`GRANT`/`REVOKE`时，或者某些全局权限更改后）。熟悉不同类型的权限（全局、数据库、表、列、存储过程等）及其管理。"
    },
    {
        "question": "### 试题 174:\n\nChoose the best answer. There has been an accidental deletion of data in one of your MySQL databases. You determine that all entries in the binary log file after position 1797 must be replayed. Examine this partial command: `mysqlbinlog binlog.000008 --start-position=1798`\nWhich operation will complete the command?",
        "selections": {
            "A": "--write-to-remote-server must be added to the command line to update the database tables.",
            "B": "No changes required. It automatically updates the MySQL Server with the data.",
            "C": "It can be piped into the MySQL Server via the command-line client.",
            "D": "You must use --stop-position=1797 to avoid the DELETE statement that caused the initial problem."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlbinlog binlog.000008 --start-position=1798` 这个命令会将`binlog.000008`文件中从位置1798开始的事件转换为SQL语句并输出到标准输出。要将这些SQL语句应用到MySQL服务器以恢复数据，需要将`mysqlbinlog`的输出通过管道传递给`mysql`命令行客户端。\nC) 它可以被通过管道传递给MySQL服务器的命令行客户端（即`mysql`命令）。完整的命令通常是：`mysqlbinlog binlog.000008 --start-position=1798 | mysql -u user -p -h host database_name` (C 正确)。\n\n错误选项分析：\nA) `--write-to-remote-server`是`mysqlbinlog`的一个选项，用于让`mysqlbinlog`直接连接到一个远程MySQL服务器并应用事件（类似于从库的SQL线程行为），但这需要额外的连接参数，并且题目中的命令片段并未包含这些。更常见和通用的方法是管道给`mysql`客户端。\nB) `mysqlbinlog`本身只转换和输出日志内容，它不自动更新MySQL服务器。\nD) 题目说的是“在位置1797之后的所有条目都必须重放”。`--start-position=1798`已经正确地从这个点开始。如果删除操作在1797之前，那么这个起始点是合适的。如果删除操作在1798或之后，并且我们想跳过它，那么需要更复杂的过滤（例如，找到该DELETE语句的GTID或精确位置，并使用`--exclude-gtids`或更细致的位置过滤，或者手动编辑`mysqlbinlog`的输出）。简单使用`--stop-position=1797`会使命令不输出任何内容，因为起始点（1798）已经晚于停止点（1797）。\n\n**考点总结:**\n此题考察使用`mysqlbinlog`进行时间点恢复或事件重放的标准方法。核心在于将`mysqlbinlog`的SQL输出通过管道传递给`mysql`客户端来执行。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住`mysqlbinlog`和`mysql`客户端在数据恢复中的典型组合用法（通过管道）。理解`mysqlbinlog`本身是“解码器”，`mysql`客户端是“执行器”。\n\n**学习建议:**\n学习`mysqlbinlog`工具的各种选项，特别是用于过滤事件（按时间、位置、GTID、数据库、表等）和控制输出格式的选项。掌握如何将其输出导入到MySQL服务器以进行数据恢复或分析。练习不同场景下的时间点恢复操作。"
    },
    {
        "question": "### 试题 175:\n\nChoose the best answer. The `mysqld` instance has the connection control plugin enabled with these settings:\n```\nconnection_control_min_connection_delay=1000\nconnection_control_max_connection_delay=2000\n```\nThe minimum and maximum delays need to be increased to 3000 and 5000, respectively.\nA command is executed: `mysql> SET GLOBAL connection_control_min_connection_delay=3000;`\nWhat is the result?",
        "selections": {
            "A": "Only the minimum connection value is increased to 3000.",
            "B": "The minimum connection value is changed to 2000.",
            "C": "The minimum value increases to 3000 and the maximum value increases to 4000.",
            "D": "An error is returned."
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n连接控制插件的参数`connection_control_min_connection_delay`和`connection_control_max_connection_delay`之间存在约束关系：最小延迟不能大于最大延迟。\n当前设置：\n- `min_delay = 1000` (ms)\n- `max_delay = 2000` (ms)\n\n尝试执行的命令：`SET GLOBAL connection_control_min_connection_delay=3000;`\n这个命令试图将最小延迟设置为3000ms。但是，此时最大延迟仍然是2000ms。由于3000 > 2000，这个设置违反了“最小延迟 <= 最大延迟”的约束。\nD) 返回一个错误。MySQL会阻止这个无效的设置，并返回一个错误，提示变量无法设置为该值 (D 正确)。\n\n错误选项分析：\nA), B), C) 都假设命令会成功执行并改变值，但由于约束冲突，命令会失败。\n\n**考点总结:**\n此题考察MySQL连接控制插件相关参数的设置约束。`connection_control_min_connection_delay`的值不能超过`connection_control_max_connection_delay`的值。在调整这些参数时，可能需要按特定顺序进行，或者同时设置以满足约束。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n注意系统变量之间可能存在的依赖关系或约束。当修改一个变量时，要考虑它是否会影响或被其他相关变量所限制。\n\n**学习建议:**\n学习MySQL连接控制插件的配置和使用。了解`connection_control_min_connection_delay`, `connection_control_max_connection_delay`, `connection_control_failed_connections_threshold`等参数的作用和它们之间的关系。掌握如何通过这些参数来缓解暴力破解密码等攻击。"
    },
    {
        "question": "### 试题 176:\n\nHow can `mysqld_multi` be configured to allow MySQL instances to use the same port number?",
        "selections": {
            "A": "The instances have appropriate net masks set.",
            "B": "The instances use different user accounts unique to each instance.",
            "C": "The instances use different socket names.",
            "D": "The instances listen on different IP addresses."
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题150内容几乎完全相同，只是工具名明确为`mysqld_multi`（一个用于管理多个mysqld进程的脚本）。\n如果多个MySQL实例要在同一台主机上使用相同的TCP端口号，它们必须绑定到该主机上不同的IP地址。\nD) 实例监听在不同的IP地址上。如果主机配置了多个IP地址，每个`mysqld`实例可以通过`bind-address`参数配置为监听其中一个唯一的IP地址，同时使用相同的端口号 (D 正确)。\n\n错误选项分析同试题150。\n\n**考点总结:**\n再次强调在单个主机上运行多个MySQL实例时，如果需要共享端口，则必须通过绑定到不同IP地址来实现。`mysqld_multi`脚本可以帮助管理这种多实例配置。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，加强记忆。TCP/IP网络中，`IP:Port`对必须唯一。\n\n**学习建议:**\n参考试题150的学习建议。如果还在使用`mysqld_multi`（在现代systemd环境中可能不那么常见），了解其配置文件格式和如何为每个实例组（`[mysqldN]`）指定不同的`bind-address`和`port`。"
    },
    {
        "question": "### 试题 177:\n\nChoose the best answer. MySQL is installed on a Linux server with this configuration: `mysqld user=mysql datadir=/data/mysql`\nWhich method sets the default authentication to SHA-256 hashing for authenticating user account passwords?",
        "selections": {
            "A": "Define CREATE USER ''@'%' IDENTIFIED WITH sha256_password in the MySQL instance.",
            "B": "Add default_authentication_plugin=sha256_password in the configuration file.",
            "C": "Add default_authentication_plugin=mysql_native_password in the configuration file.",
            "D": "Set validate-user-plugins=caching_sha2_password in the configuration file."
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n要将MySQL服务器的默认认证插件设置为使用SHA-256哈希（即`sha256_password`插件），需要在MySQL的配置文件（如`my.cnf`或`my.ini`）中进行设置。\nB) 在配置文件（通常是`[mysqld]`节下）中添加`default_authentication_plugin=sha256_password`。这将使得新创建的用户（如果在`CREATE USER`语句中未显式指定认证插件）默认使用`sha256_password`插件进行认证 (B 正确)。\n\n错误选项分析：\nA) `CREATE USER ''@'%' IDENTIFIED WITH sha256_password ...`：这是创建一个特定用户并指定其使用`sha256_password`插件，而不是设置服务器的“默认”认证插件。\nC) 将默认认证插件设置为`mysql_native_password`与题目要求（SHA-256）相反。\nD) `validate-user-plugins`（更准确的可能是`validate_password`组件或插件的相关配置）用于密码复杂度校验，与默认认证插件的类型无关。`caching_sha2_password`是MySQL 8.0的默认认证插件，但题目要求的是SHA-256（即`sha256_password`）。\n\n**考点总结:**\n此题考察如何更改MySQL服务器的默认认证插件。通过在配置文件中设置`default_authentication_plugin`系统变量可以实现。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分“设置默认行为”和“为特定对象设置行为”。“默认认证插件”是一个服务器级别的配置。\n\n**学习建议:**\n学习MySQL的认证插件机制。了解不同认证插件（如`mysql_native_password`, `sha256_password`, `caching_sha2_password`）的特点、安全性以及如何配置它们。掌握`default_authentication_plugin`系统变量的作用和设置方法。了解如何在`CREATE USER`和`ALTER USER`语句中为特定用户指定认证插件。"
    },
    {
        "question": "### 试题 178:\n\nExamine these two reports taken 100 seconds apart:\n**GLOBAL STATUS 1:**\n```\nCom_create_table=500005\nCom_drop_table=500003\nCom_flush=23\nCreate_tmp_disk_tables=400000\nCreate_tmp_tables=1200000\nMax_used_connections=92\nOpen_files=5000\nOpened_files=5000\nOpen_table_definitions=3000\nOpen_tables=1024\nOpened_table_definitions=2369\nOpened_tables=3500000\nThreads_connected=62\nThreads_running=58\nUptime=100000\n```\n**GLOBAL STATUS 2 (100 seconds later):**\n```\nCom_create_table=500505\nCom_drop_table=500498\nCom_flush=31\nCreate_tmp_disk_tables=400400\nCreate_tmp_tables=1201200\nMax_used_connections=92\nOpen_files=5000\nOpened_files=7505\nOpen_table_definitions=3000\nOpen_tables=1024\nOpened_table_definitions=2873\nOpened_tables=3503500\nThreads_connected=67\nThreads_running=64\nUptime=100100\n```\nYour MySQL system normally supports 50-75 concurrent connections.\nWhich configuration change will improve performance?",
        "selections": {
            "A": "increase max_connections",
            "B": "decrease open_files_limit",
            "C": "decrease table_definition_cache",
            "D": "increase table_open_cache"
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n比较两次状态报告的变化，寻找性能瓶颈的线索：\n- `Opened_files` 从 5000 增加到 7505 (增加了 2505)。`Open_files`（当前打开文件数）保持在5000。\n- `Opened_table_definitions` 从 2369 增加到 2873 (增加了 504)。`Open_table_definitions`（当前打开表定义数）保持在3000。\n- `Opened_tables` 从 3,500,000 增加到 3,503,500 (增加了 3500)。`Open_tables`（当前打开表数）保持在1024。\n\n高频率地“打开”文件、表定义和表（`Opened_*`计数器快速增长）通常表明相关的缓存可能不足，导致MySQL频繁地关闭和重新打开这些资源。\n- `Opened_tables` 的增长（100秒内3500次）相对于当前`Open_tables`（1024）和`table_open_cache`（未直接给出，但`Open_tables`受其限制）可能表明`table_open_cache`设置偏小，导致表被频繁关闭再打开。\n- `Opened_table_definitions` 的增长可能表明`table_definition_cache`偏小。\n\nD) 增加`table_open_cache`（表打开缓存）。如果`Opened_tables`增长很快，而`Open_tables`接近`table_open_cache`的上限，增加`table_open_cache`可以让更多表保持打开状态，减少文件打开和关闭的开销，从而提高性能 (D 正确)。\n\n错误选项分析：\nA) `Max_used_connections`（92）高于系统通常支持的并发连接数（50-75），且`Threads_connected`（62, 67）也在这个范围内。当前`max_connections`的值未给出，但如果它远大于92，则增加它意义不大。如果接近92，则可能需要增加，但这与`Opened_*`计数器的直接关系不大。\nB) `open_files_limit`是操作系统层面或MySQL配置（通过`open_files_limit`变量）允许进程打开的最大文件描述符数量。`Open_files`（5000）是当前已打开的。减少这个限制会加剧问题，而不是改善。\nC) `Opened_table_definitions`在增长，表明表定义缓存可能不足。减少`table_definition_cache`会使情况更糟。\n\n**考点总结:**\n此题考察如何根据MySQL的状态变量（特别是`Opened_*`系列计数器）来诊断性能瓶颈，并选择合适的配置参数进行调优。高`Opened_tables`和`Opened_table_definitions`通常指示`table_open_cache`和`table_definition_cache`可能需要调大。\n\n",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n关注`Opened_*`计数器的增长率。如果它们增长很快，而对应的`Open_*`计数器（当前打开数）接近或等于其缓存上限，则表明相关缓存可能不足。注意区分“当前打开数”和“历史打开总次数”。\n\n**学习建议:**\n学习MySQL的表缓存机制，包括`table_open_cache`（缓存打开的表文件描述符和状态）和`table_definition_cache`（缓存表定义）。了解它们如何影响表访问性能。掌握相关的状态变量（`Open_tables`, `Opened_tables`, `Open_table_definitions`, `Opened_table_definitions`）和配置参数。学习如何根据工作负载调优这些缓存的大小。"
    },
    {
        "question": "### 试题 179:\n\nChoose the best answer. A colleague complains about slow response time on your website. Examine this query and output:\n```sql\nmysql> SHOW GLOBAL STATUS LIKE 'Table_lock%';\n+-----------------------+---------+\n| Variable_name         | Value   |\n+-----------------------+---------+\n| Table_locks_immediate | 53148   |\n| Table_locks_waited    | 17716   |\n+-----------------------+---------+\n2 rows in set (0.00 sec)\n```\nWhat is the most likely cause for the high number of lock waits?",
        "selections": {
            "A": "You use the InnoDB storage engine and statements wait while data is inserted.",
            "B": "The InnoDB Buffer pool is full.",
            "C": "You use the MyISAM storage engine for most common tables.",
            "D": "Your table accesses wait for the operating system level flush."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n状态变量含义：\n- `Table_locks_immediate`: 立即获得表锁的次数。\n- `Table_locks_waited`: 因无法立即获得表锁而需要等待的次数。\n\n输出显示`Table_locks_waited`的值（17716）相对较高（与`Table_locks_immediate`的53148相比，等待比例约 17716 / (53148 + 17716) ≈ 25%）。这表明存在显著的表级锁争用。\nC) 你为大多数常用表使用了MyISAM存储引擎。MyISAM存储引擎主要使用表级锁。在高并发的读写场景下，表级锁很容易成为瓶颈，导致大量等待（`Table_locks_waited`增加） (C 正确)。\n\n错误选项分析：\nA) InnoDB存储引擎主要使用行级锁，在高并发下通常比表级锁具有更好的性能，能减少锁争用。如果大量使用InnoDB，`Table_locks_waited`通常不会这么高（除非是显式加表锁，或者元数据锁等）。\nB) InnoDB缓冲池已满主要影响I/O性能，不直接导致表级锁等待增加。虽然缓冲池不足可能间接导致查询变慢，从而延长事务持有锁的时间，但根本原因不是缓冲池本身。\nD) 等待操作系统级别的flush操作（如磁盘同步）与MySQL内部的表锁机制是两回事。\n\n**考点总结:**\n此题考察如何根据`Table_locks_waited`状态变量诊断表级锁争用问题。高`Table_locks_waited`值通常指示大量使用了表级锁的存储引擎（如MyISAM），或者存在频繁的需要表锁的操作（如某些DDL、显式`LOCK TABLES`）。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n将`Table_locks_waited`与存储引擎的锁机制联系起来。MyISAM = 表锁，InnoDB = 行锁（主要）。高表锁等待通常指向MyISAM。\n\n**学习建议:**\n学习MySQL不同存储引擎的锁机制（表锁、行锁、意向锁、元数据锁）。掌握相关的状态变量（如`Table_locks_immediate`, `Table_locks_waited`, `Innodb_row_lock_current_waits`, `Innodb_row_lock_time_avg`, `Innodb_row_lock_waits`等）和性能计数器。了解如何诊断和解决锁争用问题，例如通过优化查询、选择合适的存储引擎、调整事务隔离级别或改进应用并发逻辑。"
    },
    {
        "question": "### 试题 180:\n\nChoose the best answer. What is the reason for SSL not being used?\n\n```\nConnection:           Localhost via UNIX socket\nSSL:                  Not in use\n```\n",
        "selections": {
            "A": "It is connected via a UNIX socket.",
            "B": "The root user cannot use encryption.",
            "C": "A current database is not selected. There is nothing to encrypt.",
            "D": "The root user must use ssl_fips_mode = ON."
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlsh \\status` (或 `mysql> status;`) 命令的输出中明确显示：\n- `Connection: Localhost via UNIX socket`：客户端是通过Unix域套接字连接到本地MySQL服务器的。\n- `SSL: Not in use`：当前连接没有使用SSL加密。\n\nA) 它是通过UNIX套接字连接的。对于本地的Unix域套接字连接，MySQL默认通常不使用SSL加密，因为这种连接本身被认为是相对安全的（在同一台机器内部）。虽然理论上可以为Unix套接字连接配置SSL，但这不常见且需要特定配置。因此，使用Unix套接字连接是SSL未被使用的最直接原因 (A 正确)。\n\n错误选项分析：\nB) root用户可以使用加密连接，用户身份与是否使用SSL无关。\nC) 是否选择数据库与SSL连接的建立无关。SSL是在连接握手阶段协商的，用于保护整个通信通道，而不是特定数据库的内容。\nD) `ssl_fips_mode`是服务器端的一个变量，用于控制是否启用FIPS模式以符合特定安全标准。它与客户端是否使用SSL连接以及root用户是否必须使用FIPS模式没有直接因果关系。\n\n**考点总结:**\n此题考察影响MySQL客户端连接是否使用SSL的因素。对于本地Unix套接字连接，默认不启用SSL。TCP/IP连接则可以通过客户端和服务器端的配置来启用SSL。\n\n**OCR答案提示“SSL is not supported on socket, named pipe, and shared memory connections”是关键。虽然技术上可能存在为本地IPC配置某种加密的方法，但在MySQL的常规SSL/TLS连接语境下，它们通常不使用标准的SSL握手。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n关注`status`命令输出中的`Connection`类型和`SSL`状态。理解不同连接类型（TCP/IP vs 本地IPC如Unix套接字）对SSL使用的默认行为。\n\n**学习建议:**\n学习MySQL的SSL/TLS加密连接配置。了解如何在服务器端启用SSL（配置证书、密钥、`ssl_ca`, `ssl_cert`, `ssl_key`等变量）。学习如何在客户端请求SSL连接（如使用`--ssl-mode`, `--ssl-ca`等选项）。熟悉不同连接协议（TCP/IP, Unix socket, named pipe, shared memory）以及它们与SSL的关系。"
    },
    {
        "question": "### 试题 181:\n\nChoose the best answer. You have configured a working MySQL InnoDB Cluster in single-primary mode. What happens when the primary instance goes down due to a network problem?",
        "selections": {
            "A": "The cluster will continue to function with read-only members.",
            "B": "A new primary is automatically elected.",
            "C": "The cluster goes into wait mode until a new member is manually promoted as primary.",
            "D": "The cluster detects network partitioning and shuts down to remain consistent.",
            "E": "All remaining members in the cluster are automatically set to read-write mode."
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n在单主模式的InnoDB集群中，当主实例因网络问题（或其他原因）变得不可达或发生故障时，集群会自动执行故障转移（failover）过程。\nB) 一个新的主实例会被自动选举出来。集群中的其余健康成员会通过组复制的共识机制（基于Paxos或其变种）从它们中间选举出一个新的主实例来接管读写操作，以保证集群的持续可用性 (B 正确)。\n\n错误选项分析：\nA) 如果主实例宕机，集群的目标是尽快恢复写能力，而不是仅仅以只读模式运行（除非所有剩余成员都无法形成法定数量，或者被配置为在特定情况下进入只读）。\nC) 自动故障转移是InnoDB集群的关键特性，通常不需要手动提升新的主实例（除非自动选举失败或管理员想干预）。\nD) 集群会检测到成员故障或网络分区。如果剩余成员能够形成法定数量（quorum），它们会尝试选举新主并继续运行。只有在无法形成法定数量以保证数据一致性的情况下，集群的写操作才会受阻，或者在极端情况下整个集群（或部分分区）可能变得不可用，但“关闭以保持一致”不是其首要行为，而是选举新主。\nE) 在单主模式下，只有一个实例是读写（R/W）模式。如果主实例宕机，会选举一个新的主实例成为R/W，其他健康的备实例仍然是只读（R/O）模式。不会所有剩余成员都自动变成读写模式。\n\n**考点总结:**\n此题考察InnoDB集群（单主模式）在主实例故障时的自动故障转移机制。核心是自动选举新的主实例以恢复写服务。\n\n**OCR答案提示“If the existing primary leaves the group, whether voluntarily or unexpectedly, a new primary is elected automatically.”是正确的。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解InnoDB集群（特别是单主模式）的核心高可用特性——自动故障转移和主节点选举。\n\n**学习建议:**\n学习MySQL InnoDB Cluster的架构和工作原理，特别是其底层的组复制技术和自动故障转移机制。了解主节点选举的过程（例如，基于成员权重、GTID状态等）。熟悉如何监控集群状态和处理成员故障。进行故障转移演练以验证集群的恢复能力。"
    },
    {
        "question": "### 试题 182:\n\nChoose the best answer. You have configured MySQL Enterprise Transparent Data Encryption (TDE). What command would you use to encrypt a table?",
        "selections": {
            "A": "UPDATE <table> SET ENCRYPTION= 'Y';",
            "B": "ALTER INSTANCE ROTATE INNODB MASTER KEY;",
            "C": "UPDATE information_schema.tables SET encryption='Y' WHERE table_name='table';",
            "D": "ALTER TABLE <table> ENCRYPTION = 'Y';"
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题143内容几乎完全相同，只是表名用了占位符。\n为现有InnoDB表启用透明数据加密（TDE）使用`ALTER TABLE`语句。\nD) `ALTER TABLE <table> ENCRYPTION = 'Y';`：这是启用表加密的标准SQL语法。将`<table>`替换为实际表名 (D 正确)。\n\n错误选项分析：\nA) `UPDATE ... SET ENCRYPTION='Y'`不是有效的SQL语法。\nB) `ALTER INSTANCE ROTATE INNODB MASTER KEY;`用于轮转InnoDB的主加密密钥，与启用单个表的加密是不同的操作。\nC) 不能直接更新`information_schema.tables`表来修改表的加密状态。`information_schema`是只读的元数据视图。\n\n**考点总结:**\n再次强调为InnoDB表启用TDE的正确SQL命令是`ALTER TABLE ... ENCRYPTION = 'Y';`。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，加强记忆。记住DDL命令（如`ALTER TABLE`）通常用于修改表结构或属性。\n\n**学习建议:**\n参考试题143的学习建议。重点是掌握TDE相关的DDL操作。"
    },
    {
        "question": "### 试题 183:\n\nChoose the best answer. A developer accidentally dropped the InnoDB table `Customers` from the `Company` database. There is a datadir copy from two days ago in the `dbbackup` directory.\nWhich set of steps would restore only the missing table?",
        "selections": {
            "A": "Stop the MySQL Server process and restart it with the command: `mysqld --basedir=/usr/local/mysql --datadir=/dbbackup` Run `mysqldump` on this table and restore the dump file.",
            "B": "Stop the MySQL Server process and restart it with the command: `mysqld --basedir=/usr/local/mysql --datadir=/var/lib/mysql` Run `mysqldump` on this table and restore the dump file.",
            "C": "Stop the MySQL Server process, copy the `Customers.ibd` file from the `dbbackup` directory, and start the `mysqld` process.",
            "D": "Stop the MySQL Server process, and execute: `mysqlbackup --datadir=/var/lib/mysql --backup-dir=/dbbackup --include-tables='Company.Customers' copy-back` Start the `mysqld` process."
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n场景：需要从一个两天前的“数据目录副本”（datadir copy）中只恢复被误删除的`Customers`表（InnoDB表）。这意味着我们有一个物理备份。\n`mysqlbackup` (MySQL Enterprise Backup) 支持从物理备份中恢复单个表（如果备份是以支持表级恢复的方式创建的，例如使用了`--include-tables`或备份了独立表空间）。\nD) `Stop the MySQL Server process, and execute: mysqlbackup --datadir=/var/lib/mysql --backup-dir=/dbbackup --include-tables='Company\\.Customers' copy-back Start the mysqld process.`：\n   - 停止MySQL服务。\n   - 使用`mysqlbackup`的`copy-back`操作，并配合`--include-tables`选项指定只恢复`Company.Customers`表。`--backup-dir=/dbbackup`指定备份源（即两天前的数据目录副本），`--datadir=/var/lib/mysql`指定当前运行实例的数据目录（恢复目标）。\n   - 启动MySQL服务。\n   这个流程是使用`mysqlbackup`从物理备份中进行选择性表恢复的正确方法 (D 正确)。\n\n错误选项分析：\nA) 用旧的整个数据目录副本（`/dbbackup`）启动一个新的MySQL实例，然后从这个实例中`mysqldump`出`Customers`表，再导入到原始实例。这理论上可行，但步骤繁琐，且题目问的是“恢复丢失的表”，D选项直接在原实例上操作更符合题意。\nB) 同样是启动一个实例然后dump再导入，且这里用的`datadir`是当前运行实例的，无法用于从备份恢复。\nC) 仅仅从旧的数据目录副本中复制`Customers.ibd`文件到当前数据目录，然后启动MySQL，通常是行不通的。对于InnoDB表，还需要考虑数据字典的一致性、表空间ID的匹配、undo日志和redo日志的状态等。简单的文件复制可能导致表损坏或无法识别。需要使用正确的恢复工具（如`mysqlbackup`或涉及传输表空间的步骤）。\n\n**考点总结:**\n此题考察如何从物理备份（数据目录副本）中恢复单个InnoDB表。使用MySQL Enterprise Backup (`mysqlbackup`) 的`copy-back`操作并配合`--include-tables`进行选择性恢复是推荐的方法。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解物理备份恢复的复杂性，特别是对于InnoDB表，简单的文件复制通常不够。选择使用专用备份恢复工具（如`mysqlbackup`）并利用其选择性恢复功能的选项。\n\n**学习建议:**\n学习MySQL Enterprise Backup (`mysqlbackup`) 的表级恢复功能。了解其前提条件（例如，备份时是否包含必要的元数据和日志）和操作步骤。熟悉物理备份与逻辑备份在恢复灵活性方面的差异。了解InnoDB可传输表空间功能，它也提供了另一种表级迁移和恢复的方法（但步骤更复杂）。"
    },
    {
        "question": "### 试题 184:\n\nChoose the best answer. Examine this partial report:\n```sql\nmysql> SHOW FULL PROCESSLIST; (下略，显示了多个连接)\n```\nExamine this query:\n```sql\nSELECT SUM(m.CURRENT_NUMBER_OF_BYTES_USED) AS TOTAL\nFROM performance_schema.memory_summary_by_thread_by_event_name m\nINNER JOIN performance_schema.threads t ON m.THREAD_ID = t.THREAD_ID\nWHERE t.PROCESSLIST_ID = 10;\n```\nWhat information does this query provide?",
        "selections": {
            "A": "total memory used by connection 10",
            "B": "total memory used across all connections associated with the user on connection number 10",
            "C": "total memory used by the first 10 threads",
            "D": "total memory used by thread number 10",
            "E": "total memory used by the first 10 connections",
            "F": "total memory used across all connections associated with the user on thread number 10"
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n查询分析：\n- `FROM performance_schema.memory_summary_by_thread_by_event_name m`: 从按线程和事件名称汇总的内存使用摘要表中获取数据。\n- `INNER JOIN performance_schema.threads t ON m.THREAD_ID = t.THREAD_ID`: 将内存摘要与线程信息关联起来。\n- `WHERE t.PROCESSLIST_ID = 10`: 筛选出连接ID（`PROCESSLIST_ID`）为10的那个线程。\n- `SELECT SUM(m.CURRENT_NUMBER_OF_BYTES_USED) AS TOTAL`: 计算该线程当前使用的总内存字节数。\n\nA) 连接ID为10的连接所使用的总内存。`PROCESSLIST_ID`对应于`SHOW PROCESSLIST`中显示的连接ID。因此，这个查询计算的是特定连接ID（这里是10）的内存使用总和 (A 正确)。\n\n错误选项分析：\nB) 查询是按连接ID（`PROCESSLIST_ID = 10`）筛选的，不是按用户筛选，也不是“所有与用户相关的连接”。\nC), E) 查询是按`PROCESSLIST_ID = 10`筛选的单个连接/线程，不是前10个线程/连接。\nD) `THREAD_ID`是Performance Schema内部的线程标识符，而`PROCESSLIST_ID`是`SHOW PROCESSLIST`中用户可见的连接ID。查询条件是`t.PROCESSLIST_ID = 10`，所以是连接ID 10，而不是内部线程ID 10。\nF) 同B，查询是按连接ID，不是按用户。\n\n**考点总结:**\n此题考察如何使用Performance Schema中的表（`memory_summary_by_thread_by_event_name`和`threads`）来查询特定连接的内存使用情况。关键在于理解`PROCESSLIST_ID`与用户连接的对应关系，以及`THREAD_ID`是内部标识。\n\n**OCR答案提示“分析：这里 10 是 connection id, 也是 show process 显示的 id，不是 thread id”是正确的。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细阅读SQL查询的`FROM`, `JOIN`, `WHERE`子句，理解数据是如何被筛选和关联的。区分`PROCESSLIST_ID`（连接ID）和`THREAD_ID`（内部线程ID）。\n\n**学习建议:**\n学习使用MySQL Performance Schema来监控内存使用情况。熟悉与内存分配相关的表，如`memory_summary_global_by_event_name`, `memory_summary_by_thread_by_event_name`, `memory_summary_by_user_by_event_name`, `memory_summary_by_host_by_event_name`以及更底层的`events_waits_summary_by_thread_by_event_name`（如果内存分配被视为等待事件）。了解如何通过查询这些表来诊断内存泄漏或高内存消耗问题。"
    },
    {
        "question": "### 试题 185:\n\nYou plan to take daily full backups, which include the `ndbinfo` and `sys` (internal) databases.\nWhich command will back up the databases in parallel?",
        "selections": {
            "A": "mysqldump --single-transaction > full-backup-$(date +%Y%m%d).sql",
            "B": "mysqlpump --include-databases=% > full-backup-$(date +%Y%m%d).sql",
            "C": "mysqlpump --all-databases > full-backup-$(date +%Y%m%d).sql",
            "D": "mysqldump --all-databases > full-backup-$(date +%Y%m%d).sql"
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题160内容几乎完全相同。\n要求备份所有数据库（包括`ndbinfo`和`sys`）并支持并行备份。\nB) `mysqlpump --include-databases=% > full-backup-$(date +%Y%m%d).sql`：`mysqlpump`支持并行，`--include-databases=%`会包含所有数据库，包括系统库 (B 正确)。\n\n错误选项分析同试题160。\n\n**考点总结:**\n再次强调使用`mysqlpump`进行并行逻辑备份以及如何通过`--include-databases=%`包含所有数据库（包括默认排除的系统库）。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，加强记忆。`mysqlpump`是并行逻辑备份的选择，`%`是包含所有库的通配符。\n\n**学习建议:**\n参考试题160的学习建议。对常用工具的特性和选项要有清晰的认识。"
    },
    {
        "question": "### 试题 186:\n\nExamine this command, which executes successfully:\n`mysqlbackup --user=dba --password --port=3306 --with-timestamp --backup-dir=/export/backups backup-and-apply-log`\nWhich statement is true?",
        "selections": {
            "A": "The backup accesses the MySQL server files by using a pre-existing connection.",
            "B": "The database server is put into a read-only state for the duration of the backup.",
            "C": "An offline backup of InnoDB tables is taken.",
            "D": "The backup can be impacted when DDL operations run during the backup."
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlbackup` (MySQL Enterprise Backup) 执行`backup-and-apply-log`操作。这是一个热物理备份过程。\nD) 备份过程可能受到在备份期间运行的DDL操作的影响。虽然`mysqlbackup`会尝试处理并发的DDL，但某些DDL操作（特别是那些涉及表结构重大更改或文件移动的）如果在备份的关键阶段执行，可能会导致备份失败或备份数据不一致。通常建议在物理备份期间避免执行大型或关键的DDL操作 (D 正确)。\n\n错误选项分析：\nA) `mysqlbackup`会建立自己的连接到MySQL服务器以执行必要的操作（如获取元数据、执行`FLUSH`命令、读取redo日志等），它不依赖于一个“预先存在的”连接。它使用提供的`--user`, `--password`, `--port`等参数来建立连接。\nB) `mysqlbackup`执行的是热备份，目标是最小化对数据库服务的阻塞。它不会将整个数据库服务器置于只读状态。对于InnoDB表，它使用InnoDB的内部机制来获取一致的数据快照，同时允许读写操作继续。可能会有短暂的锁定（例如，在备份非InnoDB表或复制redo日志的特定阶段），但不是整个备份期间的只读。\nC) `mysqlbackup`执行的是在线（热）备份，而不是离线备份。离线备份需要停止MySQL服务器。\n\n**考点总结:**\n此题考察对MySQL Enterprise Backup (`mysqlbackup`) 热备份过程的理解，特别是其与并发DDL操作的潜在交互。虽然热备份旨在最小化影响，但并发DDL仍可能带来风险。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解热备份（在线备份）的核心特点——在服务器运行时进行，并尽量减少对应用的影响。思考哪些类型的并发操作可能与物理备份过程冲突。\n\n**学习建议:**\n学习MySQL Enterprise Backup (`mysqlbackup`) 的工作原理，特别是它如何实现对InnoDB表的热备份（例如，通过跟踪redo日志）。了解在执行物理备份期间应避免的操作（如大型DDL）。熟悉`backup-and-apply-log`这个一体化命令的作用（备份并立即准备备份使其可用于恢复）。"
    },
    {
        "question": "### 试题 187:\n\nChoose the best answer. Database `test` contains a table named `city` that has the InnoDB storage engine.\n```sql\nCREATE TABLE `city` (\n  `ID` int NOT NULL AUTO_INCREMENT,\n  `Name` char(35) NOT NULL DEFAULT '',\n  `CountryCode` char(3) NOT NULL DEFAULT '',\n  `District` char(20) NOT NULL DEFAULT '',\n  `Population` int NOT NULL DEFAULT '0',\n  PRIMARY KEY (`ID`),\n  KEY `CountryCode` (`CountryCode`)\n) ENGINE=InnoDB TABLESPACE=innodb_file_per_table;\n```\nWhat is the content of the `test` folder in the data directory?",
        "selections": {
            "A": "city.MYD, city.MYI, and city.sdi",
            "B": "city.ibd",
            "C": "city.ibd and city.frm",
            "D": "city.ibd and city.sdi",
            "E": "city.ibd, city.frm, and city.sdi"
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`CREATE TABLE`语句显示：\n- 表名为`city`，属于`test`数据库（假设当前数据库是`test`，或者表名是`test.city`）。\n- 存储引擎是`InnoDB`。\n- `TABLESPACE=innodb_file_per_table`（或者如果这是MySQL 5.6.6+且`innodb_file_per_table=ON`是默认值）：这表明`city`表会使用独立的表空间文件。\n\n在MySQL 8.0及以后版本，当`innodb_file_per_table=ON`时，每个InnoDB表的数据和索引存储在一个单独的`.ibd`文件中，该文件位于对应数据库的目录下（例如，`datadir/test/city.ibd`）。表的元数据（表定义）存储在数据字典中，对于InnoDB表，其序列化字典信息（SDI）也内嵌在`.ibd`文件的头部。\n`.frm`文件（用于存储表定义）在MySQL 8.0中已被废弃，不再为新创建的InnoDB表生成。\n\nB) `city.ibd`：这是正确的。`test`数据库目录下会有一个名为`city.ibd`的文件，包含了`city`表的数据、索引和SDI元数据 (B 正确)。\n\n错误选项分析：\nA) `.MYD`和`.MYI`是MyISAM表的数据和索引文件，与InnoDB无关。\nC), E) `.frm`文件在MySQL 8.0中不用于InnoDB表。\nD) 虽然`.ibd`文件包含SDI信息，但不会有一个单独的`city.sdi`文件与`city.ibd`并存（对于InnoDB表）。如果表是其他引擎（如MyISAM，在8.0中仍支持但需额外配置以生成SDI），则可能会有`.sdi`文件。\n\n**考点总结:**\n此题考察MySQL 8.0中InnoDB表（使用独立表空间时）在文件系统中的存储方式。核心是每个表对应一个`.ibd`文件，该文件包含数据、索引和SDI元数据，不再有`.frm`文件。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住MySQL 8.0对元数据管理的重大改变——引入数据字典并废弃`.frm`文件。了解不同存储引擎的文件结构（特别是InnoDB和MyISAM）。\n\n**学习建议:**\n学习InnoDB的存储结构，特别是独立表空间（`innodb_file_per_table`）和通用表空间。了解SDI（Serialized Dictionary Information）的概念及其在MySQL 8.0中的作用。熟悉MySQL数据目录的典型结构，以及不同类型的文件（数据文件、日志文件、配置文件、状态文件等）的存放位置。"
    },
    {
        "question": "### 试题 188:\n\nChoose the best answer. Examine this command, which executes successfully: `$ mysqlrouter --bootstrap user@hostname --port --directory=directory_path`\nWhich activity is performed?",
        "selections": {
            "A": "MySQL Router configures itself based on the information retrieved from the InnoDB cluster metadata server.",
            "B": "MySQL Router configures all the cluster nodes based on the information retrieved from the InnoDB cluster metadata server.",
            "C": "MySQL Router is restarted.",
            "D": "MySQL Router is configured based on the information in files in directory_path."
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlrouter --bootstrap ...`命令用于初始化和配置MySQL Router实例，使其能够连接到一个InnoDB集群（或其他支持的MySQL复制拓扑）并从中获取元数据。\nA) MySQL Router会连接到指定的InnoDB集群元数据服务器（通过`user@hostname --port`等参数指定），检索集群的拓扑信息、成员列表、读写端口、只读端口等，并根据这些信息自动生成或更新其自身的配置文件（通常是`mysqlrouter.conf`），以便能够正确地路由客户端连接到集群中的合适实例 (A 正确)。\n\n错误选项分析：\nB) MySQL Router是客户端连接的代理和路由器，它不配置集群节点本身。集群节点的配置由DBA或AdminAPI等工具管理。\nC) `--bootstrap`是初始化配置的过程，不是重启Router的操作。配置完成后，可能需要启动Router（如果之前未运行）。\nD) `directory_path`通常是Router用于存放其配置文件、日志文件等的目录。Router从集群元数据服务器获取信息来“生成”或“更新”其配置文件（存放在`directory_path`中），而不是“基于`directory_path`中的文件”来配置自己。信息源是集群，目标目录是`directory_path`。\n\n**考点总结:**\n此题考察MySQL Router的`--bootstrap`选项的核心功能。它是一个自动配置过程，使Router能够连接到InnoDB集群并获取必要的元数据以进行路由。\n\n**OCR答案提示中的链接指向了MySQL Router的文档，其中会详细说明bootstrap过程。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解“bootstrap”在软件配置中的含义——通常指自动化的初始设置或引导过程。将MySQL Router定位为一个连接代理和负载均衡器，其配置依赖于后端集群的元数据。\n\n**学习建议:**\n学习MySQL Router的安装、配置和使用。掌握`--bootstrap`选项如何与InnoDB集群（或其他复制拓扑）集成。了解MySQL Router的配置文件结构、不同的路由策略（如`read-write`, `read-only`, `round-robin`）以及如何监控Router的状态。熟悉其在高可用架构中的作用。"
    },
    {
        "question": "### 试题 189:\n\nChoose the best answer. You issue this command: `SHOW SLAVE STATUS`. In the output, there is a value for `seconds_behind_master`. How is this time calculated?",
        "selections": {
            "A": "It is the time between the I/O thread receiving details of the master's last transaction and the time it was applied by the SQL thread.",
            "B": "It is the time between the most recent transaction written to the relay logs and the time it was committed on the master.",
            "C": "It is the time between the I/O thread receiving details of the master's last transaction and the time it was written to the relay log on the slave.",
            "D": "It is the time between the most recent transaction applied by a SQL thread and the time it was committed on the master."
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`Seconds_Behind_Master` (SBM) 是衡量MySQL从服务器（副本）数据相对于主服务器（源）延迟的一个关键指标。\n其计算方式通常是：比较从库SQL线程当前正在处理（或刚刚处理完）的事件在主库上发生时的时间戳，与从库当前的系统时间。更精确地说，它是SQL线程处理的最新事件的时间戳（该时间戳是事件在主服务器上原始提交时的时间戳）与该事件被SQL线程在从服务器上处理完毕时的从服务器当前时间之间的差值（以秒为单位）。\n\nA) (修正后) 这是对`Seconds_Behind_Master`最准确的描述之一。它关注的是SQL线程处理的事件，并将该事件在主库上的原始时间戳与从库处理该事件时的时间进行比较 (A 最优)。\n\n错误选项分析：\nB) 这描述的是中继日志中最新事件与主库提交时间的比较，更多反映I/O线程的进度，而不是SQL线程应用数据的延迟。\nC) 这是I/O线程内部将事件从主库接收到写入本地中继日志的延迟，不是SBM。\nD) (修正后) 这描述的是I/O线程的延迟（I/O线程处理的最后一个事件的主库时间戳与从库当前时间的比较），而不是SBM（SBM主要关注SQL线程）。\n\n**考点总结:**\n此题考察对`Seconds_Behind_Master`计算方法的精确理解。核心在于它是基于SQL线程处理的事件，并比较该事件在主库上的原始时间戳与从库应用该事件时的时间。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解SBM是衡量SQL线程“追赶”主库进度的指标。关注SQL线程处理的事件和时间戳的比较。\n\n**学习建议:**\n学习MySQL复制监控，特别是`SHOW SLAVE STATUS`（或`SHOW REPLICA STATUS`）命令输出中各个字段的含义，尤其是`Seconds_Behind_Master`, `Master_Log_File`, `Read_Master_Log_Pos`, `Relay_Log_File`, `Relay_Log_Pos`, `Relay_Master_Log_File`, `Exec_Master_Log_Pos`等。了解可能导致复制延迟的原因以及如何诊断和解决它们。"
    },
    {
        "question": "### 试题 190:\n\nWhich command enables rule-based MySQL Auditing capabilities?",
        "selections": {
            "A": "shell> mysql < audit_log_filter_linux_install.sql",
            "B": "shell> mysqld --initialize --log-raw=audit.log",
            "C": "mysql> INSTALL PLUGIN audit_log;",
            "D": "mysql> INSTALL COMPONENT audit_log;"
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题169内容几乎完全相同，只是选项顺序可能不同。\n启用MySQL Enterprise Audit的基于规则的审计（过滤）功能，通常需要安装审计插件（如果尚未安装）并加载过滤器定义。\nA) `shell> mysql < audit_log_filter_linux_install.sql`：执行包含创建审计过滤器UDF和存储过程的SQL脚本，这是启用和配置基于规则的审计的关键步骤 (A 正确)。\n\n错误选项分析同试题169。\n\n**考点总结:**\n再次强调启用MySQL Enterprise Audit的基于规则的过滤功能需要安装插件并加载过滤器定义（通常通过SQL脚本）。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，加强记忆。区分插件安装和高级功能（如过滤）的配置。\n\n**学习建议:**\n参考试题169的学习建议。熟练掌握审计插件的安装、配置和使用，特别是过滤规则的创建和管理。"
    },
    {
        "question": "### 试题 191:\n\nConsider this shell output and executed commands:\n```bash\nroot@oel7 ~ # ps aux | grep mysqld\nmysql     2076  3.5 24.6 1386852 372572 ? Ssl 12:01 0:01 /usr/sbin/mysqld\nroot@oel7 ~ # kill -15 2076\n```\nWhich statement is true about MySQL server shutdown?",
        "selections": {
            "A": "kill -15 should be avoided. Use other methods such as mysqladmin shutdown or systemctl stop mysqld.",
            "B": "kill -15 and kill -9 are effectively the same forced shutdown that risk committed transactions not written to disk.",
            "C": "kill -15 carries out a normal shutdown process, such as mysqladmin shutdown.",
            "D": "mysqld_safe prohibits commands that would harm the operation of the server. An error would be returned by the kill command."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`kill -15 <pid>` (或 `kill -TERM <pid>`) 向进程发送SIGTERM信号，这是一个请求进程正常终止的信号。对于`mysqld`进程：\nC) `kill -15`会触发一个正常的关闭过程，类似于执行`mysqladmin shutdown`。`mysqld`进程在收到SIGTERM信号后，会尝试进行优雅关闭，包括完成当前活动、刷新缓冲池、关闭日志文件等 (C 正确)。\n\n错误选项分析：\nA) 虽然使用`mysqladmin shutdown`或`systemctl stop mysqld`是更推荐的、更高级别的关闭服务器的方法（因为它们可能包含额外的检查和管理逻辑），但`kill -15`本身也是一种触发正常关闭的方式，不一定“应该避免”，特别是在某些脚本或自动化场景中。\nB) `kill -15` (SIGTERM) 和 `kill -9` (SIGKILL) 完全不同。SIGTERM是请求正常关闭，允许进程清理资源。SIGKILL是强制立即终止进程，不给进程任何清理的机会，这可能导致数据损坏或不一致，应仅作为最后手段使用。\nD) `mysqld_safe`是一个包装脚本，用于启动和监控`mysqld`进程。它不直接“禁止”`kill`命令。`kill`命令是操作系统级别的，直接作用于进程。`mysqld_safe`在`mysqld`意外退出时可能会尝试重启它，但它不阻止`kill`信号。\n\n**考点总结:**\n此题考察对不同`kill`信号（特别是SIGTERM vs SIGKILL）以及它们如何影响MySQL服务器关闭过程的理解。`kill -15` (SIGTERM) 触发的是正常关闭。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分SIGTERM (-15) 和 SIGKILL (-9) 的含义和后果。理解“正常关闭”或“优雅关闭”的重要性。\n\n**学习建议:**\n学习Linux/Unix系统中的信号（signals）机制。了解`mysqld`进程如何响应常见的信号（如SIGTERM, SIGHUP, SIGQUIT）。熟悉关闭MySQL服务器的各种方法（`mysqladmin shutdown`, `systemctl stop/service stop`, `kill -15`, `SHUTDOWN` SQL命令）及其优缺点和适用场景。始终优先使用更高级别的管理命令进行关闭，避免直接使用`kill -9`，除非万不得已。"
    },
    {
        "question": "### 试题 192:\n\nChoose the best answer. Binary log events for the 'mydb1' schema must be copied to a different schema name 'mydb2'.\nWhich command will do this?",
        "selections": {
            "A": "mysqlbinlog --read-from-remote-server --raw sed 's/mydb1/mydb2/g' | mysql",
            "B": "mysqlbinlog --rewrite-db='mydb1->mydb2' | mysql",
            "C": "mysqlbinlog --database=mydb1 --database=mydb2 | mysql",
            "D": "mysqlbinlog --rewrite-db='mydb1' --rewrite-db='mydb2' | mysql"
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题165内容几乎完全相同，只是选项顺序可能不同。\n要将`mydb1`模式的binlog事件应用到`mydb2`模式，使用`mysqlbinlog`的`--rewrite-db`选项。\nB) `mysqlbinlog --rewrite-db='mydb1->mydb2' | mysql`：将所有原先针对`mydb1`的事件重写为针对`mydb2`，然后通过管道给`mysql`客户端执行 (B 正确)。\n\n错误选项分析同试题165。\n\n**考点总结:**\n再次强调使用`mysqlbinlog`的`--rewrite-db`选项进行数据库名重写，以实现将事件从一个模式应用到另一个模式。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，加强记忆。记住`--rewrite-db='source->target'`的语法。\n\n**学习建议:**\n参考试题165的学习建议。熟练掌握`mysqlbinlog`的各种实用功能。"
    },
    {
        "question": "### 试题 194:\n\nChoose the best answer. You reconfigure and start a slave that was not replicating for several days. The configuration file and `CHANGE MASTER` command are correct. Examine the GTID information from both master and slave: \n\n**Master:**\n```\ngtids_executed: aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-121,\n                bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb:1-50,\n                cccccccc-cccc-cccc-cccc-cccccccccccc:1-2345\ngtids_purged:   aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-10,\n                bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb:1-20,\n                cccccccc-cccc-cccc-cccc-cccccccccccc:1234-1237\n```\n**Slave:**\n```\ngtids_executed: aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-160,\n                cccccccc-cccc-cccc-cccc-cccccccccccc:1-2340\ngtids_purged:   aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1-100,\n                bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb:1-50\n```\nWhich statement is true?",
        "selections": {
            "A": "Replication will fail because the master has inconsistent numbers in cccccccc-cccc-cccc-cccc-cccccccccccc GTIDs.",
            "B": "Replication will work.",
            "C": "Replication will fail because the master has already purged transactions with cccccccc-cccc-cccc-cccc-cccccccccccc GTIDs.",
            "D": "Replication will fail because the slave has purged more aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa transactions than the master.",
            "E": "Replication will fail because the master does not have the required transaction with bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb GTIDs in its binary logs."
        },
        "answers": [
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n比较主从GTID集合以判断复制状态。\n主库 `gtids_executed`: `aaaa:1-121`, `bbbb:1-50`, `cccc:1-2345`.\n主库 `gtids_purged`: `aaaa:1-10`, `bbbb:1-20`, `cccc:1234-1237`.\n从库 `gtids_executed`: `aaaa:1-160`, `cccc:1-2340`.\n从库 `gtids_purged`: `aaaa:1-100`, `bbbb:1-50`.\n\n问题1: 从库的 `aaaa:1-160` (executed) 包含了主库 `aaaa:1-121` (executed) 中没有的GTID (`122-160`)。这是一个严重问题，通常会导致复制失败，因为从库不能拥有主库没有执行过的事务（除非是多源复制或之前连接过其他主库）。\n问题2: 对于`bbbb` UUID，主库执行了`1-50`，从库将其全部标记为`purged`。这意味着从库认为自己不需要这些事务。主库的binlog中可能由于`gtid_purged` (`bbbb:1-20`) 和可能的binlog自动清理，不再包含所有`bbbb:1-50`的事件。\n\nE) 复制会失败，因为主库在其二进制日志中没有从库（可能）需要的`bbbbbbbb...` GTID事务。如果主库的二进制日志由于`gtid_purged`和自动清理，已经不再包含`bbbb:21-50`这些从库未执行但主库执行过的事务（即使从库已标记为purged，但在某些恢复或重新配置场景下，如果从库的GTID状态被重置或修改，而主库无法提供这些历史事务），则复制会失败。更可能的情况是，如问题1所述，从库的`aaaa...`GTID集合与主库不兼容，这是更直接的失败原因。然而，如果答案是E，则其逻辑可能是指主库binlog的可用性问题。\n\n**考点总结:**\n此题考察GTID复制中主从GTID集合不一致可能导致的复制失败。关键在于比较`gtids_executed`和`gtids_purged`，并理解它们如何影响复制启动和事务同步。从库不能拥有主库未执行的GTID；主库必须能够提供从库缺失且未被从库purged的GTID历史。\n\n**此题的GTID状态可能存在一些假设或简化，实际诊断会更复杂。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细对比主从的`gtids_executed`和`gtids_purged`。寻找明显的矛盾，如从库执行了主库没有的GTID，或者主库已purged了从库需要的GTID。\n\n**学习建议:**\n深入学习MySQL GTID的原理、配置和管理。掌握`gtid_executed`和`gtid_purged`系统变量的作用和操作方法。学习如何诊断和解决GTID复制中的常见问题，如GTID不一致、主库binlog丢失等。熟悉与GTID相关的工具和命令，如`mysqlbinlog`, `RESET MASTER`, `RESET SLAVE`, 以及GTID操作函数。"
    },
    {
        "question": "### 试题 195:\n\nChoose the best answer. Examine this command, which executes successfully: `mysqlbackup --defaults-file=/backups/server-my.cnf --backup-dir=/backups/full copy-back`.\nWhich statement is true about the `copy-back` process?",
        "selections": {
            "A": "It restores files from the data directory to their original MySQL server locations.",
            "B": "It restores files from the backup directory to their original MySQL server locations.",
            "C": "The copy-back process is used to overwrite a new backup over an existing backup.",
            "D": "The copy-back process makes inconsistent backups."
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlbackup` (MySQL Enterprise Backup) 的 `copy-back` 操作（或包含`copy-back`的复合操作如`copy-back-and-apply-log`）用于将一个已经准备好的物理备份（通常位于`--backup-dir`指定的目录中）恢复（复制）到MySQL服务器的实际数据目录（`datadir`）。\nB) 它将文件从备份目录（`--backup-dir=/backups/full`）恢复到它们在MySQL服务器上的原始位置（或者由`--datadir`指定的目标数据目录中的相应位置）。“原始MySQL服务器位置”通常指配置的`datadir`下的文件结构 (B 正确)。\n\n错误选项分析：\nA) `copy-back`是从备份目录恢复到数据目录，而不是从（当前活动的）数据目录恢复到“原始位置”。\nC) `copy-back`是恢复操作，不是备份操作，也不是用于覆盖备份。\nD) `copy-back`操作本身是将一个已经经过准备（例如，通过`apply-log`使其一致）的备份部署到数据目录。如果备份本身是一致的，`copy-back`之后的数据也应该是一致的。它不“制造”不一致的备份。\n\n**考点总结:**\n此题考察`mysqlbackup`工具中`copy-back`操作的核心功能：将准备好的物理备份数据部署到MySQL服务器的数据目录以进行恢复。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解物理备份恢复的几个主要阶段：备份（backup）、准备（apply-log）、恢复/部署（copy-back或restore）。将`copy-back`与“部署到生产数据目录”联系起来。\n\n**学习建议:**\n学习MySQL Enterprise Backup (`mysqlbackup`) 的完整备份和恢复流程。掌握不同操作（如`backup`, `backup-to-image`, `image-to-dir`, `apply-log`, `copy-back`, `restore`等）的作用和顺序。熟悉如何使用配置文件（`--defaults-file`）和命令行参数来指定备份源、目标目录和操作选项。进行实际的备份恢复演练。"
    },
    {
        "question": "### 试题 196:\n\nYour `my.cnf` file contains these settings: `mysqld log_output=FILE slow_query_log long_query_time=2.01 log_queries_not_using_indexes`\nYou want to log queries that looked at a minimum of 5000 records and either took longer than 5 seconds to run or did not use indexes.\nWhich contains all the settings that you need to add to or modify the slow log configuration?",
        "selections": {
            "A": "log_throttle_queries_not_using_indexes=5",
            "B": "long_query_time=5 log_throttle_queries_not_using_indexes=5",
            "C": "long_query_time=5",
            "D": "long_query_time=5 log_throttle_queries_not_using_indexes=5 min_examined_row_limit=5000",
            "E": "long_query_time=5 min_examined_row_limit=5000",
            "F": "min_examined_row_limit=5000"
        },
        "answers": [
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题145内容几乎完全相同。\n当前配置：`long_query_time=2.01`, `log_queries_not_using_indexes`。\n目标配置逻辑：“(检查了至少5000行 **并且** 执行时间超过5秒) **或者** (检查了至少5000行 **并且** 没有使用索引)”。\n\nE) `long_query_time=5 min_examined_row_limit=5000`：\n   - 将慢查询时间阈值设为5秒。\n   - 设置检查行数阈值为5000。\n   结合原有的`log_queries_not_using_indexes`，记录条件变为：\n   1.  耗时 > 5秒，或\n   2.  未使用索引，或\n   3.  检查行数 >= 5000 (并满足其他慢查询日志记录条件)。\n   这个组合能覆盖题目要求的两种情况：\n   -   如果查询检查了 >=5000行 且 耗时 >5秒，它会因为“耗时>5秒”被记录，也会因为“检查行数>=5000”被记录。\n   -   如果查询检查了 >=5000行 且 未使用索引，它会因为“未使用索引”被记录，也会因为“检查行数>=5000”被记录。\n   因此，这个配置能确保目标查询被捕获 (E 正确)。\n\n错误选项分析同试题145。\n**OCR答案提示中对各个参数的解释是正确的。**\n\n**考点总结:**\n再次强调MySQL慢查询日志的配置参数，以及如何组合它们来满足特定的日志记录需求。理解慢查询日志记录条件的“或”逻辑关系是关键。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，加强记忆。分析题目要求的布尔逻辑，并将其映射到MySQL慢查询日志参数的“或”条件上。\n\n**学习建议:**\n参考试题145的学习建议。熟练掌握慢查询日志的配置和分析，这是MySQL性能优化的重要手段。"
    },
    {
        "question": "### 试题 197:\n\nChoose the best answer. Consider this shell output and executed commands:\n```bash\nroot@oel7 ~ # ps aux | grep mysqld\nmysql     2076  3.5 24.6 1386852 372572 ? Ssl 12:01 0:01 /usr/sbin/mysqld\nroot@oel7 ~ # kill -15 2076\n```\nWhich statement is true about MySQL server shutdown?",
        "selections": {
            "A": "kill -15 and kill -9 are effectively the same forced shutdown that risk committed transactions not written to disk.",
            "B": "mysqld_safe prohibits commands that would harm the operation of the server. An error would be returned by the kill command.",
            "C": "kill -15 carries out a normal shutdown process, such as mysqladmin shutdown.",
            "D": "kill -15 should be avoided. Use other methods such as mysqladmin shutdown or systemctl stop mysqld."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题191内容几乎完全相同。\n`kill -15 <pid>` (SIGTERM) 向`mysqld`进程发送正常终止信号。\nC) `kill -15`会执行一个正常的关闭过程，类似于`mysqladmin shutdown`。服务器会尝试优雅关闭 (C 正确)。\n\n错误选项分析同试题191。\n**OCR答案提示“kill -15 PID可以理解为操作系统发送一个通知告诉应用主动关闭”是正确的。**\n\n**考点总结:**\n再次强调`kill -15` (SIGTERM) 触发的是MySQL服务器的正常关闭流程，与`kill -9` (SIGKILL) 的强制终止有本质区别。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，加强记忆。区分不同信号对进程行为的影响。\n\n**学习建议:**\n参考试题191的学习建议。理解正常关闭对数据完整性的重要性。"
    },
    {
        "question": "### 试题 198:\n\nChoose the best answer. You have a MySQL system with 500 GB of data that needs frequent backups. You use a mix of MyISAM and InnoDB storage engines for your data. Examine your backup requirements:\n- The MySQL system being backed up can never be unavailable or locked to the client applications.\n- The recovery from the backup must work on any system.\n- Only 1 hour of data can be lost on recovery of the backup.\nWhich option fulfills all backup requirements?",
        "selections": {
            "A": "Take a physical backup of the MySQL system.",
            "B": "Take a logical backup of the MySQL system.",
            "C": "Use the Clone Plugin to copy the data to another MySQL system.",
            "D": "Take your backup from a slave of the MySQL system."
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n备份需求分析：\n1.  **高可用性**: 备份时不应使系统不可用或锁定应用。\n2.  **跨系统恢复**: 备份应能在任何系统上恢复（通常指逻辑备份的优势）。\n3.  **低RPO (Recovery Point Objective)**: 最多只能丢失1小时的数据。\n\nD) 从MySQL系统的从服务器（slave）进行备份：\n   -   **高可用性**: 在从库上进行备份（无论是物理备份还是逻辑备份）可以避免对主库产生性能影响或锁定，主库可以继续提供服务，满足需求1。\n   -   **跨系统恢复**: 如果从从库进行的是逻辑备份（如`mysqldump`），则满足需求2。如果进行的是物理备份，跨系统恢复可能有限制（如OS、MySQL版本、硬件架构等）。\n   -   **低RPO**: 从库数据可能存在复制延迟。如果延迟在1小时内，并且备份的是最新的从库状态，可以满足需求3。但如果延迟超过1小时，则不满足。\n   然而，考虑到其他选项的缺陷，D是最接近的。\n\n错误选项分析：\nA) 直接对主库进行物理备份：热物理备份（如MySQL Enterprise Backup）可以满足高可用性，但跨系统恢复可能受限。冷物理备份则不满足高可用性。\nB) 直接对主库进行逻辑备份（如`mysqldump`）：逻辑备份具有良好的跨系统恢复性。但如果数据量大（500GB），在主库上进行全量逻辑备份可能会非常耗时，并可能对主库性能产生影响或需要短暂锁定（即使使用`--single-transaction`，对MyISAM表也无效）。\nC) 使用克隆插件：克隆插件用于创建实例的物理副本，主要用于快速搭建新实例或替换故障成员，不是传统的备份归档方案。恢复灵活性和RPO可能不完全符合所有要求。\n\n**综合考虑D的优势：** 如果从从库进行逻辑备份，可以同时满足高可用性（不影响主库）和跨系统恢复性。RPO则取决于从库的复制延迟。如果从从库进行热物理备份，可以满足高可用性，但跨系统恢复性差。题目中没有明确备份类型，但“从从库备份”这个策略本身是解决主库可用性问题的常用方法。\n\n**如果选择D，并假设从从库进行的是结合了时间点恢复能力的备份策略（例如，逻辑备份+从库binlog，或者物理备份+从库binlog），则可以较好地满足所有需求。**\n\n**考点总结:**\n此题考察在特定需求（高可用、跨系统恢复、低RPO）下选择合适的MySQL备份策略。从从库备份是减少对主库影响的常用方法。逻辑备份具有更好的跨平台恢复性。RPO的满足则需要结合备份频率和复制延迟。\n\n**此题的“最佳答案”可能依赖于对“备份”类型的隐含假设。如果假设可以灵活选择备份类型，则D选项（从从库备份）提供了最大的灵活性来组合满足所有条件的方案。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n逐条分析备份需求，并评估每个选项是否能满足所有需求。注意备份方法（物理/逻辑）与需求（可用性、恢复性、RPO/RTO）之间的关系。\n\n**学习建议:**\n学习MySQL的各种备份恢复策略及其优缺点。了解不同备份方法对在线业务的影响、恢复速度、恢复灵活性（如跨版本、跨平台、表级恢复）、以及能达到的RPO和RTO。熟悉如何利用复制架构（如在从库上备份）来优化备份过程。学习如何结合全量备份、增量/差异备份和二进制日志来实现灵活的时间点恢复。"
    },
    {
        "question": "### 试题 199:\n\nChoose the best answer. Which statement is true about InnoDB persistent index statistics?",
        "selections": {
            "A": "Increasing innodb_stats_persistent_sample_pages determines higher pages scanning speed, at the cost of increased memory usage.",
            "B": "Execution plans based on transient index statistics improve precision when innodb_stats_persistent_sample_pages is increased.",
            "C": "Index statistics are calculated from pages buffered in the buffer pool for tables with InnoDB storage engine.",
            "D": "Setting innodb_stats_auto_recalc=ON causes statistics to be updated automatically when a new index is created, more than 10% of its rows",
            "E": "Updating index statistics is an I/O expensive operation."
        },
        "answers": [
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nInnoDB持久化索引统计信息（Persistent Index Statistics）旨在提供更稳定和准确的统计数据，以帮助优化器生成更优的查询执行计划。\nE) 更新索引统计信息（无论是通过`ANALYZE TABLE`手动触发，还是在`innodb_stats_auto_recalc=ON`时自动触发）通常需要对表中的一部分数据页（由`innodb_stats_persistent_sample_pages`控制采样页数）进行扫描和分析。这个过程会产生磁盘I/O，特别是对于大表或未缓存在缓冲池中的数据，可能是一个I/O密集型操作 (E 正确)。\n\n错误选项分析：\nA) `innodb_stats_persistent_sample_pages`控制计算持久化统计信息时采样的索引页数量。增加采样页数可以提高统计信息的准确性，但会导致`ANALYZE TABLE`等操作消耗更多时间和I/O，而不是直接“决定更高的页扫描速度”。它可能会增加内存使用（在分析期间），但主要影响是分析的成本和准确性。\nB) 持久化索引统计信息是为了取代旧的、易变的“瞬态”统计信息，以提供更稳定的执行计划。增加`innodb_stats_persistent_sample_pages`会提高持久化统计信息的准确性，而不是“基于瞬态统计信息的执行计划”的精度（因为持久化统计旨在避免瞬态统计的问题）。\nC) 计算持久化索引统计信息时，会从磁盘读取采样的索引页（如果不在缓冲池中）进行分析，而不仅仅依赖于已在缓冲池中的页。目标是获取对整个索引数据分布的代表性估计。\nD) `innodb_stats_auto_recalc=ON`（默认值）会在表数据发生显著变化（例如，超过10%的行被修改）后自动重新计算统计信息。它不直接与“新索引创建”相关（新索引创建时会计算初始统计信息），而是与现有表的数据变化量相关。\n\n**考点总结:**\n此题考察对InnoDB持久化索引统计信息特性的理解，特别是其计算过程的成本（I/O消耗）以及相关配置参数（如`innodb_stats_persistent_sample_pages`, `innodb_stats_auto_recalc`）的作用。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解持久化统计信息的目的——提高查询计划的稳定性。了解统计信息计算的基本原理——采样分析，这通常涉及I/O。\n\n**学习建议:**\n学习InnoDB的索引统计信息管理，包括持久化统计信息和瞬态统计信息的区别。掌握`ANALYZE TABLE`命令的作用和行为。了解`innodb_stats_persistent`, `innodb_stats_persistent_sample_pages`, `innodb_stats_auto_recalc`, `innodb_stats_transient_sample_pages`等相关系统变量的含义和配置。理解索引统计信息（如基数）如何影响查询优化器的决策。"
    },
    {
        "question": "### 试题 200:\n\nChoose the best answer. Which step or set of steps can be used to rotate the error log?",
        "selections": {
            "A": "Execute SET GLOBAL max_error_count = `number of messages at point to rotate`.",
            "B": "Rename the error log file on disk, and then execute FLUSH ERROR LOGS.",
            "C": "Execute SET GLOBAL log_error = `new error log file`.",
            "D": "Execute SET GLOBAL expire_logs_days=0 to enforce a log rotation."
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL错误日志的轮转（rotation）通常需要手动操作，或者依赖外部日志管理工具（如`logrotate`）。MySQL服务器本身没有内置的基于大小或时间的自动轮转错误日志的功能（不像二进制日志或慢查询日志在某些配置下可以自动轮转）。\nB) 在磁盘上重命名当前的错误日志文件，然后执行`FLUSH ERROR LOGS;`（或`FLUSH LOGS;`）SQL命令。`FLUSH ERROR LOGS`会关闭当前的错误日志文件句柄，并重新打开（或创建一个新的）由`log_error`变量指定的错误日志文件。如果在flush之前旧文件已被重命名，服务器会创建一个新的同名文件开始写入。这是手动轮转错误日志的标准方法 (B 正确)。\n\n错误选项分析：\nA) `max_error_count`是一个用于限制在错误日志中写入重复错误消息数量的变量（与错误日志轮转无关）。\nC) `SET GLOBAL log_error = 'new_log_file';`可以动态更改错误日志的输出目标文件，但这需要重启服务器才能完全生效，或者至少在执行`FLUSH ERROR LOGS`后新的日志会写入新文件。它本身不是一个“轮转”操作（轮转通常指保留旧日志并开始新日志）。\nD) `expire_logs_days`是用于控制二进制日志自动过期的参数，与错误日志无关。\n\n**考点总结:**\n此题考察手动轮转MySQL错误日志的方法。核心步骤是重命名现有日志文件，然后执行`FLUSH ERROR LOGS`（或`FLUSH LOGS`）使服务器关闭旧句柄并打开新文件。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住错误日志的管理与二进制日志/慢查询日志不同，它通常需要手动轮转或外部工具。`FLUSH ERROR LOGS`是关键命令。\n\n**学习建议:**\n学习MySQL错误日志的配置（`log_error`变量）、内容和管理。掌握手动轮转错误日志的步骤。了解如何使用操作系统级别的日志轮转工具（如Linux上的`logrotate`）来自动管理MySQL错误日志文件的大小和保留周期。"
    },
    {
        "question": "### 试题 201:\n\nChoose the best answer. You are using an existing server with a new configuration. MySQL Server fails to start. Examine this snapshot of the error log:\n```\n190925 12:49:05 InnoDB:Initializing buffer pool, size = 3.0G\n190925 12:49:05 InnoDB:Completed initialization of buffer pool\nInnoDB:Error:log file ./ib_logfile0 is of different size 5242880 bytes\nInnoDB:than specified in the cnf file 26214400 bytes!\n190925 12:49:05 ERROR Plugin 'InnoDB' init function returned error.\n190925 12:49:05 ERROR Plugin 'InnoDB' registration as a STORAGE ENGINE failed.\n190925 12:49:05 ERROR Aborting\n\n190925 12:49:05 Note /usr/sbin/mysqld:Shutdown complete\n```\nWhich action would allow the server to start?",
        "selections": {
            "A": "Execute mysqladmin flush-logs.",
            "B": "Create a new ib_logfile0 file of size 26214400.",
            "C": "Remove ib_logfile0 and ib_logfile1 files from the file system.",
            "D": "First run mysqld --initialize to refresh the size of ib_logfile."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n错误日志的关键信息是：“`log file ./ib_logfile0 is of different size 5242880 bytes than specified in the cnf file 26214400 bytes!`”。这表明现有的InnoDB redo日志文件（`ib_logfile0`）的大小（5MB）与配置文件（`my.cnf`）中新指定的redo日志文件大小（25MB，假设`innodb_log_file_size=25M`且`innodb_log_files_in_group`导致单个文件是这个大小）不匹配。\n当更改了`innodb_log_file_size`或`innodb_log_files_in_group`参数后，如果服务器正常关闭，它通常会尝试根据新配置调整redo日志文件。但如果未能正常调整，或者直接用不匹配的旧日志文件启动，就会出现此错误。\nC) 从文件系统中移除`ib_logfile0`和`ib_logfile1`（以及其他所有`ib_logfile*`文件）。当MySQL服务器下次启动时，如果找不到现有的redo日志文件，并且配置文件中指定了有效的redo日志参数，InnoDB会自动创建符合新配置大小的redo日志文件。这通常是解决redo日志大小不匹配问题的标准方法（前提是服务器上次是正常关闭的，数据已刷盘，否则有数据丢失风险） (C 正确)。\n\n错误选项分析：\nA) `mysqladmin flush-logs`用于轮转日志或刷新缓冲，与解决redo日志文件大小不匹配的问题无关，且服务器都无法启动，无法执行此命令。\nB) 手动创建一个特定大小的`ib_logfile0`文件通常不可行，因为redo日志文件的内部格式和元数据需要由InnoDB自身管理和初始化。\nD) `mysqld --initialize`用于初始化一个全新的数据目录，会删除现有数据。这不适用于解决现有实例的redo日志大小问题。\n\n**考点总结:**\n此题考察当InnoDB redo日志文件大小与配置文件中指定的大小不匹配时，如何解决导致服务器启动失败的问题。标准做法是（在确认数据安全的前提下）删除旧的redo日志文件，让InnoDB在下次启动时根据新配置重新创建它们。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细阅读错误日志，找到导致启动失败的直接原因。当涉及InnoDB日志文件大小不匹配时，要想到删除旧日志让服务器重建是常见解决方案。\n\n**学习建议:**\n学习InnoDB的redo日志（`ib_logfile*`）的配置参数（`innodb_log_file_size`, `innodb_log_files_in_group`, `innodb_log_group_home_dir`）及其作用。了解在更改这些参数后如何正确地让更改生效（通常涉及正常关闭服务器、删除旧日志文件、然后重启）。理解redo日志在事务持久性和崩溃恢复中的重要性，以及在操作它们时潜在的数据丢失风险（务必确保服务器上次是干净关闭的）。"
    },
    {
        "question": "### 试题 202:\n\nChoose the best answer. Which characters are most commonly used in a SQL injection attack?",
        "selections": {
            "A": "' and \\",
            "B": "< and >",
            "C": "null (\\0) and newline (\\n)",
            "D": "^ and $",
            "E": "+ and -"
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nSQL注入攻击的核心是利用用户输入来构造恶意的SQL代码片段，从而改变原始查询的逻辑或执行额外的操作。一些常用于此目的的特殊字符包括：\nA) 反引号 (`` ` ``) 和反斜杠 (`\\`)：\n   - 反引号 (`` ` ``) 在MySQL中用于界定数据库、表、列等标识符。如果用户输入可以控制标识符部分，注入反引号可能用于闭合或改变标识符。\n   - 反斜杠 (`\\`) 在SQL字符串中通常用作转义字符。注入反斜杠可以用来转义引号，从而使攻击者能够将额外的引号或SQL代码注入到字符串字面量中。\n   除了这两个，单引号 (`'`) 和双引号 (`\"`) 是SQL注入中最常用于闭合字符串字面量并注入后续代码的字符。分号 (`;`) 用于分隔多个SQL语句。注释符 (`-- ` 或 ` /* ... */`) 用于忽略原始查询的剩余部分。\n   在给出的选项中，A选项中的反斜杠`\\`是明确用于SQL注入中进行转义以破坏字符串完整性的。反引号``` ` ```虽然也可能被利用，但其场景不如单/双引号和反斜杠普遍。\n\n   **然而，如果我们必须从给出的选项中选“最常用”的，并且考虑到单引号/双引号没有作为独立选项出现，那么包含反斜杠的A选项是最相关的。**\n\n错误选项分析：\nB) `<` 和 `>`：这些是比较运算符，或用于XML/HTML标签，在SQL注入中不那么直接常用，除非是在特定上下文（如利用XML相关功能）或与其他字符组合。\nC) 空字符 (`\\0`) 和换行符 (`\\n`)：空字符在某些情况下可能用于截断字符串或利用某些C API的漏洞。换行符在SQL中通常被视为空格，不直接用于注入攻击的核心逻辑。\nD) `^` 和 `$`：这些在正则表达式中表示开头和结尾，在SQL中作为位异或运算符或无特殊含义，不常用于SQL注入。\nE) `+` 和 `-`：这些是算术运算符或用于日期/时间操作，不直接是SQL注入的核心特殊字符。\n\n**考点总结:**\n此题考察对SQL注入攻击中常用特殊字符的识别。核心在于那些能够改变SQL语句结构或语义的字符，如引号、注释符、分隔符、转义符。\n\n**OCR解释中列举了多种SQL注入方法，包括使用单引号/双引号、注释符等，这是正确的。**\n**鉴于选项中没有单引号或双引号，而A选项包含了反斜杠（用于转义）和反引号（用于标识符），这是相对最接近的。如果题目允许选择多个，则包含单引号/双引号的选项会是首选。**\n**如果此题是单选“最佳答案”，且必须从给定选项中选择，A是因其包含反斜杠（`\\`）而相对最有可能的。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n思考哪些字符在SQL中有特殊含义，并且如果被用户输入控制，可能被用来“欺骗”解析器。引号、注释、分号是SQL注入的“老朋友”。\n\n**学习建议:**\n深入学习SQL注入的各种类型和技巧。了解不同数据库系统对特殊字符的处理差异。掌握防范SQL注入的根本方法——参数化查询/预编译语句，以及辅助方法如输入验证和输出编码。熟悉常见的SQL注入检测和防御工具。"
    },
    {
        "question": "### 试题 203:\n\nChoose the best answer. Examine these commands, which execute successfully on the `ic1` host:\n```\nmysqlsh> dba.createCluster('cluster1', {memberWeight:35})\nmysqlsh> var mycluster = dba.getCluster()\nmysqlsh> mycluster.addInstance('ic2@ic2', {memberWeight:25})\nmysqlsh> mycluster.addInstance('ic3@ic3', {memberWeight:50})\n```\nNow examine this configuration setting, which is the same on all nodes: `group_replication_consistency=BEFORE_ON_PRIMARY_FAILOVER`\nWhich statement is true if primary node `ic1` fails?",
        "selections": {
            "A": "Node ic2 becomes the new primary and existing transactions are considered stale and rolled back.",
            "B": "Node ic3 becomes the new primary and existing transactions are considered stale and rolled back.",
            "C": "Node ic3 becomes the new primary and is ignored until any backlog of transactions is completed.",
            "D": "Only two nodes remain so the election process is uncertain and must be done manually.",
            "E": "Node ic2 becomes the new primary and is ignored until any backlog of transactions is completed."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n集群配置：\n-   `ic1` (初始主)，权重35。\n-   `ic2`，权重25。\n-   `ic3`，权重50。\n-   `group_replication_consistency=BEFORE_ON_PRIMARY_FAILOVER`：这个一致性级别意味着在主节点发生故障转移之前，所有在旧主上已提交的事务必须先在新的主节点上应用完毕（确保新主拥有所有已提交数据），然后新主才能接受新的写事务。\n\n当主节点`ic1`失败后：\n1.  **选举新主**：集群会在剩余的`ic2`和`ic3`中选举新的主节点。由于`ic3`的权重（50）高于`ic2`的权重（25），`ic3`会被选为新的主节点。\n2.  **一致性保证**：由于`group_replication_consistency=BEFORE_ON_PRIMARY_FAILOVER`，在`ic3`正式成为可写主节点之前，它必须确保自己已经应用了所有来自旧主`ic1`的事务积压（backlog）。在此期间，`ic3`（以及整个集群的写能力）可能会被“忽略”或“暂停”，直到这个同步过程完成。\n\nC) 节点`ic3`成为新的主节点，并且在其完成任何事务积压之前，（来自客户端的新的写请求）会被忽略（或者说，集群的写操作会暂停，直到`ic3`准备好）。这个描述最符合选举结果和一致性设置的行为 (C 正确)。\n\n错误选项分析：\nA), E) `ic2`不会成为新主，因为其权重较低。\nB) “现有事务被认为是陈旧的并回滚”：这不正确。`BEFORE_ON_PRIMARY_FAILOVER`的目标是确保新主拥有所有已提交的事务，而不是回滚它们。\nD) 剩下两个节点（`ic2`和`ic3`）可以形成法定数量（对于3节点集群，多数派是2）。选举过程是自动的，基于权重。不需要手动进行。\n\n**考点总结:**\n此题考察InnoDB集群在主节点故障时的自动故障转移行为，特别是新主节点的选举（基于成员权重）和不同`group_replication_consistency`级别对故障转移过程的影响。`BEFORE_ON_PRIMARY_FAILOVER`强调在切换前的数据同步。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解InnoDB集群主节点选举的依据（主要是成员权重）。熟悉不同`group_replication_consistency`级别（如`EVENTUAL`, `BEFORE_ON_PRIMARY_FAILOVER`, `BEFORE`, `AFTER`, `BEFORE_AND_AFTER`）的含义及其对事务一致性和故障转移行为的影响。\n\n**学习建议:**\n学习MySQL InnoDB Cluster的高可用特性和配置。掌握成员权重（`memberWeight`）在主节点选举中的作用。深入理解不同一致性级别（`group_replication_consistency`）的语义和适用场景。进行故障转移演练，观察不同配置下的集群行为。"
    },
    {
        "question": "### 试题 204:\n\nChoose the best answer. You execute this command: `shell> mysqlpump --exclude-databases=% --users`\nWhich statement is true?",
        "selections": {
            "A": "It creates a logical backup of all metadata, but contains no table data.",
            "B": "It creates a logical backup of only the users database.",
            "C": "It creates a logical backup of all MySQL user accounts.",
            "D": "It returns an error because the mysqldump command should have been used."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlpump`命令的选项：\n-   `--exclude-databases=%`：`%`作为通配符，会排除所有数据库。这意味着不会备份任何数据库的结构或数据。\n-   `--users`：这个选项告诉`mysqlpump`转储用户账户定义（即`CREATE USER`和`GRANT`语句）。\n\nC) 它创建一个只包含所有MySQL用户账户（及其权限）的逻辑备份。由于`--exclude-databases=%`排除了所有数据库的结构和数据，而`--users`选项指示只备份用户账户信息，所以最终的输出将主要是`CREATE USER`和`GRANT`语句 (C 正确)。\n\n错误选项分析：\nA) 由于`--exclude-databases=%`，它不会备份任何数据库的元数据（如表结构）。它只备份用户账户元数据。\nB) `--users`选项备份的是所有用户账户的定义，这些信息存储在`mysql`数据库中，但该选项的作用是专门提取这些账户和权限语句，而不是备份整个`mysql`“数据库”（因为所有数据库都被排除了）。\nD) `mysqlpump`是一个有效的命令，可以与这些选项一起使用。它与`mysqldump`是不同的工具，各有特点。\n\n**考点总结:**\n此题考察`mysqlpump`工具中`--exclude-databases`和`--users`选项组合使用的效果。核心在于理解`--users`选项专门用于备份用户账户和权限定义，而`--exclude-databases=%`会阻止备份任何数据库的表结构和数据。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n准确理解`mysqlpump`（和`mysqldump`）中用于过滤数据库、表以及备份特定对象类型（如用户、存储过程、事件等）的选项。注意选项之间的组合效果。\n\n**学习建议:**\n学习`mysqlpump`和`mysqldump`的高级用法，特别是如何进行选择性备份和恢复。掌握`--users`, `--routines`, `--events`, `--triggers`等选项的作用。了解在哪些场景下可能需要只备份用户账户信息（例如，在迁移或重建服务器时，希望保留用户和权限但重新导入数据）。"
    },
    {
        "question": "### 试题 205:\n\nChoose the best answer. You want to log only the changes made to the database objects and data on the MySQL system.\nWhich log will do this by default?",
        "selections": {
            "A": "slow query log",
            "B": "binary log",
            "C": "error log",
            "D": "general query log",
            "E": "audit log"
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n题目要求记录对数据库对象（如表结构更改DDL）和数据（如行插入/更新/删除DML）所做的“更改”。\nB) 二进制日志（binary log）：默认情况下（当启用时），二进制日志会记录所有导致数据或数据库结构发生更改的SQL语句或行事件。这包括DDL（如`CREATE TABLE`, `ALTER TABLE`）和DML（如`INSERT`, `UPDATE`, `DELETE`）。它是用于复制和时间点恢复的核心日志 (B 正确)。\n\n错误选项分析：\nA) 慢查询日志（slow query log）：记录执行时间超过指定阈值的查询，主要用于性能优化，不记录所有更改。\nC) 错误日志（error log）：记录服务器启动、关闭过程中的信息、错误、警告以及一些诊断信息，不记录数据或对象更改的SQL语句。\nD) 通用查询日志（general query log）：记录所有从客户端接收到的SQL语句，包括`SELECT`等只读查询以及所有更改。虽然它包含了更改，但题目说“只记录更改”，通用查询日志记录了“所有”语句，范围更广，且对性能影响较大。\nE) 审计日志（audit log）：用于记录特定的数据库活动以进行安全审计，例如登录、访问敏感数据、权限更改等。其记录内容可配置，可以包含数据更改，但其主要目的和默认行为是审计特定事件，不一定“只”记录所有对象和数据更改。\n\n**考点总结:**\n此题考察MySQL不同类型日志的主要功能和记录内容。二进制日志是专门用于记录数据和结构“更改”的日志。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n清晰地区分MySQL的几种主要日志类型（错误日志、通用查询日志、慢查询日志、二进制日志、中继日志、审计日志）及其各自的核心用途。\n\n**学习建议:**\n学习MySQL的日志系统。掌握每种日志的配置参数、记录内容、格式以及如何查看和管理它们。理解二进制日志在复制和恢复中的关键作用。"
    },
    {
        "question": "### 试题 206:\n\nChoose the best answer. Examine this partial output for InnoDB Cluster status: \n```json\n{\n  \"topology\": {\n    \"host1:3377\": {\n      \"address\": \"host1:3377\",\n      \"mode\": \"R/W\",\n      \"status\": \"ONLINE\",\n      \"version\": \"8.0.18\"\n    },\n    \"host2:3377\": {\n      \"address\": \"host2:3377\",\n      \"mode\": \"R/O\",\n      \"status\": \"MISSING\"\n    },\n    \"host3:3377\": {\n      \"address\": \"host3:3377\",\n      \"mode\": \"R/O\",\n      \"status\": \"ONLINE\",\n      \"version\": \"8.0.18\"\n    }\n  }\n}\n```\nWhich statement explains the state of the instance deployed on host2?",
        "selections": {
            "A": "It can rejoin the cluster by using the command cluster.addInstance ('<user>@host3:3377').",
            "B": "It has been expelled from the cluster because of a transaction error.",
            "C": "It can be recovered from a donor instance on host3 by cloning using the command cluster.rejoinInstance ('<user>@host3:3377').",
            "D": "It has been removed from the cluster by using the command STOP GROUP_REPLICATION.",
            "E": "It can rejoin the cluster by using the command dba.rebootClusterFromCompleteOutage()."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题125内容几乎完全相同。\n输出显示host2的状态为`MISSING`。\nC) 它可以从一个健康的donor实例（如host1或host3）通过克隆（如果需要）恢复，并使用`cluster.rejoinInstance('<user>@host2_address:port_of_host2_to_rejoin>')`命令尝试重新加入集群。`rejoinInstance`是处理`MISSING`状态成员恢复的常用命令 (C 正确，但命令中的donor应该是集群自动选择或可指定，目标是host2本身)。\n\n错误选项分析同试题125。\n**OCR答案提示中的解释与试题125类似，强调了`rejoinInstance`的适用性，并区分了`removeInstance`后使用`addInstance`的情况。**\n\n**考点总结:**\n再次强调对InnoDB集群成员状态（特别是`MISSING`）的理解以及如何使离线或故障成员重新加入集群。`cluster.rejoinInstance()`是核心恢复命令之一。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，加强记忆。理解`MISSING`状态的含义和恢复路径。\n\n**学习建议:**\n参考试题125的学习建议。熟练掌握集群成员的生命周期管理和故障恢复操作。"
    },
    {
        "question": "### 试题 207:\n\nChoose the best answer. You use Row Based Replication and need to see `pseudo-SQL` statements for the replication event that is located in the log_file position NNNNN file.\nWhich command should you use?",
        "selections": {
            "A": "mysqlshow --debug --stop-position=NNNNN log_file",
            "B": "mysqlbinlog --verbose --start-position=NNNNN log_file",
            "C": "mysqlbinlog --debug --start-position=NNNNN log_file",
            "D": "mysqlbinlog --debug --stop-position=NNNNN log_file",
            "E": "mysqlshow --verbose --stop-position=NNNNN log_file",
            "F": "mysqlbinlog --verbose --stop-position=NNNNN log_file",
            "G": "mysqlshow --debug --start-position=NNNNN log_file",
            "H": "mysqlshow --verbose --start-position=NNNNN log_file"
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n题目要求查看基于行复制（Row Based Replication, RBR）的二进制日志事件，并以“伪SQL”（pseudo-SQL）的形式展示。`mysqlbinlog`工具用于此目的。\n-   `--verbose` (或 `-v`): 当与RBR事件一起使用时，这个选项会使`mysqlbinlog`尝试将行更改事件（如`Write_rows`, `Update_rows`, `Delete_rows`）转换为更易读的、类似SQL注释的形式，显示更改前后的列值。这就是所谓的“伪SQL”。\n-   `--start-position=NNNNN`: 指定从日志文件的哪个位置开始处理事件。\n-   `log_file`: 指定要处理的二进制日志文件名。\n\nB) `mysqlbinlog --verbose --start-position=NNNNN log_file`：这个命令使用`--verbose`选项来获取伪SQL输出，并从指定的位置`NNNNN`开始处理指定的`log_file`。这符合题目的要求 (B 正确)。\n\n错误选项分析：\nA), E), G), H) `mysqlshow`是一个客户端程序，用于显示关于数据库、表、列等的信息，它不用于处理或显示二进制日志内容。\nC), D) `--debug`选项用于输出`mysqlbinlog`自身的调试信息，与生成伪SQL无关。\nF) `--stop-position`用于指定停止处理事件的位置。题目要求查看“位于”某个位置的事件，暗示从该位置开始，而不是在该位置停止。\n\n**考点总结:**\n此题考察使用`mysqlbinlog`工具查看和分析基于行复制（RBR）的二进制日志事件，特别是如何通过`--verbose`选项获取“伪SQL”表示以帮助理解行更改内容。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住`mysqlbinlog`是查看binlog内容的标准工具。了解`--verbose`选项在处理RBR事件时的特殊作用（生成伪SQL）。区分`--start-position`和`--stop-position`。\n\n**学习建议:**\n学习`mysqlbinlog`工具的各种选项，特别是与解码RBR事件相关的（如`-v`, `-vv`, `--base64-output=DECODE-ROWS`）。练习使用这些选项来分析不同类型的binlog事件。了解RBR与SBR（Statement Based Replication）的区别及其对binlog内容和大小的影响。"
    },
    {
        "question": "### 试题 208:\n\nChoose the best answer. Which utility would you use to view the queries in the slow query log sorted by average query time?",
        "selections": {
            "A": "mysqlcheck",
            "B": "mysqlshow",
            "C": "mysqlimport",
            "D": "mysqldump",
            "E": "mysqldumpslow"
        },
        "answers": [
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL慢查询日志记录了执行时间超过阈值的SQL语句。要分析这些日志并按特定标准（如平均查询时间）排序，可以使用`mysqldumpslow`工具。\nE) `mysqldumpslow`：这是一个Perl脚本，用于解析MySQL慢查询日志文件，并对查询进行汇总和排序。它提供了多种排序选项，包括按平均查询时间（`-s at`或`--sort=at`）、总执行时间、执行次数等 (E 正确)。\n\n错误选项分析：\nA) `mysqlcheck`：用于检查、修复、分析和优化表。\nB) `mysqlshow`：用于显示数据库、表、列等信息。\nC) `mysqlimport`：用于从文本文件导入数据到表中（`LOAD DATA INFILE`的命令行接口）。\nD) `mysqldump`：用于创建数据库的逻辑备份。\n\n**考点总结:**\n此题考察分析MySQL慢查询日志的专用工具。`mysqldumpslow`是官方提供的标准工具。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住`mysqldumpslow`是与“slow query log”对应的分析工具。其名称本身就提示了功能。\n\n**学习建议:**\n学习如何配置和启用MySQL慢查询日志。掌握`mysqldumpslow`工具的使用方法和常用选项（如`-s <sort_type>`, `-t <num_queries>`, `-g <pattern>`等）。了解如何解读`mysqldumpslow`的输出，以找出性能瓶颈查询。也可以考虑使用更高级的日志分析工具，如Percona Toolkit中的`pt-query-digest`，它提供了更强大和灵活的分析功能。"
    },
    {
        "question": "### 试题 209:\n\nChoose the best answer. Examine the command, which executes successfully: `shell> mysqld --initialize`\nWhich statement is true?",
        "selections": {
            "A": "The root password is created in the error log in plain text.",
            "B": "The installation creates a temporary test environment with data in the /tmp directory.",
            "C": "The installation is created without enforcing or generating SSL certificates.",
            "D": "The root password is not created allowing easy access from the same host."
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题158和试题74关注点相似，但这里用的是`mysqld --initialize`（而不是`--initialize-insecure`）。\n`mysqld --initialize`命令用于初始化MySQL数据目录。在MySQL 5.7.6及以后版本（包括8.0），这个命令会：\n-   创建一个`'root'@'localhost'`用户账户。\n-   为这个root用户生成一个临时的、随机的密码。\n-   将这个临时密码输出到MySQL的错误日志文件中。\n\nA) root用户的（临时）密码以明文形式创建并记录在错误日志中 (A 正确)。\n\n错误选项分析：\nB) 初始化数据目录是在`datadir`指定的路径下进行，与`/tmp`目录无关（除非`datadir`被设置为`/tmp`）。它创建的是生产环境所需的数据文件结构。\nC) SSL证书的生成和强制使用是独立于数据目录初始化的配置。服务器启动时可能会自动生成自签名SSL证书（如果未配置），但这与`--initialize`命令本身不直接相关。\nD) `mysqld --initialize`会为root用户创建密码。是`--initialize-insecure`才会创建无密码的root用户。\n\n**考点总结:**\n此题考察`mysqld --initialize`命令的特定行为，即它会为本地root用户生成一个临时密码并将其记录到错误日志中。这与`--initialize-insecure`（创建无密码root）形成对比。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分`--initialize`和`--initialize-insecure`这两个初始化选项的关键差异——密码的创建方式。记住`--initialize`会产生临时密码并输出到错误日志。\n\n**学习建议:**\n学习MySQL数据目录初始化的不同方法和选项。掌握如何定位MySQL错误日志文件。熟悉初始化后首次登录MySQL并修改root密码的步骤（使用`ALTER USER`命令）。了解`mysql_secure_installation`脚本在初始安全配置中的作用。"
    },
    {
        "question": "### 试题 210:\n\nChoose the best answer. Your MySQL environment has asynchronous position based-replication with one master and one slave. The slave instance had a disk I/O problem, so it was stopped. You determine that the slave relay log files were corrupted and unusable, but no other files are damaged. You restart MySQL Server.\nHow can replication be restored?",
        "selections": {
            "A": "The slave relay logs should be deleted; then execute START SLAVE;",
            "B": "The slave needs to be restored from backup.",
            "C": "The slave relay logs should be deleted; execute CHANGE MASTER to adjust the replication relay log file name, then issue START SLAVE;",
            "D": "The relay logs from the master should be used to replace the corrupted relay logs."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n场景：从库因磁盘I/O问题停止，导致中继日志（relay logs）损坏。其他文件（如数据文件）完好。服务器已重启。\n目标是恢复复制。\nC) 删除损坏的中继日志文件。然后执行`CHANGE MASTER TO ...`（或`CHANGE REPLICATION SOURCE TO ...`）命令。即使主库信息（如主机、端口、用户、密码）没有改变，重新执行`CHANGE MASTER TO`命令（可以指定当前的`MASTER_LOG_FILE`和`MASTER_LOG_POS`，或者如果主库binlog位置未知或不确定，可能需要从一个新的、已知安全的位置开始，或者如果启用了GTID，则使用`MASTER_AUTO_POSITION=1`）。这个命令的一个副作用是它会重置中继日志信息，使从库在下次启动I/O线程时会从主库请求新的binlog并创建新的中继日志文件。然后执行`START SLAVE;`（或`START REPLICA;`）来启动复制线程 (C 正确)。\n\n错误选项分析：\nA) 仅仅删除中继日志并执行`START SLAVE`可能不够。如果中继日志的元数据（如`master.info`或`relay-log.info`文件，或在MySQL 8.0.22+的`mysql.slave_master_info`和`mysql.slave_relay_log_info`表）也指向了损坏的日志或不一致的位置，从库可能无法正确启动或从正确的位置继续。`CHANGE MASTER TO`可以更可靠地重置这些状态。\nB) 如果只是中继日志损坏，而数据文件完好，通常不需要从备份中完全恢复从库。只需修复复制链路。\nD) 主库上的是二进制日志（binary logs），不是中继日志。不能用主库的二进制日志直接替换从库的中继日志。从库的中继日志是从主库二进制日志复制过来的副本。\n\n**考点总结:**\n此题考察当MySQL从库的中继日志损坏时如何恢复复制。标准步骤通常包括停止复制、清理损坏的中继日志（和可能相关的元数据文件/表）、使用`CHANGE MASTER TO`命令重新指定复制源和位置（或重置中继日志状态），然后重新启动复制。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解中继日志在复制中的作用——它是从主库binlog复制过来的临时存储。当中继日志损坏时，核心是让从库“忘记”旧的、损坏的中继日志，并从主库重新获取。\n\n**学习建议:**\n学习MySQL复制的故障排除。熟悉当不同组件（如I/O线程、SQL线程、中继日志、主库binlog）出现问题时如何诊断和恢复。掌握`SHOW SLAVE STATUS`, `CHANGE MASTER TO`, `START SLAVE`, `STOP SLAVE`, `RESET SLAVE`等命令的使用。了解与中继日志相关的配置参数（如`relay_log`, `relay_log_index`, `relay_log_info_file`/`relay_log_info_repository`等）以及`relay_log_recovery`参数的作用。"
    },
    {
        "question": "### 试题 211:\n\nExamine this configuration: You have a corporate private network, which uses its own Certificate Authority (CA) using an industry standard 2048-bit RSA key length. All MySQL Server and client certificates are signed using the central corporate CA. All clients are known, controlled, and exist only on the private LAN. The private network uses its own private authoritative DNS. The private network also uses other nominal enterprise services. An end-to-end encrypted connection for a MySQL client to MySQL server has been established on this LAN.\nHow does the MySQL Servers' self signed certificate compare to one that would be signed by a known public, third party trusted Certificate Authority?",
        "selections": {
            "A": "The self-signed certificate is equally secure and equally trusted.",
            "B": "The self-signed certificate is more secure and less trusted.",
            "C": "The self-signed certificate is less secure and equally trusted.",
            "D": "The self-signed certificate is equally secure and less trusted.",
            "E": "The self-signed certificate is more secure and equally trusted.",
            "F": "The self-signed certificate is less secure and less trusted."
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n题目描述的是一个使用内部企业CA签发的服务器证书的环境。\n- **安全性（Secure）**: 指的是加密强度、密钥长度、协议的安全性等。如果内部CA遵循与公共CA相同的行业标准（如2048位RSA密钥），并且正确生成和管理证书，那么从加密算法和密钥强度的角度看，其提供的加密安全性是“同等安全”的。\n- **可信度（Trusted）**: 指的是证书被客户端（或更广泛的互联网）信任的程度。公共CA的根证书通常内置在操作系统和浏览器中，因此由它们签发的证书被广泛自动信任。内部企业CA的根证书通常只在该企业内部的设备上被配置为受信任。对于企业外部的客户端，或者未配置信任该内部CA的客户端，这个证书是“不被信任”或“信任度较低”的。\n\nD) 自签名证书（这里更准确地说是“内部CA签发的证书”）在安全性上是同等的（equally secure，假设遵循相同标准），但在可信度上较低（less trusted，指对外部而言） (D 正确)。\n\n错误选项分析：\nA) “同等信任”是错误的，因为内部CA不如公共CA被广泛信任。\nB) “更安全”通常不正确，除非内部CA在某些方面比公共CA更严格。信任度确实更低。\nC) “不安全”通常不正确。信任度“同等”是错误的。\nE) “更安全”且“同等信任”都是错误的。\nF) “不安全”且“不信任”过于绝对。安全性是同等的，信任度是内部的。\n\n**考点总结:**\n此题考察对X.509证书体系中CA角色、证书安全性和可信度的理解。关键在于区分证书提供的加密安全性（取决于算法、密钥长度、生成过程）和其被信任的范围（取决于CA的可信度和客户端的信任配置）。内部CA签发的证书在内部网络中可以被配置为完全受信任，但在外部看来其信任度低于公共CA。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n区分“安全性”（加密强度等技术层面）和“可信度”（被信任的范围和程度）。内部CA和公共CA在安全性上可以做到同等，但在可信范围上有本质区别。\n\n**学习建议:**\n学习公钥基础设施（PKI）和X.509证书的基本概念，包括证书颁发机构（CA）、根证书、中间证书、服务器证书、客户端证书、证书链验证等。了解自签名证书、内部CA签发证书和公共CA签发证书的区别、适用场景和安全含义。熟悉如何在MySQL中配置和使用SSL/TLS，包括生成和管理证书。"
    },
    {
        "question": "### 试题 212:\n\nChoose the best answer. Examine these statements and output:\n```sql\nmysql> GRANT PROXY ON accounting@localhost TO 'rsmith'@'%';\nmysql> SELECT USER(), CURRENT_USER(), @@proxy_user; \n```\n\n```\n+--------------------+------------------------+--------------+\n| USER()             | CURRENT_USER()         | @@proxy_user |\n+--------------------+------------------------+--------------+\n| rsmith@some_client | accounting@localhost   | 'rsmith'@'%' |\n+--------------------+------------------------+--------------+\n```\nWhich statement is true?",
        "selections": {
            "A": "The user failed to define a username and the connecting username defaulted to '@%'.",
            "B": "The user is authorized as the rsmith@localhost user.",
            "C": "The user is authenticated as the anonymous proxy user '@%'.",
            "D": "The user is logged in with --user=accounting as an option.",
            "E": "The user is authorized as the accounting@localhost user."
        },
        "answers": [
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n- `GRANT PROXY ON accounting@localhost TO 'rsmith'@'%';`: 这条语句授予用户`'rsmith'@'%'`代理（PROXY）用户`'accounting'@'localhost'`的权限。这意味着`rsmith`可以以`accounting`的身份连接和操作，但服务器知道实际连接者是`rsmith`。\n- `USER()`: 返回客户端连接时使用的账户，这里是`'rsmith'@'some_client'`（假设`some_client`是`rsmith`连接的实际主机）。\n- `CURRENT_USER()`: 返回当前会话执行权限检查时使用的账户。由于`rsmith`代理了`accounting`，`CURRENT_USER()`会显示被代理的账户，即`'accounting'@'localhost'`。\n- `@@proxy_user`: 返回代理用户的账户，这里是`'rsmith'@'%'`。\n\nE) 用户被授权为`accounting@localhost`用户。由于`CURRENT_USER()`是`'accounting'@'localhost'`，这意味着当前会话的所有权限检查都是基于`accounting@localhost`这个账户被授予的权限。`rsmith`实际上是以`accounting`的身份在操作 (E 正确)。\n\n错误选项分析：\nA) `USER()`显示`'rsmith'@'some_client'`，表明用户是以`rsmith`的身份连接的。\nB) 用户是以`rsmith`的身份认证连接的（`USER()`和`@@proxy_user`都指向`rsmith`），但其当前的权限上下文是`accounting@localhost`（`CURRENT_USER()`）。所以他不是被“授权为`rsmith@localhost`用户”（除非`rsmith@localhost`和`rsmith@%`是同一个权限集，但`CURRENT_USER`是关键）。\nC) 用户是以`rsmith`认证的，不是匿名代理用户。`accounting@localhost`是被代理的用户。\nD) 用户是以`rsmith`登录的，然后激活了对`accounting`的代理。不是直接用`--user=accounting`登录。\n\n**考点总结:**\n此题考察MySQL的代理用户（Proxy User）功能。核心在于理解`USER()`, `CURRENT_USER()`, 和 `@@proxy_user`（或`PROXY_USER()`函数）在代理场景下的不同含义。`CURRENT_USER()`是被代理的身份，决定了当前会话的权限。\n\n**OCR分析中给出的创建代理用户和授权的步骤是正确的。`CURRENT_USER()`是权限的真正拥有者。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住在代理用户场景下：\n-   `USER()` = 实际连接的客户端用户。\n-   `CURRENT_USER()` = 被代理的用户，权限检查基于此用户。\n-   `@@proxy_user` = 实际连接的客户端用户（即代理者）。\n\n**学习建议:**\n学习MySQL的代理用户功能，包括如何创建代理关系（`GRANT PROXY ON ... TO ...`）、如何激活代理（例如，客户端连接时指定或在应用中设置），以及代理用户如何影响权限检查和审计。了解代理用户的应用场景（如连接池、应用服务器代表最终用户执行操作等）。"
    },
    {
        "question": "### 试题 213:\n\nChoose the best answer. You wish to store the username and password for a client connection to MySQL server in a file on a local file system.\nWhich is the best way to encrypt the file?",
        "selections": {
            "A": "Use mysql_secure_installation to encrypt stored login credentials.",
            "B": "Use the AES_ENCRYPT() MySQL function on the option file.",
            "C": "Use mysql_config_editor to create an encrypted file.",
            "D": "Use a text editor to create a new defaults file and encrypt it from Linux prompt."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n要在本地文件系统中安全地存储MySQL客户端连接的用户名和密码（特别是密码），推荐使用MySQL提供的专用工具。\nC) 使用`mysql_config_editor`工具来创建一个加密的文件（通常是`~/.mylogin.cnf`）。这个工具会将连接参数（包括密码）以加密形式存储。客户端程序（如`mysql`, `mysqldump`等）可以通过`--login-path`选项读取这些加密的凭据，而无需在命令行或普通配置文件中明文存储密码 (C 正确)。\n\n错误选项分析：\nA) `mysql_secure_installation`是一个用于MySQL安装后进行基本安全加固的脚本，它不用于加密存储客户端登录凭据的文件。\nB) `AES_ENCRYPT()`是MySQL服务器端的SQL函数，用于加密数据库中的数据，不能直接用于加密操作系统上的选项文件。\nD) 使用文本编辑器创建默认文件（如`~/.my.cnf`）然后从Linux命令行加密它，这是一种通用的文件加密方法，但不是MySQL推荐的、与客户端集成最好的方式。`mysql_config_editor`提供了更便捷和专门的解决方案。\n\n**考点总结:**\n此题考察安全存储MySQL客户端连接凭据的方法。`mysql_config_editor`是官方推荐的用于创建加密登录路径文件的工具。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n当题目涉及“安全存储密码”或“加密凭据文件”时，优先考虑`mysql_config_editor`。将其与在普通选项文件中明文存储密码（不安全）或在命令行提供密码（不安全）进行对比。\n\n**学习建议:**\n学习如何使用`mysql_config_editor`命令（`set`, `remove`, `print`, `reset`等子命令）来创建、管理和使用加密的登录路径。了解`.mylogin.cnf`文件的作用和存储位置。熟悉MySQL客户端程序如何通过`--login-path`选项利用这些预存的连接参数。"
    },
    {
        "question": "### 试题 214:\n\nYou recently upgraded your MySQL installation to MySQL 8.0. Examine this client error: `ERROR 2059 (HY000): Authentication plugin 'caching_sha2_password' cannot be loaded:/usr/local/mysql/lib/plugin/caching_sha2_password.so: cannot open shared object file: No such file or directory`\nWhich option will allow this client to connect to MySQL Server?",
        "selections": {
            "A": "mysqld default_authentication_plugin=sha256_password",
            "B": "mysqld default_authentication_plugin=caching_sha2_password",
            "C": "ALTER USER user IDENTIFIED WITH sha256_password BY 'password';",
            "D": "ALTER USER user IDENTIFIED WITH caching_sha2_password BY 'password';",
            "E": "ALTER USER user IDENTIFIED WITH mysql_native_password BY 'password';",
            "F": "mysqld default_authentication_plugin=mysql_native_password"
        },
        "answers": [
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题与试题167内容几乎完全相同。\n错误信息表明客户端无法加载`caching_sha2_password`认证插件的共享库文件。要解决此问题，应在服务器端将用户的认证插件更改为客户端普遍支持的插件。\nE) `ALTER USER user IDENTIFIED WITH mysql_native_password BY 'password';`：将用户的认证插件更改为`mysql_native_password`，并设置新密码。这允许客户端使用传统的、广泛支持的认证方法连接 (E 正确)。\n\n错误选项分析同试题167。\n\n**考点总结:**\n再次强调当客户端因无法加载`caching_sha2_password`插件而连接失败时，通过在服务器端将用户认证方式更改为`mysql_native_password`是常用的解决方法。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n重复考点，加强记忆。认证插件加载失败通常指向客户端兼容性问题。\n\n**学习建议:**\n参考试题167的学习建议。务必理解不同认证插件的特点和兼容性，以及如何在服务器和客户端进行配置。"
    },
    {
        "question": "### 试题 215:\n\nChoose the best answer. Which condition is true about the use of the hash join algorithm?",
        "selections": {
            "A": "At least one of the tables in the join must have a hash index.",
            "B": "No index can be used for the join.",
            "C": "The query must access no more than two tables.",
            "D": "The smallest of the tables in the join must fit in memory as set by join_buffer_size."
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL从8.0.18版本开始支持哈希连接（Hash Join）。哈希连接通常在以下情况下被优化器考虑使用：\n-   连接是等值连接（equi-join）。\n-   没有合适的索引可用于更优的连接算法（如嵌套循环连接Nested Loop Join或索引嵌套循环连接Index Nested Loop Join）。\n-   优化器估计哈希连接的成本更低。\n\n哈希连接的工作过程通常涉及：\n1.  **构建阶段 (Build Phase)**：选择连接中的一个表（通常是较小的那个，称为构建表build table），读取其行，并根据连接键计算哈希值，将行存入内存中的哈希表（hash table）。\n2.  **探测阶段 (Probe Phase)**：读取另一个表（探测表probe table）的行，根据连接键计算哈希值，并在哈希表中查找匹配的行。\n\n B) 正确：哈希连接通常在不使用索引的情况下效果最好，因为它会为连接键构建内存中的哈希表。如果已经存在索引（如B树索引），优化器可能会选择其他连接方式（如嵌套循环连接）。\n\n错误选项分析：\n A) 错误：哈希连接不需要表预先存在哈希索引。它是执行时动态构建的临时哈希表，与表的存储结构无关。\nC) 错误：哈希连接可以用于多表连接（不止两个表），只要优化器认为合适。\nD) 错误：虽然哈希连接需要内存，但现代实现（如MySQL 8.0+）支持grace hash join，当内存不足时会将数据分片到磁盘处理，不要求整个小表必须放入内存。\n\n**考点总结:**\n此题考察对MySQL哈希连接算法基本原理和使用条件的理解。核心在于它是等值连接的一种优化算法，特别是在无合适索引时，并且其性能与构建表能否放入内存（受`join_buffer_size`等影响）密切相关。\n\n**OCR答案提示中的链接和解释指出了哈希连接只在没有索引的等值连接字段上有效，并且引用了相关的文档页码。**",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解哈希连接的“哈希表”核心。思考构建哈希表对内存的需求。将其与基于索引的连接方法（如嵌套循环）进行对比。\n\n**学习建议:**\n学习MySQL 8.0中引入的哈希连接算法，包括其工作原理、适用场景（特别是等值连接、无合适索引、一个表相对较小的情况）。了解`join_buffer_size`等内存参数如何影响哈希连接的性能。学习如何通过`EXPLAIN`（特别是`FORMAT=JSON`或`EXPLAIN ANALYZE`）来观察查询是否使用了哈希连接以及其执行细节。"
    },
    {
        "question": "### 试题 216:\n\nWhich three are characteristics of logical backups?",
        "selections": {
            "A": "They consist of exact copies of database directories and files.",
            "B": "They can be created by mysqlbackup for InnoDB tables or by file-system commands, such as cp, scp, tar, or rsync, for MyISAM tables.",
            "C": "They can be performed while the MySQL server is not running.",
            "D": "They can be run only against a running MySQL server.",
            "E": "They are machine independent and highly portable.",
            "F": "Backup and restore granularity is available at the server level, database level, or table level for any storage engine.",
            "G": "In addition to databases, backups can include any related files, such as log or configuration files."
        },
        "answers": [
            "D",
            "E",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n逻辑备份（如使用`mysqldump`或`mysqlpump`创建的备份）的特点：\nD) 它们通常只能针对正在运行的MySQL服务器执行。逻辑备份工具需要连接到服务器，查询元数据（表结构等）和数据，然后将其转换为逻辑格式（如SQL语句或分隔文本） (D 正确)。\nE) 它们是机器无关且高度可移植的。由于逻辑备份是SQL语句或标准文本格式，它们通常可以轻松地在不同操作系统、不同MySQL版本（在一定兼容范围内）甚至不同数据库系统（如果只是数据且格式兼容）之间进行恢复 (E 正确)。\nF) 备份和恢复的粒度可以达到服务器级别（所有数据库）、数据库级别或表级别（对于任何存储引擎）。逻辑备份工具通常提供选项来指定要备份的对象范围 (F 正 Cũng)。\n\n错误选项分析：\nA) 这是物理备份的特点，物理备份直接复制数据目录和文件。\nB) `mysqlbackup`主要用于物理备份。使用文件系统命令（cp, scp, tar, rsync）复制MyISAM表文件属于物理备份（冷备份或温备份）。\nC) 逻辑备份需要连接到运行中的服务器以查询数据和元数据。如果服务器未运行，无法进行逻辑备份。冷物理备份才是在服务器停止时进行的。\nG) 逻辑备份主要关注数据库对象（库、表、视图、存储过程等）的结构和数据。它们通常不直接包含服务器的日志文件（如错误日志、二进制日志）或配置文件（`my.cnf`）。这些文件需要单独备份。\n\n**考点总结:**\n此题考察对逻辑备份基本特性的理解，包括其操作前提（服务器运行）、可移植性以及备份恢复的粒度。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n清晰地区分逻辑备份和物理备份的核心特征。逻辑备份是“导出为可重现的指令或数据”，物理备份是“复制原始文件”。\n\n**学习建议:**\n学习MySQL的逻辑备份工具（`mysqldump`, `mysqlpump`）和物理备份工具/方法。掌握它们各自的优点、缺点、适用场景、备份/恢复速度、对服务器负载的影响、备份文件大小、可移植性、以及支持的备份恢复粒度。了解如何选择合适的备份策略以满足不同的业务需求。"
    },
    {
        "question": "### 试题 217:\n\nWhich two statements are true about MySQL Enterprise Backup?",
        "selections": {
            "A": "It supports the creation of incremental backups.",
            "B": "It creates logical backups.",
            "C": "It supports restoring to a remote MySQL system.",
            "D": "It supports backing up only table structures.",
            "E": "It supports backup of a remote MySQL system.",
            "F": "It can perform hot or warm backups."
        },
        "answers": [
            "A",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL Enterprise Backup (`mysqlbackup`) 是一个企业级物理备份工具。\nA) 它支持创建增量备份（incremental backups）。增量备份只备份自上次备份（完全备份或另一次增量备份）以来发生更改的数据页，可以显著减少备份时间和存储空间 (A 正确)。\nF) 它可以执行热备份（hot backups）或温备份（warm backups）。对于InnoDB存储引擎，它可以执行热备份，即在数据库正常运行且可读写的情况下进行备份，对应用影响最小。对于其他存储引擎（如MyISAM），可能执行温备份（需要短暂锁定）或需要其他策略 (F 正确)。\n\n错误选项分析：\nB) `mysqlbackup`主要创建物理备份，而不是逻辑备份。逻辑备份通常由`mysqldump`或`mysqlpump`创建。\nC) `mysqlbackup`本身主要用于将备份恢复到本地系统或具有相似配置的系统。要恢复到“远程MySQL系统”，通常涉及将备份文件传输到远程系统，然后在那里进行恢复操作。它不直接“支持恢复到远程系统”作为一个内建的网络恢复功能。\nD) `mysqlbackup`进行的是物理备份，会备份整个数据文件，包括表结构和数据，而不仅仅是表结构。\nE) `mysqlbackup`通常在MySQL服务器本机或可以访问其数据文件的主机上运行以执行备份。它不直接“备份远程MySQL系统”的数据文件（除非通过网络文件系统等间接方式，但这不算是其标准远程备份模式）。要备份远程系统，通常是在远程系统上运行备份工具。\n\n**考点总结:**\n此题考察MySQL Enterprise Backup的核心特性，包括其物理备份的本质、对增量备份的支持以及执行热/温备份的能力。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n将MySQL Enterprise Backup定位为一个高级的“物理备份”解决方案。记住其关键特性：热备、增量、压缩、加密等。\n\n**学习建议:**\n学习MySQL Enterprise Backup (`mysqlbackup`) 的各种备份类型（完全、增量、差异）、特性（压缩、加密、TTL、乐观备份、传输表空间等）和操作（备份、准备、恢复）。了解其与不同存储引擎（特别是InnoDB）的交互方式。进行实际的备份恢复演练，熟悉其命令行选项和配置文件。"
    },
    {
        "question": "### 试题 218:\n\nWhich two types of logs can be stored in database tables?",
        "selections": {
            "A": "General query log",
            "B": "Slow query log",
            "C": "Binary log",
            "D": "Audit log",
            "E": "Relay log"
        },
        "answers": [
            "A",
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL 提供了多种类型的日志文件，用于记录数据库活动、错误、以及复制等信息。其中，有两类日志是可以选择存储在数据库表中的。\nA) **General query log（通用查询日志）(A 正确)。** 通用查询日志记录了 MySQL 服务器接收到的所有客户端连接和执行的 SQL 语句。它可以通过配置选择是写入文件（默认）还是写入名为 `mysql.general_log` 的数据库表。\nB) **Slow query log（慢查询日志）(B 正确)。** 慢查询日志记录了执行时间超过 `long_query_time` 系统变量值的 SQL 语句。它同样可以通过配置选择是写入文件（默认）还是写入名为 `mysql.slow_log` 的数据库表。\n\n错误选项分析：\nC) **Binary log（二进制日志）。** 二进制日志记录了所有更改数据或可能更改数据（例如DDL和DML语句）的事件，是数据恢复和复制的基础。它只能以二进制格式写入文件，不能存储在数据库表中。\nD) **Audit log（审计日志）。** 审计日志记录了数据库的安全相关事件，例如用户登录、数据访问等。虽然审计日志插件（如 MySQL Enterprise Audit）可以提供灵活的存储选项，但其主要设计是写入文件或专门的审计存储（如 syslog），而不是直接写入常规的数据库表 `mysql.audit_log`。核心的 MySQL Audit Log 插件通常写入文件。\nE) **Relay log（中继日志）。** 中继日志是 MySQL 复制过程中从主服务器复制到从服务器的二进制日志事件的副本。它由从服务器写入，并且只能以二进制格式写入文件，不能存储在数据库表中。\n\n**考点总结:**\n此题考察 MySQL 各种日志的存储方式和特点。核心考点在于区分哪些日志可以灵活配置存储在文件或数据库表中，以及哪些日志（特别是二进制日志和中继日志）只能存储在文件。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n在记忆 MySQL 日志类型时，将日志分为“记录操作或查询”和“用于复制/恢复”两大类。通常，“记录操作或查询”的日志（如通用查询日志和慢查询日志）在特定配置下可以存储在表中，而“用于复制/恢复”的日志（如二进制日志和中继日志）则只能是文件。\n\n**学习建议:**\n深入学习 MySQL 的各种日志：\n1.  **错误日志 (Error Log):** 记录服务器启动、关闭和运行过程中的错误、警告和事件。\n2.  **通用查询日志 (General Query Log):** 记录所有连接和执行的语句，了解其如何启用、存储位置（文件或表）以及对性能的影响。\n3.  **慢查询日志 (Slow Query Log):** 记录执行时间超过阈值的查询，了解其配置（`long_query_time`）、存储位置（文件或表）以及如何用于性能优化。\n4.  **二进制日志 (Binary Log):** 掌握其作用（数据恢复、复制）、格式以及无法存储在表中的原因。\n5.  **中继日志 (Relay Log):** 理解其在主从复制中的作用以及文件存储的特性。\n6.  **审计日志 (Audit Log):** 了解其目的和常见的实现方式（通常通过插件）。\n\n通过配置和实践不同日志的启用和查看，可以加深理解。"
    },
    {
        "question": "### 试题 219:\n\nExamine these queries and output:\n\n```sql\nmysql> EXPLAIN FORMAT=TREE SELECT * FROM city WHERE CountryCode LIKE 'A%'\n*************************** 1. row ***************************\nEXPLAIN: -> Index range scan on city using CountryCode, with index condition: (city.CountryCode like 'A%') (cost=129.41 rows=107)\n1 row in set (0.00 sec)\n\nmysql> EXPLAIN FORMAT=TREE SELECT * FROM city WHERE CountryCode LIKE 'C%'\n*************************** 1. row ***************************\nEXPLAIN: -> Filter: (city.CountryCode like 'C%') (cost=429.60 rows=551)\n-> Table scan on city (cost=429.60 rows=4046)\n1 row in set (0.00 sec)\n```\n\nThe `city` table is using the InnoDB storage engine.\n\nWhich statement is true?",
        "selections": {
            "A": "The `city` table has exactly 4046 rows.",
            "B": "The `CountryCode` index has no statistics.",
            "C": "The `CountryCode` index is a hash index.",
            "D": "The `CountryCode` column is the primary key of the `city` table.",
            "E": "The predicate `CountryCode LIKE 'A%'` is more selective than `CountryCode LIKE 'C%'`."
        },
        "answers": [
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n这道题目通过两个 `EXPLAIN FORMAT=TREE` 的输出，考察了 `MySQL` 优化器对 `LIKE` 查询的索引使用和选择性判断。`city` 表使用 `InnoDB` 存储引擎。\n\n**第一个 `EXPLAIN` (WHERE CountryCode LIKE 'A%'):**\n`EXPLAIN: -> Index range scan on city using CountryCode, with index condition: (city.CountryCode like 'A%') (cost=129.41 rows=107)`\n* `Index range scan`: 表示优化器使用了 `CountryCode` 列上的索引进行范围扫描。\n* `rows=107`: 优化器估计满足 `CountryCode LIKE 'A%'` 条件的行数为 107。\n\n**第二个 `EXPLAIN` (WHERE CountryCode LIKE 'C%'):**\n`EXPLAIN: -> Filter: (city.CountryCode like 'C%') (cost=429.60 rows=551)`\n`-> Table scan on city (cost=429.60 rows=4046)`\n* `Table scan on city`: 表示优化器选择了全表扫描，没有使用 `CountryCode` 上的索引。\n* `Filter: (city.CountryCode like 'C%')`: 表示在全表扫描后，MySQL 会对所有行进行过滤，以找出满足 `CountryCode LIKE 'C%'` 条件的行。\n* `rows=4046` (在 `Table scan` 行中): 这表示优化器估计 `city` 表的总行数为 4046。\n* `rows=551` (在 `Filter` 行中): 优化器估计满足 `CountryCode LIKE 'C%'` 条件的行数为 551。\n\n现在分析选项：\nA) **The `city` table has exactly 4046 rows。** 从第二个 `EXPLAIN` 的 `Table scan on city (cost=429.60 rows=4046)` 中可以看出，优化器估算的表总行数是 4046。虽然这不是“精确”的行数（`EXPLAIN` 中的 `rows` 是一个估算值），但在没有更精确信息的情况下，这是最接近的答案。然而，`EXPLAIN` 的 `rows` 是估算值，不保证精确，所以“exactly”一词使得这个选项存疑。\nB) **The `CountryCode` index has no statistics。** 如果索引没有统计信息，优化器通常很难做出有效的索引选择决策，或者会选择全表扫描。但在这里，对于 `LIKE 'A%'` 的查询，它使用了索引，这表明索引有足够的统计信息供优化器使用。如果完全没有统计信息，那么两个查询很可能都会进行全表扫描。\nC) **The `CountryCode` index is a hash index。** `InnoDB` 表默认使用 B-tree 索引。虽然 MySQL 支持哈希索引（例如 Memory 存储引擎或通过自适应哈希索引），但 `EXPLAIN` 输出中没有明确指示这是哈希索引。`Index range scan` 是 B-tree 索引的典型行为，而哈希索引通常用于等值查询（`=`），并且不支持范围扫描（`LIKE 'A%'`）。因此，此选项不正确。\nD) **The `CountryCode` column is the primary key of the `city` table。** 如果 `CountryCode` 是主键，那么 `SELECT * FROM city WHERE CountryCode LIKE 'A%'` 的 `EXPLAIN` 输出会显示 `const` 或 `eq_ref` 等更高效的访问类型，或者在 `PRIMARY` 索引上进行操作。这里显示的是 `Index range scan`，说明 `CountryCode` 可能是普通索引，而不是主键。\nE) **The predicate `CountryCode LIKE 'A%'` is more selective than `CountryCode LIKE 'C%'` (E 正确)。**\n* 对于 `LIKE 'A%'`，优化器估计结果集有 107 行。\n* 对于 `LIKE 'C%'`，优化器估计结果集有 551 行。\n选择性（Selectivity）是指谓词能够过滤掉的行数占总行数的比例，或者说，满足条件的行数占总行数的比例越小，选择性越高。107/4046 (约 2.6%) 明显小于 551/4046 (约 13.6%)。因此，`CountryCode LIKE 'A%'` 的选择性更高，这也是为什么优化器选择了索引扫描，因为它能更快地找到少量匹配的行；而 `CountryCode LIKE 'C%'` 的选择性较低，优化器认为全表扫描并过滤比索引扫描更高效。\n\n**考点总结:**\n此题考察 `MySQL EXPLAIN` 命令的输出解读，特别是关于：\n1.  **索引使用（Index Usage）：** 识别 `Index range scan` 和 `Table scan`。\n2.  **优化器估算（Optimizer Estimates）：** 理解 `rows` 字段表示优化器估算的行数。\n3.  **查询选择性（Query Selectivity）：** 如何通过估算行数判断谓词的选择性。\n4.  **索引类型和适用性：** `LIKE` 条件对索引使用的影响，以及 B-tree 索引与哈希索引的区别。\n5.  **主键索引的特性：** 了解主键索引通常的访问方式。\n\n理解优化器如何根据谓词的选择性来决定是否使用索引是解决此类问题的关键。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n仔细分析 `EXPLAIN` 输出中的 `type` (或 `FORMAT=TREE` 格式下的操作类型，如 `Index range scan`, `Table scan`) 和 `rows` 字段。`rows` 字段是优化器估算的行数，是判断选择性的直接依据。当 `rows` 估算值占总行数比例较小，且使用了索引时，通常表明选择性较高。\n\n**学习建议:**\n1.  **熟练掌握 `EXPLAIN` 命令:** 学习 `EXPLAIN` 的各种输出字段及其含义，特别是 `id`, `select_type`, `table`, `partitions`, `type`, `possible_keys`, `key`, `key_len`, `ref`, `rows`, `filtered`, `Extra` 等。`FORMAT=TREE` 是 MySQL 8.0 引入的新格式，也应熟悉。\n2.  **理解索引工作原理:** 深入理解 B-tree 索引的工作原理，以及它如何支持等值查询、范围查询（如 `LIKE 'prefix%'`）和排序。了解哈希索引的特点和局限性。\n3.  **掌握查询优化器原理:** 了解优化器如何根据表的统计信息（如行数、索引基数、数据分布）来估算查询成本，并选择最佳的执行计划。\n4.  **理解选择性（Selectivity）：** 它是数据库优化的一个核心概念。高选择性的查询（过滤掉大量数据）通常能更好地利用索引。\n5.  **实践 `LIKE` 查询和索引：** 通过实际操作，测试不同 `LIKE` 模式（如 `LIKE 'prefix%'` vs `LIKE '%suffix'` vs `LIKE '%pattern%'`）对索引使用的影响，并观察 `EXPLAIN` 输出的变化。"
    },
    {
        "question": "### 试题 220:\n\nExamine this command which executes successfully:\n\n```bash\nmysqlbackup --user=mysqlbackup --password --backup-image=/home/backup.mbi --backup-dir=/home/backupdir backup-to-image\n```\n\nWhich command restores the backup to the original data directory?",
        "selections": {
            "A": "`mysqlbackup --backup-dir=/home/backupdir copy-back`",
            "B": "`mysqlbackup --backup-dir=/home/backupdir apply-log`",
            "C": "`mysqlbackup --backup-dir=/home/backupdir --backup-image=/home/backup.mbi copy-back`",
            "D": "`mysqlbackup --backup-dir=/home/backupdir --backup-image=/home/backup.mbi copy-back-and-apply-log`",
            "E": "`mysqlbackup --backup-dir=/home/backupdir --backup-image=/home/backup.mbi extract`"
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n题目中给出的命令是使用 `mysqlbackup` 工具创建了一个“备份镜像”（backup image）。命令 `backup-to-image` 将数据库备份到一个单一的压缩文件中（即 `.mbi` 文件），同时将一些中间文件和元数据存储在 `--backup-dir` 指定的目录中。现在的问题是如何将这个备份还原到原始数据目录。\n\n`mysqlbackup` 的恢复过程通常分为两个阶段：\n1.  **准备阶段 (Preparation):** `apply-log` 或 `copy-back-and-apply-log`。这个阶段会应用备份期间产生的事务日志（redo log），使数据文件达到一致性状态。\n2.  **还原阶段 (Restore):** `copy-back`。这个阶段将准备好的数据文件从备份目录复制回 MySQL 的数据目录。\n\n分析选项：\nA) **`mysqlbackup --backup-dir=/home/backupdir copy-back`**：这个命令只执行 `copy-back` 操作。对于使用 `backup-to-image` 创建的 `.mbi` 备份，`copy-back` 操作需要知道备份镜像文件的位置。更重要的是，在复制回数据目录之前，备份数据通常需要经过 `apply-log` 阶段，使其处于一致状态。这个命令缺少 `apply-log` 步骤和 `backup-image` 参数。\nB) **`mysqlbackup --backup-dir=/home/backupdir apply-log`**：这个命令只执行 `apply-log` 操作。它通常是在 `backup-dir` 目录下对已解压的备份文件进行准备，使其达到一致性。然而，从 `.mbi` 文件恢复需要先将内容解压或使用能处理 `.mbi` 的操作。它缺少 `copy-back` 步骤和 `backup-image` 参数。\nC) **`mysqlbackup --backup-dir=/home/backupdir --backup-image=/home/backup.mbi copy-back`**：这个命令指定了 `backup-image` 并执行 `copy-back`。但是，它缺少了对日志进行应用（`apply-log`）的步骤。直接复制一个未经准备的物理备份可能导致数据不一致。\nD) **`mysqlbackup --backup-dir=/home/backupdir --backup-image=/home/backup.mbi copy-back-and-apply-log` (D 正确)。** `copy-back-and-apply-log` 是 `mysqlbackup` 提供的一个组合操作，它首先从 `backup-image` 文件中将数据复制到 `backup-dir`，然后立即对这些数据应用事务日志（redo log），使其达到一致状态，最后将准备好的数据复制到 MySQL 的数据目录。这个命令完整地处理了从备份镜像文件还原到原始数据目录所需的所有步骤：解压、准备和复制。\nE) **`mysqlbackup --backup-dir=/home/backupdir --backup-image=/home/backup.mbi extract`**：`extract` 命令用于将备份镜像文件 (`.mbi`) 的内容解压到指定的 `--backup-dir` 目录，但它不执行日志应用 (`apply-log`) 或复制到最终数据目录 (`copy-back`) 的步骤。它只是解压。\n\n**考点总结:**\n此题考察 `MySQL Enterprise Backup (MEB)` 中 `mysqlbackup` 命令的恢复流程，特别是从备份镜像文件 (`.mbi`) 进行恢复的完整步骤和相关参数。理解 `apply-log` 和 `copy-back` 在物理备份恢复中的作用，以及 `copy-back-and-apply-log` 作为一个组合操作的便利性是关键。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n对于 `mysqlbackup` 的恢复命令，记住两个核心步骤：**准备 (prepare / apply-log)** 和 **还原 (copy-back)**。当从 `.mbi` 文件恢复时，还需要指定 `backup-image`。`copy-back-and-apply-log` 是一个方便的组合命令，它集成了这两步（以及从镜像中解压），是物理备份恢复的常见做法。\n\n**学习建议:**\n1.  **了解 `mysqlbackup` 的备份类型:** 掌握 `backup-dir` (目录备份) 和 `backup-to-image` (镜像备份) 的区别。\n2.  **熟悉 `mysqlbackup` 的恢复流程:** 这是一个多阶段的过程。通常是 `backup` -> `apply-log` (或 `prepare`) -> `copy-back`。\n3.  **掌握关键的 `mysqlbackup` 恢复命令和参数：**\n    * `apply-log`：用于使备份数据一致。\n    * `copy-back`：用于将数据复制回 MySQL 的数据目录。\n    * `copy-back-and-apply-log`：用于一站式完成准备和复制。\n    * `extract`：用于从 `.mbi` 镜像中解压内容。\n    * `--backup-dir`: 指定备份的目录。\n    * `--backup-image`: 指定备份镜像文件。\n4.  **实践操作：** 最好能在测试环境中实际操作 `mysqlbackup` 的备份和恢复过程，加深理解。这将帮助你理解每个命令的作用和参数的必要性。"
    },
    {
        "question": "### 试题 221:\n\nWhich two are benefits of Group Replication over circular replication?",
        "selections": {
            "A": "Group Replication performs conflict resolution.",
            "B": "Group Replication supports all storage engines.",
            "C": "Group Replication detects and handles network partitioning.",
            "D": "Group Replication scales write operations.",
            "E": "Group Replication partitions data across multiple MySQL servers."
        },
        "answers": [
            "A",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL Group Replication (MGR) 是一种高可用性和高伸缩性的多主更新（multi-primary update）复制解决方案，它基于 Paxos 协议实现，提供了比传统循环复制（Circular Replication，通常指异步或半同步的主从复制链）更多的优势。\n\nA) **Group Replication performs conflict resolution (A 正确)。** MGR 的一个核心特性是内置了冲突检测和解决机制。当多个成员同时写入并导致冲突时（例如，对同一行进行不同修改），MGR 会自动检测并根据配置的策略（通常是“第一个提交者获胜”）来处理冲突，确保数据一致性。传统循环复制在多主写入时通常需要外部机制来处理冲突，或者根本不推荐多主写入。\n\nC) **Group Replication detects and handles network partitioning (C 正确)。** MGR 通过 Paxos 协议的分布式共识机制，能够检测并自动处理网络分区（split-brain）。当发生网络分区时，只有拥有大多数成员的分区才能继续执行写入操作，从而避免了数据不一致性。传统的主从复制在网络分区时可能导致脑裂，不同节点写入不同数据而无法同步。\n\n错误选项分析：\nB) **Group Replication supports all storage engines。** MGR **主要依赖 InnoDB 存储引擎**，因为它需要 InnoDB 的事务能力、行级锁定和二进制日志。虽然理论上可以与非事务性引擎（如 MyISAM）一起使用，但 MGR 的核心功能和数据一致性保证是基于 InnoDB 的。因此，说它支持“所有”存储引擎是不准确的，尤其是无法充分利用非事务性引擎的特性。\nD) **Group Replication scales write operations。** 虽然 MGR 支持多主写入（所有成员都可以接受写入请求），但由于其内部的原子性广播和共识协议（Paxos），**写入操作实际上是同步的，这意味着所有成员都需要对每笔事务达成共识，这在一定程度上限制了写入的吞吐量，并不会像分片（sharding）那样真正线性扩展写入能力。** MGR 更多是提供高可用性和读扩展，而非线性写扩展。线性写扩展通常通过分片实现。\nE) **Group Replication partitions data across multiple MySQL servers。** **数据分区（Data Partitioning）或分片（Sharding）是另外一种扩展数据库的方法**，它将数据分散存储在不同的独立服务器上。Group Replication 是一个复制技术，旨在提供相同数据集的高可用性和一致性，而不是将数据在不同服务器之间进行分区存储。两者是不同的概念和解决方案。\n\n**考点总结:**\n此题考察 MySQL Group Replication 相较于传统复制的主要优势，特别是其在**冲突解决、网络分区处理**以及高可用性方面的能力。理解 MGR 的设计目标和底层机制是关键。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n将 Group Replication 的优势与传统主从复制（异步/半同步）进行对比。重点关注 MGR 带来的分布式一致性、高可用性和多主写入能力。排除那些描述分片（Sharding）或通用安全/性能特性的选项。\n\n**学习建议:**\n1.  **理解 MGR 的核心概念:** 学习其成员资格服务、分布式共识协议（Paxos）、原子性广播以及冲突检测和解决机制。\n2.  **MGR 与传统复制的对比:** 明确 MGR 在高可用性、脑裂预防、自动化管理方面的优势。了解其多主更新模型（尽管写扩展受限）。\n3.  **MGR 的限制和适用场景:** 认识到 MGR 对 InnoDB 的依赖，以及其在写扩展方面的局限性。它更适合需要高可用性和数据强一致性的场景，而不是纯粹的线性写扩展。\n4.  **关注 MGR 的具体特性:** 例如，`single-primary` 模式与 `multi-primary` 模式的区别，以及故障转移和恢复的机制。\n5.  **阅读官方文档:** MySQL 官方文档是学习 Group Replication 最佳的资源，它提供了详细的配置、管理和最佳实践指南。"
    },
    {
        "question": "### 试题 222:\n\nAn application that is running on a Windows desktop needs to access data from a MySQL server running on a Linux server.\n\nWhich connection protocol must you use?",
        "selections": {
            "A": "UNIX socket",
            "B": "Named pipe",
            "C": "Shared memory",
            "D": "TCP/IP",
            "E": "UDP"
        },
        "answers": [
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n此题考察 MySQL 客户端与服务器之间的连接协议。关键信息是应用程序运行在 Windows 桌面，而 MySQL 服务器运行在 Linux 服务器上，这意味着它们是不同的机器，需要通过网络进行通信。\n\nA) **UNIX socket (A 错误)。** UNIX socket (Unix域套接字) 是一种用于**同一台机器上不同进程间通信**的机制。它通过文件系统路径来表示，无法用于跨网络的连接。Windows 系统也不直接支持 UNIX socket。\nB) **Named pipe (B 错误)。** 命名管道是一种主要用于 **Windows 操作系统上本地进程间通信**的机制。它通常用于在同一台 Windows 机器上连接 MySQL 客户端和服务器，不能用于跨操作系统的网络连接。\nC) **Shared memory (C 错误)。** 共享内存是一种允许**同一台机器上不同进程共享一块内存区域**以进行高效通信的机制。它也仅限于本地连接，无法用于跨网络的连接。\nD) **TCP/IP (D 正确)。** TCP/IP (传输控制协议/互联网协议) 是**互联网上最常用的通信协议栈**。它允许不同主机（无论是 Windows 还是 Linux）上的应用程序通过网络进行通信。MySQL 服务器通常监听一个 TCP 端口（默认为 3306），客户端通过 TCP/IP 连接到这个端口来访问数据库。\nE) **UDP (E 错误)。** UDP (用户数据报协议) 是一种**无连接的、不可靠的传输协议**。虽然它也可以用于网络通信，但 MySQL 客户端-服务器通信主要使用 TCP/IP，因为 TCP 提供了可靠的数据传输、流量控制和错误恢复机制，这对于数据库操作至关重要。UDP 不适用于这种需要可靠连接的场景。\n\n**考点总结:**\n此题考察 MySQL 客户端连接协议的基础知识，特别是区分本地连接协议（UNIX socket, Named pipe, Shared memory）和跨网络连接协议（TCP/IP）。理解不同协议的适用场景是关键。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n当题目描述的是**不同机器之间**的连接时，答案几乎总是 `TCP/IP`。本地连接选项（UNIX socket, Named pipe, Shared memory）适用于客户端和服务器运行在**同一台机器上**的情况。排除 UDP，因为它不提供可靠的数据传输，不适用于数据库连接。\n\n**学习建议:**\n1.  **深入理解 MySQL 连接协议:** 学习各种连接协议的特点和适用场景。\n    * **TCP/IP:** 默认且最常用的网络连接方式，用于跨主机连接。记住默认端口 3306。\n    * **UNIX socket:** Linux/Unix 系统本地连接的首选，高效。\n    * **Named pipe:** Windows 系统本地连接的一种方式。\n    * **Shared memory:** 仅限 Windows，在服务器和客户端在同一台机器时提供最高效的本地连接。\n2.  **配置 MySQL 监听:** 了解 `my.cnf` 或 `my.ini` 中如何配置 `bind-address` 来控制 MySQL 服务器监听哪些 IP 地址和端口，以及如何启用/禁用本地连接协议。\n3.  **客户端连接字符串:** 熟悉不同语言的 MySQL 客户端库如何构建连接字符串来指定连接协议、主机、端口等信息。"
    },
    {
        "question": "### 试题 223:\n\nMySQL 8.0 supports data-at-rest encryption.\n\nWhich three types of files can be encrypted?",
        "selections": {
            "A": "Error logs",
            "B": "General query logs",
            "C": "Slow query logs",
            "D": "Binary logs",
            "E": "InnoDB tablespaces",
            "F": "InnoDB redo logs",
            "G": "MyISAM tables"
        },
        "answers": [
            "D",
            "E",
            "F"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL 8.0 引入了**数据静态加密（Data-at-rest encryption）**功能，主要通过 `InnoDB` 表空间加密和二进制日志加密来实现，旨在提高数据的安全性，防止未经授权的物理访问导致数据泄露。加密通常由 Keyring 插件管理。\n\nD) **Binary logs (D 正确)。** MySQL 8.0 支持对二进制日志进行加密。二进制日志包含所有数据修改的事件，加密它们对于确保数据在传输和静态存储时的安全至关重要，尤其是在复制环境中。\nE) **InnoDB tablespaces (E 正确)。** `InnoDB` 表空间加密是 MySQL 8.0 静态数据加密的核心功能。它可以对独立的 `InnoDB` 表空间 (`.ibd` 文件) 和通用表空间中的数据进行加密，包括表数据、索引、undo logs 等。这意味着即使文件被非法获取，没有密钥也无法读取内容。\nF) **InnoDB redo logs (F 正确)。** `InnoDB` 重做日志 (`redo logs`) 记录了所有对 `InnoDB` 数据进行修改的物理操作。在 MySQL 8.0 中，`redo logs` 也可以被加密，这是确保数据库数据完整性和恢复能力的最后一道防线，因为它们包含了尚未写入数据文件的变更信息。\n\n错误选项分析：\nA) **Error logs (A 错误)。** 错误日志记录服务器的启动、关闭、警告和错误信息。这些日志通常是文本文件，MySQL 8.0 的静态加密功能不直接支持对其进行加密。日志的加密通常由操作系统层面的加密（如文件系统加密）或外部工具实现。\nB) **General query logs (B 错误)。** 通用查询日志记录了所有客户端连接和执行的 SQL 语句。与错误日志类似，它们通常是文本文件，不直接受 MySQL 8.0 静态加密功能的保护。如果存储在 `mysql.general_log` 表中，理论上如果表空间被加密，数据也会被加密，但通常我们谈论的是文件层面的加密。\nC) **Slow query logs (C 错误)。** 慢查询日志记录执行时间超过阈值的 SQL 语句。与通用查询日志和错误日志一样，它们通常是文本文件，不直接受 MySQL 8.0 静态加密功能的保护。\nG) **MyISAM tables (G 错误)。** `MySQL 8.0` 的静态加密功能主要针对 `InnoDB` 存储引擎。`MyISAM` 是一种非事务性存储引擎，**不直接支持表空间级别的加密**。`MyISAM` 表的数据文件通常是 `.MYD` 和 `.MYI` 文件，它们不包含在 `InnoDB` 的加密范畴内。如果需要加密 `MyISAM` 数据，通常需要依赖文件系统级别的加密。\n\n**考点总结:**\n此题考察 MySQL 8.0 静态数据加密（Data-at-rest encryption）的具体范围。核心考点在于识别哪些是 `InnoDB` 相关的关键数据文件和二进制日志，它们是该加密功能的主要目标，而其他类型的文本日志和非 `InnoDB` 表（如 `MyISAM`）则不直接支持。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n记住 `MySQL 8.0` 的静态加密主要集中在**事务性存储引擎（尤其是 `InnoDB`）**和**二进制日志**。对于普通文本日志（如错误日志、查询日志、慢日志）和非事务性存储引擎（如 `MyISAM`），MySQL 自身的加密功能不直接适用。\n\n**学习建议:**\n1.  **理解静态加密的目标：** 为什么需要静态加密？它保护的是什么（主要是数据文件和日志文件，以防物理泄露）。\n2.  **了解 MySQL 的 Keyring 插件：** 这是实现静态加密的关键组件，用于管理加密密钥。\n3.  **区分可加密和不可加密的文件类型：**\n    * **可加密：** `InnoDB` 表空间（包括独立表空间和通用表空间）、`InnoDB` 重做日志、二进制日志。\n    * **不可直接加密（通过 MySQL 自身功能）：** 错误日志、通用查询日志、慢查询日志（通常为文本文件）、`MyISAM` 表文件、`CSV` 等其他存储引擎的文件。\n4.  **掌握相关系统变量和配置：** 了解如何启用和配置静态加密，例如 `innodb_encrypt_tablespaces`、`binlog_encryption` 等。\n5.  **安全最佳实践：** 了解除了静态加密，还有哪些安全措施（如传输加密、访问控制、审计日志）可以提高 MySQL 数据库的整体安全性。"
    },
    {
        "question": "### 试题 224:\n\nExamine this statement and output:\n\n```sql\nmysql> SET log_slave_updates=0;\nERROR 1238 (HY000): Variable 'log_slave_updates' is a read only variable\n```\n\nWhich method changes `log_slave_updates` to 0 immediately?",
        "selections": {
            "A": "`SET GLOBAL log_slave_updates=0;`",
            "B": "`SET PERSIST log_slave_updates=0;`",
            "C": "`SET PERSIST_ONLY log_slave_updates=0;`",
            "D": "`SET PERSIST log_slave_updates=0; RESTART;`",
            "E": "`SET PERSIST_ONLY log_slave_updates=0; RESTART;`"
        },
        "answers": [
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n题目中显示 `SET log_slave_updates=0;` 报错 `ERROR 1238 (HY000): Variable 'log_slave_updates' is a read only variable`。这意味着 `log_slave_updates` 是一个只读系统变量，不能在运行时通过 `SET` 命令直接修改（即使是 `SET GLOBAL` 也不行）。对于这类只读变量，通常需要在 MySQL 服务器启动时在配置文件（如 `my.cnf` 或 `my.ini`）中设置，或者使用 `SET PERSIST` 系列命令将其持久化到 `mysqld-auto.cnf` 文件中，然后在**下次重启服务器后**才能生效。\n\n`log_slave_updates` 这个变量控制从服务器是否将其收到的（和执行的）事件写入自己的二进制日志。将其设置为 0 意味着从服务器不会将其复制操作记录到自己的二进制日志中，这在某些级联复制或特定备份场景中可能会用到。\n\n分析选项：\nA) **`SET GLOBAL log_slave_updates=0;` (A 错误)。** `SET GLOBAL` 用于修改当前运行服务器的全局变量值。但由于 `log_slave_updates` 是一个只读变量，此命令会像题目中 `SET` 命令一样报错，无法立即修改。\nB) **`SET PERSIST log_slave_updates=0;` (B 错误)。** `SET PERSIST` 命令用于将系统变量的值写入 `mysqld-auto.cnf` 文件，使其在服务器重启后生效。虽然它能持久化设置，但对于只读变量，它**不能立即生效**。命令执行时会提示变量是只读的，且需要重启才能生效。\nC) **`SET PERSIST_ONLY log_slave_updates=0;` (C 错误)。** `SET PERSIST_ONLY` 同样用于持久化变量设置到 `mysqld-auto.cnf` 文件，与 `SET PERSIST` 的主要区别在于它**只持久化，不尝试立即修改当前会话或全局值**。因此，它也不能“立即”改变只读变量的值。它依然需要重启才能生效。\nD) **`SET PERSIST log_slave_updates=0; RESTART;` (D 错误)。** `RESTART` 并不是 `SET PERSIST` 命令的一部分。`SET PERSIST` 是一个 SQL 命令，`RESTART` 是一个 SQL 命令，它们是独立的。虽然 `SET PERSIST` 之后需要重启，但将 `RESTART` 直接写在同一个 SQL 语句中是语法错误的。而且，即使能够这样写，也不是 `SET PERSIST` 命令本身能“立即”改变值，而是“重启”这个动作改变的。\nE) **`SET PERSIST_ONLY log_slave_updates=0; RESTART;` (E 正确)。** 就像上面分析的，`log_slave_updates` 是一个只读变量，不能在运行时直接修改。要使其生效，必须：\n    1.  通过 `SET PERSIST_ONLY` (或 `SET PERSIST`) 将新值写入配置文件，以便持久化。\n    2.  **重启 MySQL 服务器**。只有重启后，服务器才会读取新的配置值并应用它。因此，`SET PERSIST_ONLY log_slave_updates=0;` 后跟着执行服务器 `RESTART` 操作（这是通过操作系统或服务管理工具完成的，而非 SQL 命令），是改变这个只读变量并使其立即生效的唯一方法（从服务器的角度看，“立即生效”指的是重启后）。选项中将 `RESTART` 以这种方式呈现，暗示了这是一个需要在命令执行后进行的独立操作。\n\n**考点总结:**\n此题考察 `MySQL` 系统变量的类型（特别是只读变量）以及 `SET`、`SET GLOBAL`、`SET PERSIST`、`SET PERSIST_ONLY` 命令的用法和区别。核心考点是理解对于只读变量，**任何运行时修改都无效，必须通过修改配置文件并在服务器重启后才能生效**。`SET PERSIST_ONLY` 专门用于这种情况，因为它不尝试在运行时修改当前值，只负责持久化。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n遇到 `Variable '...' is a read only variable` 错误时，立即想到需要**重启**才能使变量生效。`SET PERSIST` 和 `SET PERSIST_ONLY` 的作用是持久化配置，本身不会让只读变量立即生效。选项中包含 `RESTART` 的往往是正确方向，但要注意 `RESTART` 通常不是 SQL 命令的一部分，而是独立的服务器操作。\n\n**学习建议:**\n1.  **系统变量分类：** 学习 `MySQL` 系统变量的范围（GLOBAL, SESSION）和类型（动态可修改、只读）。\n2.  **`SET` 命令家族：**\n    * `SET variable = value;` (SESSION 级别)\n    * `SET GLOBAL variable = value;` (GLOBAL 级别，影响后续连接)\n    * `SET PERSIST variable = value;` (GLOBAL 级别，同时持久化到 `mysqld-auto.cnf`，并尝试立即生效)\n    * `SET PERSIST_ONLY variable = value;` (只持久化到 `mysqld-auto.cnf`，不尝试立即修改当前值)\n3.  **配置文件 (`my.cnf`) 和 `mysqld-auto.cnf`：** 理解它们在 `MySQL` 配置中的作用，以及 `SET PERSIST` 系列命令对 `mysqld-auto.cnf` 的影响。\n4.  **服务器重启的重要性：** 明确哪些变量的更改需要重启服务器才能生效。"
    },
    {
        "question": "### 试题 225:\n\nWhich two statements are true about multisource replication?",
        "selections": {
            "A": "Each channel has its own IO thread.",
            "B": "Each channel has its own master.info file.",
            "C": "All channels share one SQL thread.",
            "D": "All channels share the same relay log files.",
            "E": "Each source server has a binary log dump thread."
        },
        "answers": [
            "A",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\nMySQL 多源复制（Multisource Replication）允许一个从服务器从多个主服务器接收并应用二进制日志事件。这在合并多个数据源或构建数据仓库等场景中非常有用。\n\nA) **Each channel has its own IO thread (A 正确)。** 在多源复制中，每个复制通道（channel）对应一个独立的主服务器。为了从各自的主服务器获取二进制日志事件，每个通道都会启动一个独立的 I/O 线程（`Receiver_IO_thread`），负责连接主服务器并读取其二进制日志事件。\n\nE) **Each source server has a binary log dump thread (E 正确)。** 二进制日志 dump 线程 (`Binlog Dump thread`) 是在**主服务器**上运行的。每当一个从服务器连接到主服务器并请求二进制日志事件时，主服务器就会为该从服务器启动一个独立的 `Binlog Dump thread`。因此，如果一个主服务器有多个从服务器连接（包括多个多源复制的通道），它就会有多个 `Binlog Dump thread`。这适用于所有类型的 MySQL 复制，包括多源复制。\n\n错误选项分析：\nB) **Each channel has its own master.info file。** `master.info` 文件（在 MySQL 8.0 中通常是 `mysql.slave_master_info` 表）用于存储从服务器连接到主服务器的信息，例如主服务器的地址、端口、用户名、密码以及从服务器读取到的二进制日志文件名和位置。在多源复制中，这些信息是针对**每个通道**独立存储的。所以，更准确的说法是每个通道有自己独立的存储来记录这些信息，而不是一个独立的 `master.info` 文件（如果以文件形式存在，通常只有一个文件包含所有通道信息，或者说每个通道的元数据单独存储）。但在 MySQL 8.0 中，这些信息存储在 `mysql.slave_master_info` 和 `mysql.slave_relay_log_info` 表中，每个通道在这些表中都有独立的记录，而不是独立的文件。\nC) **All channels share one SQL thread。** **这是错误的。** 在多源复制中，虽然早期版本可能存在单 SQL 线程的限制，但在现代 MySQL 版本（尤其是支持多源复制的版本）中，为了并行应用来自不同源的事件，**每个通道都有自己的 SQL 线程**（`Applier_SQL_thread`）。这样可以避免单个 SQL 线程成为瓶颈，提高应用效率。\nD) **All channels share the same relay log files。** **这是错误的。** 每个通道都有自己的**独立的**中继日志文件集。这是为了确保不同主服务器的事件流可以独立管理和应用，防止混淆和冲突。中继日志文件存储在从服务器的数据目录下，通常以 `relay-log.index` 文件来索引，并且每个通道都有自己的索引文件和对应的中继日志文件。\n\n**考点总结:**\n此题考察 `MySQL` 多源复制的架构和工作原理，特别是不同线程和文件在多通道环境下的独立性。核心考点在于理解每个复制通道的资源（I/O 线程、SQL 线程、中继日志）都是独立的，而主服务器的二进制日志 `dump` 线程是为每个连接的从服务器独立生成的。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n理解多源复制的核心是**“通道（Channel）”**的概念。每个通道可以看作是独立的单源复制实例。因此，与特定源（主服务器）相关的资源（如 I/O 线程、SQL 线程、中继日志）通常都是**通道级别独立**的。二进制日志 `dump` 线程是主服务器为每个从服务器连接生成的。\n\n**学习建议:**\n1.  **深入理解 MySQL 复制的基本架构：** 掌握主服务器的二进制日志、主服务器的 `Binlog Dump thread`、从服务器的 I/O 线程、从服务器的 SQL 线程、以及从服务器的中继日志。\n2.  **学习多源复制的概念：** 理解“通道”在多源复制中的作用，它如何将来自不同主服务器的事件流隔离开。\n3.  **区分各线程和文件的归属：**\n    * **主服务器：** `Binlog Dump thread`（每个连接的从服务器一个）。\n    * **从服务器（多源复制）：**\n        * I/O 线程：每个通道一个。\n        * SQL 线程：每个通道一个。\n        * 中继日志：每个通道独立一套。\n        * `master.info` / `slave_master_info`：信息存储针对每个通道独立记录。\n4.  **实践多源复制配置：** 通过实际配置和运行多源复制，可以更直观地理解其工作原理和各组件之间的关系。"
    },
    {
        "question": "### 试题 226:\n\nWhich type of file is required to perform a point-in-time recovery?",
        "selections": {
            "A": "InnoDB redo log",
            "B": "InnoDB undo log",
            "C": "Binary log",
            "D": "Relay log",
            "E": "General query log"
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n**时间点恢复 (Point-in-Time Recovery, PITR)** 是指将数据库恢复到在某个特定时间点或特定事件之前/之后的状态。这种恢复能力是数据库备份和恢复策略的关键组成部分，它允许用户从数据损坏、意外删除或逻辑错误中恢复，而不仅仅是恢复到最近一次全备份的状态。\n\nC) **Binary log (C 正确)。** 二进制日志（Binary Log，通常简称为 Binlog）是进行时间点恢复的**核心文件**。它记录了所有更改数据库数据或结构的事件（如 INSERT, UPDATE, DELETE, DDL语句）。时间点恢复的基本步骤是：\n1.  恢复到最近一次的**完整备份**（可以是物理备份或逻辑备份）。\n2.  然后，从完整备份的时间点开始，**重放二进制日志中记录的事件**，直到目标时间点或事件。通过这种方式，可以精确地将数据库恢复到过去的任意一个时间点，从而实现精细化的数据恢复。\n\n错误选项分析：\nA) **InnoDB redo log (A 错误)。** `InnoDB redo log` (重做日志) 主要用于确保事务的持久性（crash recovery）。它记录了 `InnoDB` 存储引擎的物理数据页修改，用于在数据库崩溃后恢复未完成的事务，使数据达到一致状态。它不用于回放历史操作到特定时间点，其内容是循环写入的，并且在崩溃恢复后通常会被截断或重用。\nB) **InnoDB undo log (B 错误)。** `InnoDB undo log` (撤销日志) 主要用于事务回滚（rollback）、MVCC（多版本并发控制）以及崩溃恢复。它记录了事务修改数据之前的状态，以便在事务回滚时恢复数据。它也不用于时间点恢复。\nD) **Relay log (D 错误)。** 中继日志是 MySQL 复制过程中，从服务器从主服务器接收并存储二进制日志事件的临时文件。虽然它包含了需要应用的事件，但它是从服务器的本地缓存，其内容是动态变化的，并且在应用后通常会被删除。进行时间点恢复时，需要的是**主服务器的原始二进制日志**，而不是从服务器的中继日志。\nE) **General query log (E 错误)。** 通用查询日志记录了所有客户端的连接和 SQL 语句。它主要用于调试和审计，不包含用于数据恢复所需的操作的精确、完整和原子性的记录，也不是事务性的。因此，它无法用于时间点恢复。\n\n**考点总结:**\n此题考察 `MySQL` 备份与恢复的核心概念，特别是**时间点恢复**对**二进制日志**的依赖性。理解二进制日志作为数据库变更的完整和有序记录的重要性是关键。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n在关于 `MySQL` 备份和恢复的题目中，凡是涉及到**“时间点恢复”**或**“前滚操作 (roll-forward)”**，答案几乎总是**二进制日志 (Binary Log)**。其他日志（`redo log`, `undo log`, `relay log` 等）各有其特定用途，但都不直接用于这种类型的恢复。\n\n**学习建议:**\n1.  **深入理解 `MySQL` 的备份类型：**\n    * **物理备份：** 直接复制数据文件（如 `mysqlbackup`）。\n    * **逻辑备份：** 导出 `SQL` 语句（如 `mysqldump`）。\n2.  **掌握 `MySQL` 恢复机制：**\n    * **完整恢复：** 使用完整备份进行恢复。\n    * **时间点恢复 (PITR)：** 在完整备份的基础上，结合二进制日志进行前滚，达到指定时间点或事件。\n3.  **区分各种日志的作用：**\n    * **二进制日志 (Binary Log):** 事务性事件的完整记录，用于复制和时间点恢复。\n    * **重做日志 (Redo Log):** `InnoDB` 崩溃恢复的关键，确保持久性。\n    * **撤销日志 (Undo Log):** `InnoDB` 事务回滚和 `MVCC` 的基础。\n    * **中继日志 (Relay Log):** 从服务器用于缓存主服务器二进制日志事件的临时文件。\n    * **错误日志 (Error Log):** 记录服务器错误、启动关闭信息。\n    * **通用查询日志 (General Query Log):** 记录所有 SQL 语句。\n    * **慢查询日志 (Slow Query Log):** 记录执行慢的 SQL 语句。\n4.  **实践恢复操作：** 通过模拟数据库崩溃和数据丢失，练习使用备份和二进制日志进行时间点恢复，这将极大加深你的理解。"
    },
    {
        "question": "### 试题 227:\n\nWhere is the MySQL data dictionary stored?",
        "selections": {
            "A": "InnoDB tables",
            "B": "JSON formatted text files",
            "C": "Text files containing SQL statements",
            "D": "Combinations of binary and text files"
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`MySQL` 的数据字典（Data Dictionary）存储了关于数据库对象（如表、视图、存储过程、函数、索引等）的元数据。从 `MySQL 8.0` 开始，数据字典的存储方式发生了重大变化，以提高原子性、一致性、持久性和隔离性（ACID）。\n\nA) **InnoDB tables (A 正确)。** 在 `MySQL 8.0` 及更高版本中，数据字典被重新设计并存储在**持久的 `InnoDB` 表中**。这些表位于 `mysql` 系统数据库中，通常使用加密。这种设计确保了数据字典本身是事务性的，并且可以从崩溃中安全恢复，提供更好的数据一致性和可靠性。\n\n错误选项分析：\nB) **JSON formatted text files (B 错误)。** 尽管 `MySQL` 在某些场景下会使用 `JSON` 格式（例如 `EXPLAIN` 输出或文档存储），但数据字典的核心元数据不以 `JSON` 格式的文本文件存储。以前的 `.frm` 文件包含一些表定义信息，但这些也不是 `JSON` 格式。\nC) **Text files containing SQL statements (C 错误)。** 文本文件包含 `SQL` 语句通常是用于导入或导出数据/结构，而不是 `MySQL` 内部存储数据字典的方式。\nD) **Combinations of binary and text files (D 错误)。** 在 `MySQL 8.0` 之前，数据字典信息分散在多种文件类型中，包括 `.frm` 文件（存储表定义，是二进制格式）、`InnoDB` 内部系统表空间（包含 `InnoDB` 表的元数据）以及 `mysql` 数据库中的某些表（如 `mysql.table_definitions`）。然而，`MySQL 8.0` 的目标就是将这些分散的元数据统一存储在 `InnoDB` 表中，从而避免了这种“组合”的复杂性和潜在不一致性。\n\n**考点总结:**\n此题考察 `MySQL` 数据字典的存储方式，特别是 `MySQL 8.0` 版本后的重要变化。核心考点在于理解 `MySQL 8.0` 将数据字典统一存储在 `InnoDB` 表中，以实现 `ACID` 特性和更高的可靠性。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n对于 `MySQL 8.0` 之后的版本，记住其重要的架构改进之一就是**将数据字典存储在 `InnoDB` 表中**。这与早期版本的数据字典分散在文件和旧版系统表中的方式有根本区别。\n\n**学习建议:**\n1.  **理解数据字典的作用：** 它是数据库的元数据存储，描述了数据库中所有对象的结构和属性。\n2.  **了解 `MySQL 8.0` 数据字典的改进：** 重点学习为什么 `Oracle` 决定重构数据字典，以及将其存储在 `InnoDB` 表中带来的好处（如事务性、原子性、崩溃恢复能力、更好的并发性等）。\n3.  **区分不同版本的存储方式：** 了解 `MySQL 8.0` 之前数据字典的存储方式（`.frm` 文件、`InnoDB` 内部数据字典等），以及 `MySQL 8.0` 如何统一这些存储。\n4.  **不要与 `information_schema` 混淆：** `information_schema` 是一个虚拟数据库，提供对数据字典信息的标准 SQL 访问接口，它本身不存储数据，而是从底层的数据字典获取信息。"
    },
    {
        "question": "### 试题 228:\n\nExamine these entries from the general log:\n\n```\nTime                     Id  Command  Argument\n2020-08-06T06:52:10.893454Z 17  Query    START TRANSACTION\n2020-08-06T06:52:56.129623Z 20  Query    START TRANSACTION\n2020-08-06T06:53:42.832127Z 17  Query    UPDATE db.t SET c=1 WHERE id=10\n2020-08-06T06:54:09.162324Z 20  Query    SELECT * FROM db.t WHERE id<25\n2020-08-06T06:55:01.263298Z 17  Query    UPDATE db.t SET c=1 WHERE id=20\n```\n\nThe server has only two sessions at this time. The `db.t` table uses the `InnoDB` storage engine and all `UPDATE` statements reference existing rows. The `id` column is the primary key. Which describes the outcome of the sequence of statements?",
        "selections": {
            "A": "Connection 17 has to wait for connection 20.",
            "B": "Connection 20 has to wait for connection 17.",
            "C": "All statements execute without waiting."
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n这道题目考察对 `InnoDB` 事务和行级锁的理解。在 `InnoDB` 中，`UPDATE` 语句通常会对被修改的行施加排他锁（X-lock），以防止其他事务同时修改这些行。`SELECT` 语句在默认的 `REPEATABLE READ` 隔离级别下，如果是普通 `SELECT`（非 `FOR UPDATE` 或 `FOR SHARE`），则通常使用快照读（snapshot read），不会加锁，因此不会阻塞写入。\n\n分析日志中的事件：\n1.  **`2020-08-06T06:52:10.893454Z 17 Query START TRANSACTION`**: 连接 17 开启事务。\n2.  **`2020-08-06T06:52:56.129623Z 20 Query START TRANSACTION`**: 连接 20 开启事务。\n3.  **`2020-08-06T06:53:42.832127Z 17 Query UPDATE db.t SET c=1 WHERE id=10`**: 连接 17 更新 `id=10` 的行。此时，连接 17 会对 `id=10` 的行施加排他锁。\n4.  **`2020-08-06T06:54:09.162324Z 20 Query SELECT * FROM db.t WHERE id<25`**: 连接 20 执行一个 `SELECT` 语句。这个 `SELECT` 语句是一个普通查询，它不会对 `id<25` 的行加锁，而是通过 `MVCC` 读取一个历史快照。因此，即使连接 17 持有 `id=10` 的锁，连接 20 的 `SELECT` 也不会被阻塞。\n5.  **`2020-08-06T06:55:01.263298Z 17 Query UPDATE db.t SET c=1 WHERE id=20`**: 连接 17 更新 `id=20` 的行。`id=20` 的行与连接 17 之前更新的 `id=10` 以及连接 20 查询的范围 `id<25` 并不直接冲突。连接 17 已经持有 `id=10` 的锁，现在它试图获取 `id=20` 的锁。由于连接 20 并没有对 `id=20` 加锁（它只是一个普通 `SELECT`），并且 `id=20` 与 `id=10` 是不同的行，因此连接 17 在更新 `id=20` 时不会被阻塞。\n\n结论是，连接 17 和连接 20 执行的操作不会相互阻塞，因为它们操作的行不冲突（`UPDATE` 不同行），并且 `SELECT` 语句是快照读（不加锁）。\n\nC) **All statements execute without waiting (C 正确)。** 根据上述分析，由于 `SELECT` 语句不会加锁，并且两个 `UPDATE` 语句操作的是 `InnoDB` 不同行（通过主键 `id` 区分），它们之间不会产生锁冲突，因此所有语句都会立即执行，不会有等待情况发生。\n\n错误选项分析：\nA) **Connection 17 has to wait for connection 20。** 错误，连接 20 是 `SELECT` 操作，不会持有锁来阻塞连接 17 的 `UPDATE`。\nB) **Connection 20 has to wait for connection 17。** 错误，连接 20 的 `SELECT` 是快照读，不会被连接 17 对 `id=10` 的锁阻塞。\n\n**考点总结:**\n此题考察 `InnoDB` 存储引擎的**行级锁机制**和**多版本并发控制 (MVCC)**。关键点在于理解：\n* `UPDATE` 语句会对所修改的行加排他锁。\n* 默认隔离级别下，普通 `SELECT` 语句（非 `FOR UPDATE`/`FOR SHARE`）使用 `MVCC` 进行快照读，不加锁，因此不会被其他事务的写锁阻塞，也不会阻塞其他事务。\n* `InnoDB` 的锁是行级的，不同行的并发修改通常不会相互阻塞。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n在分析事务并发和锁等待问题时，首先识别语句类型：`SELECT` 通常是读操作，默认不加锁；`UPDATE/DELETE/INSERT` 是写操作，会加锁。其次，判断操作的**具体资源**是否冲突（例如，是否操作同一行）。`InnoDB` 是行级锁，精确到行。\n\n**学习建议:**\n1.  **深入理解 `InnoDB` 的事务特性：** 学习 `ACID` 特性，特别是隔离性（Isolation）。\n2.  **掌握 `InnoDB` 的锁机制：** 了解行级锁（Record Lock, Gap Lock, Next-Key Lock）、意向锁（Intention Lock）以及共享锁（S-lock）和排他锁（X-lock）的概念和用途。\n3.  **理解 `MVCC`：** 学习 `InnoDB` 如何通过 `MVCC`（多版本并发控制）实现读写不阻塞，特别是在 `READ COMMITTED` 和 `REPEATABLE READ` 隔离级别下的快照读。\n4.  **不同隔离级别的影响：** 了解 `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE` 这些隔离级别对锁行为和并发性的影响。\n5.  **实践：** 通过实际执行 `SQL` 语句，并结合 `SHOW ENGINE INNODB STATUS` 或 `performance_schema` 中的锁信息，观察并发操作时的锁等待情况，加深理解。"
    },
    {
        "question": "### 试题 229:\n\nWhich three statements are true about InnoDB files?",
        "selections": {
            "A": "InnoDB redo logs are stored in binary log files.",
            "B": "InnoDB undo logs are stored in the system tablespace.",
            "C": "MySQL data dictionary tables are stored in the mysql.ibd file.",
            "D": "A general tablespace consists of only one file.",
            "E": "A file-per-table tablespace can store only one table.",
            "F": "All InnoDB files must be stored in the data directory."
        },
        "answers": [
            "C",
            "D",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n这道题目考察对 `InnoDB` 存储引擎文件结构和管理方式的理解。\n\nC) **MySQL data dictionary tables are stored in the `mysql.ibd` file (C 正确)。** 在 `MySQL 8.0` 及更高版本中，`MySQL` 的数据字典（包括所有数据库对象的元数据）被统一存储在 `mysql` 系统数据库中，这些系统表本身就是 `InnoDB` 表，它们的数据存储在 `InnoDB` 系统表空间文件 `ibdata1`（或配置的系统表空间文件）以及 `mysql` 数据库对应的 `.ibd` 文件中。题目中的 `mysql.ibd` 指的是 `mysql` 数据库下的表所对应的文件，**数据字典的核心表（如 `mysql.dd_tables` 等）确实存储在 `InnoDB` 表中，其文件位于数据目录下 `mysql` 目录下的 `.ibd` 文件中**。例如，`mysql.dd_tables.ibd`，`mysql.dd_columns.ibd` 等。\n\nD) **A general tablespace consists of only one file (D 正确)。** 通用表空间（General Tablespace）是 `MySQL 5.7.24` 和 `8.0` 引入的新特性，允许用户在一个共享的 `InnoDB` 文件中存储多个表。一个通用表空间在创建时只对应一个物理文件（例如 `my_general_tablespace.ibd`），并且这个文件是不会自动分裂成多个文件的。它作为一个整体来管理。\n\nE) **A file-per-table tablespace can store only one table (E 正确)。** 按表文件（`file-per-table`）表空间是 `InnoDB` 的默认行为（通过 `innodb_file_per_table=ON` 控制），意味着每个 `InnoDB` 表都拥有一个独立的 `.ibd` 文件。这个 `.ibd` 文件只包含对应表的数据和索引，因此每个文件只存储一个表。\n\n错误选项分析：\nA) **InnoDB redo logs are stored in binary log files。** `InnoDB redo logs`（通常是 `ib_logfile0`, `ib_logfile1` 等）和二进制日志 (`binary log`，通常是 `mysql-bin.xxxxxx`）是**两种完全独立的文件**。`redo log` 记录 `InnoDB` 存储引擎的物理更改，用于崩溃恢复；`binary log` 记录所有数据库的逻辑更改，用于复制和时间点恢复。它们有不同的作用和存储格式，不会存储在一起。\nB) **InnoDB undo logs are stored in the system tablespace。** 在 `MySQL 5.7` 之前，`undo logs` 的确存储在系统表空间 (`ibdata1`) 中。然而，从 `MySQL 5.7` 开始，`undo logs` 可以配置为存储在独立的 `undo` 表空间文件 (`undo_001.ibd`, `undo_002.ibd` 等) 中，**并且这是推荐和默认的做法**，尤其是在 `MySQL 8.0` 中，默认就是独立的 `undo` 表空间。因此，说它们“存储在系统表空间”是不全面的，甚至可能是错误的描述，因为它通常在独立文件中。\nF) **All InnoDB files must be stored in the data directory。** 大多数 `InnoDB` 文件（如 `.ibd` 文件、`redo log`、`undo log` 等）默认存储在数据目录下。然而，用户可以通过配置参数（如 `innodb_data_home_dir`、`innodb_log_group_home_dir`、`innodb_undo_directory` 等）将这些文件存储在**数据目录以外的其他位置**。因此，“所有 `InnoDB` 文件必须”是一个过于绝对的说法，是不正确的。\n\n**考点总结:**\n此题考察 `InnoDB` 存储引擎的文件结构和管理方式，特别是对 `MySQL 8.0` 中 `InnoDB` 文件系统的一些新特性和最佳实践的理解。核心考点包括 `redo log` 与 `binary log` 的区别、数据字典的存储、通用表空间和按表文件表空间的特性，以及文件存储位置的灵活性。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n对于 `InnoDB` 文件的特性，注意区分不同日志的作用。重点关注 `MySQL 8.0` 引入的新特性（如数据字典的 `InnoDB` 化、通用表空间）。“所有/必须”这类绝对词通常会提示选项可能是错误的。\n\n**学习建议:**\n1.  **深入学习 `InnoDB` 文件结构：**\n    * **系统表空间 (`ibdata1`):** 曾经存储所有 `InnoDB` 数据、索引、`undo log` 和数据字典。现在主要存储共享信息。\n    * **独立表空间 (`.ibd` 文件):** `innodb_file_per_table=ON` 时，每个表一个 `.ibd` 文件，包含数据和索引。\n    * **通用表空间 (`.ibd` 文件):** 存储多个表的共享表空间。\n    * **临时表空间 (`ibtmp1`):** 用于内部临时表。\n    * **重做日志 (`redo log`):** `ib_logfileX`，用于崩溃恢复。\n    * **撤销日志 (`undo log`):** `undo_00X.ibd`，用于事务回滚和 `MVCC`。\n2.  **理解 `MySQL 8.0` 的变化：** 重点是数据字典的 `InnoDB` 化和 `undo log` 的独立表空间化。\n3.  **区分不同日志文件的作用：** `redo log`、`undo log` 和 `binary log` 是三个最常混淆的日志文件，理解它们各自的职责。\n4.  **掌握文件存储位置的配置：** 了解如何通过 `my.cnf` 配置 `InnoDB` 文件的存储位置。"
    },
    {
        "question": "### 试题 230:\n\nYou want to change your own MySQL password. Which two methods can you use?",
        "selections": {
            "A": "The `ALTER USER` statement",
            "B": "The `GRANT` statement",
            "C": "The `mysqladmin` client program",
            "D": "The `mysql_config_editor` utility",
            "E": "The `mysql_secure_installation` utility"
        },
        "answers": [
            "A",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n这道题目考察 `MySQL` 中修改用户密码的常用方法。\n\nA) **The `ALTER USER` statement (A 正确)。** `ALTER USER` 语句是 `MySQL` 中修改用户属性（包括密码）的标准 SQL 命令。例如：`ALTER USER 'username'@'localhost' IDENTIFIED BY 'new_password';` 这是一个推荐且常用的方法，因为它直接在数据库中操作。\nC) **The `mysqladmin` client program (C 正确)。** `mysqladmin` 是 `MySQL` 附带的一个命令行管理工具，可以执行各种管理操作，包括修改密码。使用 `mysqladmin` 修改密码的命令通常是：`mysqladmin -u username -p password old_password new_password`。这是一个在命令行环境下方便且常用的方法。\n\n错误选项分析：\nB) **The `GRANT` statement (B 错误)。** `GRANT` 语句主要用于授予用户权限。虽然在 `MySQL` 较早的版本中，`GRANT ... IDENTIFIED BY ...` 语句可以在创建用户时设置密码，或者在某些情况下修改密码，但在现代 `MySQL` 版本中（尤其是在 `MySQL 8.0` 中），`ALTER USER` 是修改密码的推荐和更明确的语句。直接使用 `GRANT` 来修改现有用户的密码不是其主要目的，并且可能会有权限上的限制或不确定的行为（例如，如果用户不存在，它会创建用户）。\nD) **The `mysql_config_editor` utility (D 错误)。** `mysql_config_editor` 工具是用于管理 `MySQL` 配置文件中加密的登录路径（login-path）。它存储连接信息（如用户、主机、端口、密码），以便客户端程序连接到 `MySQL` 服务器时不需要在命令行中输入密码。它修改的是**客户端的连接配置**，而不是服务器上用户的真实密码。\nE) **The `mysql_secure_installation` utility (E 错误)。** `mysql_secure_installation` 是一个交互式脚本，用于帮助用户执行一系列安全最佳实践，例如设置 `root` 密码、删除匿名用户、禁用远程 `root` 登录、删除测试数据库等。它主要用于**首次安全设置**，而不是日常修改用户密码的工具。它通常在安装 `MySQL` 后运行一次。\n\n**考点总结:**\n此题考察 `MySQL` 中管理用户密码的常用方法。核心考点在于区分直接在数据库中修改密码的 SQL 命令 (`ALTER USER`) 和命令行工具 (`mysqladmin`)，以及其他不用于修改数据库用户密码的工具 (`GRANT` 的主要作用、`mysql_config_editor`、`mysql_secure_installation`)。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n当遇到密码修改问题时，首先想到的是 `SQL` 语句 (`ALTER USER`) 和命令行管理工具 (`mysqladmin`)。其他选项，如 `GRANT` 主要用于授权，`mysql_config_editor` 用于客户端连接，`mysql_secure_installation` 用于初始安全设置，它们的目的不同。\n\n**学习建议:**\n1.  **用户账户管理：** 学习 `MySQL` 中用户账户的创建、修改和删除。掌握 `CREATE USER`, `ALTER USER`, `DROP USER` 等语句。\n2.  **权限管理：** 学习 `GRANT` 和 `REVOKE` 语句，理解它们与用户密码修改的区别。\n3.  **`mysqladmin` 工具：** 熟悉 `mysqladmin` 的常用子命令，包括 `password`、`shutdown`、`status` 等。\n4.  **`mysql_config_editor`：** 理解其作用是方便客户端连接，而不是修改数据库中的用户密码。\n5.  **`mysql_secure_installation`：** 了解其作为安全配置向导的作用。"
    },
    {
        "question": "### 试题 231:\n\nWhen does the `GRANT` take effect?",
        "selections": {
            "A": "Immediately",
            "B": "When Mark reconnects to the MySQL server",
            "C": "When Mark changes the default database",
            "D": "When the database administrator executes `FLUSH PRIVILEGES`"
        },
        "answers": [
            "B"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`GRANT` 语句用于授予用户权限。当数据库管理员（DBA）执行 `GRANT` 语句时，权限信息会被立即写入 `MySQL` 的授权表（例如 `mysql.user`, `mysql.db`, `mysql.tables_priv` 等）。然而，这些新的权限对于**当前已经连接的会话**并不会立即生效。会话在连接时会加载其权限信息。\n\nB) **When Mark reconnects to the MySQL server (B 正确)。** 当 `Mark` （或任何其他用户）重新连接到 `MySQL` 服务器时，服务器会重新读取其在授权表中的权限信息。此时，通过 `GRANT` 语句授予的新权限才会对其生效。这是 `MySQL` 权限生效的典型行为。\n\n错误选项分析：\nA) **Immediately。** 对于已存在的连接，新的 `GRANT` 权限不会立即生效。只有新连接才会获取到更新后的权限。\nC) **When Mark changes the default database。** 改变当前会话的默认数据库 (`USE database_name;`) 不会重新加载用户权限。权限的加载发生在连接建立时。\nD) **When the database administrator executes `FLUSH PRIVILEGES`。** `FLUSH PRIVILEGES` 命令会强制 `MySQL` 服务器重新加载授权表到内存中。这个命令通常在直接修改授权表后（例如通过 `INSERT` 或 `UPDATE` 语句而非 `GRANT`/`REVOKE`）使用，以使更改生效。对于 `GRANT` 和 `REVOKE` 语句，它们在执行时已经更新了授权表并通常会触发内部机制来通知服务器，因此**不需要**手动执行 `FLUSH PRIVILEGES` 来使权限生效。`FLUSH PRIVILEGES` 对已连接用户权限的刷新效果和重新连接类似，但对于 `GRANT` 语句而言，主要还是通过重新连接生效。在日常操作中，`GRANT` 语句本身已经具备了使其效果持久化并被新连接识别的能力。\n\n**考点总结:**\n此题考察 `MySQL` 权限管理中 `GRANT` 语句的生效时机。核心考点是理解 `GRANT` 语句会立即更新授权表，但对于现有连接，权限通常需要在**重新连接**后才能生效。同时，要区分 `GRANT` 语句与 `FLUSH PRIVILEGES` 命令的不同作用。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n关于 `MySQL` 权限生效的问题，记住一条黄金法则：**大多数权限更改对当前会话不会立即生效，需要重新连接**。`FLUSH PRIVILEGES` 虽然能重新加载权限表，但对于 `GRANT` 和 `REVOKE` 语句而言并非必要步骤。\n\n**学习建议:**\n1.  **理解 `MySQL` 权限体系：** 学习用户账户、权限级别（全局、数据库、表、列）、权限表（`mysql.user`, `mysql.db`, `mysql.tables_priv` 等）以及权限的存储方式。\n2.  **掌握 `GRANT` 和 `REVOKE` 语句：** 熟练使用这些语句授予和撤销权限。\n3.  **区分权限生效机制：**\n    * **新连接：** 始终会加载最新的权限。\n    * **当前连接：** `GRANT`/`REVOKE` 权限通常不会立即对当前连接生效（除了少数特殊情况，如 `PROXY` 权限）。\n    * **`FLUSH PRIVILEGES`：** 主要用于手动修改授权表后的重新加载，对于 `GRANT`/`REVOKE` 命令通常不是必需的。\n4.  **实践：** 创建用户、授予权限、然后尝试在同一会话和新会话中测试权限是否生效，以验证理解。"
    },
    {
        "question": "### 试题 232:\n\nYou want to run multiple MySQL instances on the same host machine. Which two `mysqld` options can share the same value?",
        "selections": {
            "A": "`basedir`",
            "B": "`datadir`",
            "C": "`socket`",
            "D": "`user`",
            "E": "`pid-file`"
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n在一台主机上运行多个 `MySQL` 实例（即多实例部署）时，每个实例都需要有其独立的配置，以避免资源冲突。然而，有些配置参数是可以共享的，或者说其值可以是相同的，而另一些则必须是独立的。\n\nA) **`basedir` (A 正确)。** `basedir` 参数指定 `MySQL` 的安装目录，即所有 `MySQL` 相关文件（如可执行文件、库文件、脚本等）的根目录。在同一台机器上，你通常只需要安装一份 `MySQL` 软件，然后从这个安装目录启动多个实例，每个实例可以有自己的数据目录。因此，多个 `MySQL` 实例可以共享同一个 `basedir` 值。\n\nD) **`user` (D 正确)。** `user` 参数指定 `mysqld` 进程以哪个操作系统用户身份运行。为了安全和管理方便，多个 `MySQL` 实例可以都以同一个非特权操作系统用户身份运行（例如 `mysql` 用户）。这通常是一个推荐的做法，因为它避免了为每个实例创建单独的操作系统用户账户的复杂性，并且可以统一管理权限。\n\n错误选项分析：\nB) **`datadir` (B 错误)。** `datadir` 参数指定 `MySQL` 实例的数据目录，其中包含数据库文件、表空间、日志文件等。**每个 `MySQL` 实例必须拥有一个独立的 `datadir`**，否则它们会尝试访问和修改同一套数据文件，导致数据损坏和冲突。\nC) **`socket` (C 错误)。** `socket` 参数指定 `MySQL` 服务器用于本地客户端连接的 `UNIX` 域套接字文件路径。在同一台 `UNIX/Linux` 主机上，`UNIX` 域套接字是文件，其路径必须是唯一的，因为它们代表了不同的通信端点。如果多个实例使用相同的 `socket` 文件，将会导致冲突和连接失败。\nE) **`pid-file` (E 错误)。** `pid-file` 参数指定 `MySQL` 服务器进程 ID (PID) 文件的路径。每个 `MySQL` 实例都是一个独立的进程，因此它会有一个唯一的 `PID`，并且其 `PID` 文件路径必须是唯一的，以避免覆盖和混淆。\n\n**考点总结:**\n此题考察 `MySQL` 多实例部署的关键配置，特别是哪些 `mysqld` 参数在多实例环境中必须是唯一的，哪些可以共享。核心考点是理解资源冲突和隔离在多实例部署中的重要性。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n在多实例部署中，记住以下原则：**凡是与实例运行时产生数据、日志、连接入口相关的文件或端口，都必须是唯一的**。而程序本身所在的目录 (`basedir`) 和运行进程的操作系统用户 (`user`) 则可以共享。\n\n**学习建议:**\n1.  **理解多实例部署的意义：** 为什么需要多实例？它的优势（资源隔离、版本测试）和挑战（配置复杂性）。\n2.  **核心配置参数：** 掌握在多实例部署中必须独立的参数：\n    * `port` (TCP/IP 端口，必须唯一)\n    * `socket` (UNIX 域套接字文件，必须唯一)\n    * `datadir` (数据目录，必须唯一)\n    * `pid-file` (进程ID文件，必须唯一)\n    * `log-error` (错误日志文件，必须唯一)\n    * `general_log_file` (通用查询日志文件，通常需要唯一)\n    * `slow_query_log_file` (慢查询日志文件，通常需要唯一)\n    * `log_bin` (二进制日志前缀，必须唯一)\n    * `server_id` (复制场景下必须唯一)\n3.  **可以共享的参数：** `basedir` (安装目录) 和 `user` (操作系统运行用户)。\n4.  **实践多实例配置：** 尝试在本地搭建多实例环境，手动配置 `my.cnf` 文件，并启动/停止不同实例，这将有助于加深理解。"
    },
    {
        "question": "### 试题 233:\n\nWhich two are benefits of using `mysqlpump` instead of `mysqldump` for databases with many large tables?",
        "selections": {
            "A": "`mysqlpump` does not lock the tables.",
            "B": "`mysqlpump` shows the dump progress.",
            "C": "`mysqlpump` reduces the backup time with multiple threads.",
            "D": "`mysqlpump` reduces the restore time with multiple threads.",
            "E": "`mysqlpump` can perform incremental backup."
        },
        "answers": [
            "B",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n`mysqlpump` 是 `MySQL 5.7` 引入的一个逻辑备份工具，旨在解决 `mysqldump` 在处理大型数据库时的一些局限性，特别是其在并发性和进度显示方面的不足。它是一个并行（多线程）备份工具，而 `mysqldump` 主要是单线程的。\n\nB) **`mysqlpump` shows the dump progress (B 正确)。** `mysqlpump` 在执行备份时，能够实时显示备份的进度信息，例如已备份的字节数、剩余时间等。这对于管理大型数据库的备份过程非常有用，因为 `mysqldump` 默认情况下没有这样的进度显示功能，用户无法直观地了解备份的进展。\n\nC) **`mysqlpump` reduces the backup time with multiple threads (C 正确)。** `mysqlpump` 的主要优势之一是其**并行（多线程）备份能力**。它可以使用多个线程同时备份不同的数据库或表，从而显著减少大型数据库的备份时间。相比之下，`mysqldump` 是单线程的，备份大型数据库时效率较低。\n\n错误选项分析：\nA) **`mysqlpump` does not lock the tables。** `mysqlpump` 和 `mysqldump` 都可以通过不同的方式来减少甚至避免对表的锁定，尤其是在使用 `InnoDB` 存储引擎时。它们通常会使用 `READ COMMITTED` 或 `REPEATABLE READ` 隔离级别（通过 `FOR EXPORT` 或 `START TRANSACTION ... WITH CONSISTENT SNAPSHOT`）来获取一致性快照，从而最小化对表的读写锁定。所以，说 `mysqlpump` **不**锁定表是不准确的，它仍然会获取必要的锁来确保数据一致性，只是其锁定策略更灵活或影响更小。这个描述并非其相对于 `mysqldump` 的独特优势。\nD) **`mysqlpump` reduces the restore time with multiple threads。** `mysqlpump` 生成的备份文件通常是 `SQL` 语句，导入（恢复）这些 `SQL` 文件通常使用 `mysql` 客户端工具。`mysqlpump` **本身不直接参与恢复过程**。虽然可以通过并行导入 `SQL` 文件来加速恢复，但这更多是 `mysql` 客户端（或自定义脚本）的功能，而非 `mysqlpump` 的直接利益。`mysqlpump` 的主要目的是加速**备份**。\nE) **`mysqlpump` can perform incremental backup。** `mysqlpump` 和 `mysqldump` 都属于逻辑备份工具，它们都**不能直接执行增量备份**。增量备份通常是物理备份工具（如 `MySQL Enterprise Backup` 或 `XtraBackup`）的功能，它们通过备份数据文件的修改部分来实现。逻辑备份工具通常生成完整的 `SQL` 导出文件。\n\n**考点总结:**\n此题考察 `mysqlpump` 相较于 `mysqldump` 的主要优势。核心考点在于理解 `mysqlpump` 作为并行备份工具，在**性能（通过多线程加速）**和**用户体验（进度显示）**方面的提升。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n将 `mysqlpump` 视为 `mysqldump` 的“增强版”或“并行版”。记住其主要优势在于**并行备份**（从而缩短备份时间）和**进度显示**。排除与增量备份或恢复时间直接相关的选项，因为这些不是 `mysqlpump` 的直接特点。\n\n**学习建议:**\n1.  **掌握 `mysqldump` 的基本用法：** 理解其单线程、生成 `SQL` 文本文件、以及如何处理 `InnoDB` 和 `MyISAM` 表的锁定。\n2.  **学习 `mysqlpump` 的特性：**\n    * **并行性：** 如何使用 `--default-parallelism` 或 `--parallel-databases` 等选项来控制并行度。\n    * **进度显示：** 了解其输出格式。\n    * **不同输出格式：** 除了 `SQL`，还可以输出其他格式。\n    * **过滤选项：** 支持更细粒度的包含/排除数据库和表。\n3.  **区分逻辑备份和物理备份：** 明确 `mysqldump` 和 `mysqlpump` 是逻辑备份工具，它们与 `mysqlbackup` (物理备份) 在功能和适用场景上的区别，特别是增量备份。\n4.  **备份和恢复策略：** 了解如何根据数据库大小、业务需求和可用资源选择合适的备份工具和策略。"
    },
    {
        "question": "### 试题 234:\n\nWhich MySQL client program can list all the current sessions connected to a MySQL server?",
        "selections": {
            "A": "`mysqladmin`",
            "B": "`mysqlbinlog`",
            "C": "`mysqlcheck`",
            "D": "`mysqlshow`",
            "E": "`mysqlslap`"
        },
        "answers": [
            "A"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n这道题目考察 `MySQL` 客户端工具的功能，特别是哪个工具能够查看当前连接到 `MySQL` 服务器的会话。\n\nA) **`mysqladmin` (A 正确)。** `mysqladmin` 是 `MySQL` 的一个命令行管理工具，可以执行各种管理操作，包括显示服务器状态。使用 `mysqladmin status` 或 `mysqladmin processlist` 命令可以查看当前连接到 `MySQL` 服务器的会话列表（进程列表）。`mysqladmin processlist` 是专门用于列出连接和它们正在执行的命令的。\n\n错误选项分析：\nB) **`mysqlbinlog` (B 错误)。** `mysqlbinlog` 工具用于处理和显示二进制日志文件的内容。它用于查看二进制日志中的事件，但不能列出当前连接的会话。\nC) **`mysqlcheck` (C 错误)。** `mysqlcheck` 工具用于检查、修复、优化和分析表。它执行的是表维护操作，与查看当前会话无关。\nD) **`mysqlshow` (D 错误)。** `mysqlshow` 工具用于快速查看数据库、表、列和索引的信息。它可以显示数据库和表的结构，但不能列出当前连接的会话。\nE) **`mysqlslap` (E 错误)。** `mysqlslap` 工具是一个用于模拟 `MySQL` 服务器负载并测试其性能的客户端工具。它用于性能测试和基准测试，与查看当前会话无关。\n\n**考点总结:**\n此题考察 `MySQL` 常用客户端工具的功能。核心考点是识别 `mysqladmin` 作为管理工具在查看服务器状态和进程列表方面的作用。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n将 `MySQL` 客户端工具按其主要功能进行分类。`mysqladmin` 是一个通用的管理工具，涵盖了服务器状态、进程管理等多个方面。遇到与“服务器管理”或“查看运行时信息”相关的题目时，首先考虑 `mysqladmin`。\n\n**学习建议:**\n1.  **熟悉 `MySQL` 常用客户端工具：**\n    * **`mysql`:** 命令行客户端，用于执行 `SQL` 语句。\n    * **`mysqldump`:** 逻辑备份工具。\n    * **`mysqlpump`:** 并行逻辑备份工具。\n    * **`mysqladmin`:** 服务器管理工具，可用于查看状态、进程、关闭服务器、修改密码等。\n    * **`mysqlbinlog`:** 查看和处理二进制日志。\n    * **`mysqlcheck`:** 表维护工具（检查、修复、优化、分析）。\n    * **`mysqlshow`:** 显示数据库对象信息。\n    * **`mysqlslap`:** 性能测试工具。\n2.  **了解每个工具的主要用途和常用选项：** 尤其是一些常见的管理命令，如 `mysqladmin status`、`mysqladmin processlist`。\n3.  **实践：** 在自己的 `MySQL` 环境中尝试运行这些命令，观察它们的输出和效果，加深理解。"
    },
    {
        "question": "### 试题 235:\n\nExamine this command which executes successfully on an `InnoDB` cluster:\n\n```sql\ndba.killSandboxInstance(3320)\n```\n\nWhich two are true?",
        "selections": {
            "A": "The sandbox instance is shut down gracefully.",
            "B": "The files of the sandbox instance are deleted.",
            "C": "The sandbox instance performs instance recovery when it restarts.",
            "D": "The method simulates an instance failure.",
            "E": "The method simulates a disk failure.",
            "F": "The method simulates a network failure."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n题目中提到的 `dba.killSandboxInstance(3320)` 是 `MySQL Shell` 中 `dba` (Database Administrator) 实用程序提供的一个函数，用于管理沙箱实例（Sandbox Instance）。沙箱实例通常是用于开发和测试目的的轻量级 `MySQL` 实例。`killSandboxInstance` 函数的设计目的是模拟一种**非正常终止**，即模拟崩溃。\n\nC) **The sandbox instance performs instance recovery when it restarts (C 正确)。** 当一个 `MySQL` 实例非正常终止（崩溃）时，`InnoDB` 存储引擎会在下次启动时自动执行**崩溃恢复（Crash Recovery）**。崩溃恢复利用 `redo logs` 来确保数据的一致性和持久性。由于 `killSandboxInstance` 模拟的是实例失败，所以重启后会执行崩溃恢复。\n\nD) **The method simulates an instance failure (D 正确)。** `killSandboxInstance` 的目的就是模拟一个 `MySQL` 实例突然停止（崩溃）的情况，而不是优雅地关机。这对于测试数据库的故障恢复能力和 `InnoDB` 的崩溃恢复机制非常有用。\n\n错误选项分析：\nA) **The sandbox instance is shut down gracefully。** `killSandboxInstance` 的名称和其设计目的（模拟失败）表明它是一个**非优雅关机**，更像是强制终止进程，而不是像 `mysqladmin shutdown` 那样的正常关机。正常关机会确保所有事务提交或回滚，并刷新所有数据到磁盘。\nB) **The files of the sandbox instance are deleted。** `killSandboxInstance` 函数只会停止或终止实例进程，**不会删除沙箱实例的数据文件或配置文件**。要删除沙箱实例，通常需要使用 `dba.dropSandboxInstance()` 函数。\nE) **The method simulates a disk failure。** 磁盘故障是存储层面的问题，`killSandboxInstance` 模拟的是 `MySQL` 进程本身的异常终止，而不是存储介质的故障。\nF) **The method simulates a network failure。** 网络故障是网络连接中断，`killSandboxInstance` 作用于本地 `MySQL` 进程，模拟的是进程层面的崩溃，与网络故障是不同的故障类型。\n\n**考点总结:**\n此题考察 `MySQL Shell` 中 `dba` 实用程序对沙箱实例的管理功能，特别是 `killSandboxInstance()` 函数的作用和它所模拟的故障类型。核心考点是理解该函数旨在模拟**实例崩溃（instance failure）**，从而触发 `InnoDB` 的**崩溃恢复（instance recovery）**。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n`kill` 通常暗示着非正常终止或强制杀死。当看到 `killSandboxInstance` 这样的函数名时，应联想到它模拟的是**实例失败/崩溃**，而不是优雅关机。而实例崩溃必然会触发 `InnoDB` 的**崩溃恢复**。\n\n**学习建议:**\n1.  **了解 `MySQL Shell` 和 `dba` 实用程序：** 熟悉 `MySQL Shell` 作为 `MySQL` 高级管理工具的功能，特别是 `dba` 实用程序提供的自动化部署、管理 `InnoDB Cluster`、`InnoDB ReplicaSet` 和沙箱实例的功能。\n2.  **理解沙箱实例：** 知道沙箱实例是用于测试和开发目的的轻量级 `MySQL` 实例，以及它们如何通过 `MySQL Shell` 快速部署和管理。\n3.  **区分不同的实例管理操作：**\n    * **启动：** `dba.deploySandboxInstance()`\n    * **停止/杀死：** `dba.killSandboxInstance()` (模拟崩溃), `dba.stopSandboxInstance()` (优雅停止)\n    * **删除：** `dba.dropSandboxInstance()`\n4.  **掌握 `InnoDB` 的崩溃恢复机制：** 了解 `redo log` 在崩溃恢复中的作用，以及 `MySQL` 如何在非正常关机后自动执行恢复。\n5.  **实践：** 在测试环境中部署和使用沙箱实例，并尝试使用 `killSandboxInstance()` 来观察崩溃恢复的过程。"
    },
    {
        "question": "### 试题 236:\n\nThis is the structure of the employees table:\n\n```sql\nCREATE TABLE employees (\n  emp_no INT UNSIGNED NOT NULL,\n  job_title VARCHAR(50),\n  last_name VARCHAR(50),\n  first_name VARCHAR(50),\n  PRIMARY KEY (emp_no),\n  KEY job_title(job_title,last_name,first_name)\n);\n```\n\nWhich two queries can take advantage of existing indexes to avoid a filesort?",
        "selections": {
            "A": "`SELECT * FROM employees WHERE job_title='Manager' ORDER BY last_name`",
            "B": "`SELECT * FROM employees WHERE job_title='Manager' ORDER BY first_name`",
            "C": "`SELECT * FROM employees WHERE last_name='Smith' ORDER BY first_name`",
            "D": "`SELECT job_title, COUNT(*) FROM employees GROUP BY job_title ORDER BY job_title`",
            "E": "`SELECT first_name, COUNT(*) FROM employees GROUP BY first_name ORDER BY first_name`"
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n本题考察 `MySQL` 优化器如何利用索引来避免 `filesort` 操作。`filesort` 是一种消耗资源的操作，发生在 `ORDER BY` 或 `GROUP BY` 的列无法通过现有索引直接满足排序或分组需求时。`MySQL` 可以利用索引的有序性来直接获取排序/分组好的结果。\n\n表中有一个复合索引 `KEY job_title(job_title,last_name,first_name)`。\n\n**索引的特点是：从左到右，列的顺序很重要。只有当查询条件或排序/分组的列**符合索引的前缀**时，才能有效利用索引的有序性。\n\nA) **`SELECT * FROM employees WHERE job_title='Manager' ORDER BY last_name` (A 正确)。**\n    * `WHERE job_title='Manager'`：使用了索引的第一个列 `job_title` 进行等值查询，这使得索引的剩余部分 (`last_name, first_name`) 在 `job_title='Manager'` 的这个固定值下是排序好的。\n    * `ORDER BY last_name`：`last_name` 是复合索引的第二个列。在 `job_title` 固定时，`last_name` 在索引中是有序的。因此，优化器可以直接利用索引的顺序来满足 `ORDER BY` 子句，避免 `filesort`。\n\nD) **`SELECT job_title, COUNT(*) FROM employees GROUP BY job_title ORDER BY job_title` (D 正确)。**\n    * `GROUP BY job_title`：`job_title` 是复合索引的第一个列。`MySQL` 可以直接利用索引 `job_title` 的有序性进行分组，而不需要创建临时表进行 `filesort`。\n    * `ORDER BY job_title`：`job_title` 也是索引的第一个列。由于 `GROUP BY` 已经通过索引满足了 `job_title` 的有序性，`ORDER BY job_title` 也可以直接利用索引的顺序，从而避免 `filesort`。\n\n错误选项分析：\nB) **`SELECT * FROM employees WHERE job_title='Manager' ORDER BY first_name` (B 错误)。**\n    * `WHERE job_title='Manager'`：使用了索引的第一个列 `job_title` 进行等值查询。\n    * `ORDER BY first_name`：`first_name` 是复合索引的第三个列。虽然 `job_title` 固定了，但 `first_name` 在 `last_name` 之前并不是有序的（只有当 `job_title` 和 `last_name` 都确定后，`first_name` 才有序）。因此，此查询无法直接利用索引来满足 `first_name` 的排序，可能需要 `filesort`。\n\nC) **`SELECT * FROM employees WHERE last_name='Smith' ORDER BY first_name` (C 错误)。**\n    * `WHERE last_name='Smith'`：查询条件直接跳过了复合索引的第一个列 `job_title`。这意味着 `MySQL` 无法直接利用这个复合索引来过滤 `last_name`，也无法利用其有序性来满足 `ORDER BY`。\n    * 即使 `last_name` 被过滤，`first_name` 也不在 `last_name` 后面直接有序，除非 `job_title` 固定。\n    * 这种情况下，`MySQL` 可能会进行全表扫描或利用其他索引（如果有），但不能通过这个复合索引来避免 `filesort`。\n\nE) **`SELECT first_name, COUNT(*) FROM employees GROUP BY first_name ORDER BY first_name` (E 错误)。**\n    * `GROUP BY first_name`：`first_name` 是复合索引的第三个列。直接对 `first_name` 进行分组，无法利用复合索引 `(job_title,last_name,first_name)` 的前缀有序性。`MySQL` 需要进行 `filesort` 来完成分组和排序。\n\n**考点总结:**\n此题考察 `MySQL` 优化器对复合索引的利用，特别是如何使用索引来优化 `WHERE`、`ORDER BY` 和 `GROUP BY` 子句，从而避免 `filesort`。核心在于理解复合索引的**最左前缀原则**和**有序性**。\n\n`ORDER BY` 或 `GROUP BY` 能够利用索引的条件是：\n1.  `ORDER BY` 或 `GROUP BY` 的列是索引的最左前缀。\n2.  `ORDER BY` 或 `GROUP BY` 的列是索引的连续部分，且其前面的索引列都被用于**等值查询**。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n分析 `ORDER BY` 或 `GROUP BY` 子句时，要对照索引的定义。如果排序/分组的列与索引的前缀（或在索引前缀等值查询后）匹配，则可以避免 `filesort`。特别是对于复合索引，记住“最左前缀匹配”原则对于 `WHERE`、`ORDER BY` 和 `GROUP BY` 都非常重要。\n\n**学习建议:**\n1.  **深入理解索引原理：** 学习 `B-tree` 索引的结构和有序性。\n2.  **掌握复合索引（组合索引）的创建和使用：** 理解最左前缀原则，以及它如何影响查询优化。\n3.  **分析 `EXPLAIN` 输出：** 学习如何通过 `EXPLAIN` 输出中的 `Extra` 列来判断是否发生了 `filesort` (例如 `Using filesort`)。\n4.  **优化 `ORDER BY` 和 `GROUP BY`：**\n    * 如果 `WHERE` 子句使用了索引的一部分，那么 `ORDER BY` 可以继续使用索引的下一部分。\n    * `ORDER BY` 的列必须与索引的顺序和方向（ASC/DESC）一致。\n    * `GROUP BY` 可以在某些情况下直接使用索引的有序性，避免 `filesort`。\n5.  **实践：** 创建包含复合索引的表，然后执行各种 `SELECT` 语句（包含 `WHERE`、`ORDER BY`、`GROUP BY`），并使用 `EXPLAIN` 命令分析其执行计划，观察 `filesort` 是否被避免。"
    }
  ]
